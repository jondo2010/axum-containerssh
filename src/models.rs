#![allow(unused_qualifications)]

use http::HeaderValue;
use validator::Validate;

#[cfg(feature = "server")]
use crate::header;
use crate::{models, types::*};

      
      
      
      





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Affinity {
    #[serde(rename = "nodeAffinity")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_affinity: Option<models::NodeAffinity>,

    #[serde(rename = "podAffinity")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pod_affinity: Option<models::PodAffinity>,

    #[serde(rename = "podAntiAffinity")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pod_anti_affinity: Option<models::PodAntiAffinity>,

}


impl Affinity {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Affinity {
        Affinity {
            node_affinity: None,
            pod_affinity: None,
            pod_anti_affinity: None,
        }
    }
}

/// Converts the Affinity value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Affinity {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping nodeAffinity in query parameter serialization

            // Skipping podAffinity in query parameter serialization

            // Skipping podAntiAffinity in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Affinity value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Affinity {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub node_affinity: Vec<models::NodeAffinity>,
            pub pod_affinity: Vec<models::PodAffinity>,
            pub pod_anti_affinity: Vec<models::PodAntiAffinity>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Affinity".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "nodeAffinity" => intermediate_rep.node_affinity.push(<models::NodeAffinity as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "podAffinity" => intermediate_rep.pod_affinity.push(<models::PodAffinity as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "podAntiAffinity" => intermediate_rep.pod_anti_affinity.push(<models::PodAntiAffinity as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Affinity".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Affinity {
            node_affinity: intermediate_rep.node_affinity.into_iter().next(),
            pod_affinity: intermediate_rep.pod_affinity.into_iter().next(),
            pod_anti_affinity: intermediate_rep.pod_anti_affinity.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Affinity> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Affinity>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Affinity>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Affinity - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Affinity> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Affinity as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Affinity - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// goland:noinspection GoDeprecation



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AppConfig {
    #[serde(rename = "backend")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub backend: Option<String>,

    #[serde(rename = "docker")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub docker: Option<models::DockerConfig>,

/// DockerRun is a placeholder for the removed DockerRun backend. Filling this with anything but nil will yield a validation error.
    #[serde(rename = "dockerrun")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dockerrun: Option<crate::types::Object>,

    #[serde(rename = "health")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub health: Option<models::HealthConfig>,

    #[serde(rename = "kubernetes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kubernetes: Option<models::KubernetesConfig>,

/// KubeRun is a placeholder for the removed DockerRun backend. Filling this with anything but nil will yield a validation error.
    #[serde(rename = "kuberun")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kuberun: Option<crate::types::Object>,

    #[serde(rename = "security")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub security: Option<models::SecurityConfig>,

    #[serde(rename = "sshproxy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sshproxy: Option<models::SshProxyConfig>,

}


impl AppConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AppConfig {
        AppConfig {
            backend: None,
            docker: None,
            dockerrun: None,
            health: None,
            kubernetes: None,
            kuberun: None,
            security: None,
            sshproxy: None,
        }
    }
}

/// Converts the AppConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AppConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.backend.as_ref().map(|backend| {
                [
                    "backend".to_string(),
                    backend.to_string(),
                ].join(",")
            }),

            // Skipping docker in query parameter serialization

            // Skipping dockerrun in query parameter serialization

            // Skipping health in query parameter serialization

            // Skipping kubernetes in query parameter serialization

            // Skipping kuberun in query parameter serialization

            // Skipping security in query parameter serialization

            // Skipping sshproxy in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AppConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AppConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub backend: Vec<String>,
            pub docker: Vec<models::DockerConfig>,
            pub dockerrun: Vec<crate::types::Object>,
            pub health: Vec<models::HealthConfig>,
            pub kubernetes: Vec<models::KubernetesConfig>,
            pub kuberun: Vec<crate::types::Object>,
            pub security: Vec<models::SecurityConfig>,
            pub sshproxy: Vec<models::SshProxyConfig>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AppConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "backend" => intermediate_rep.backend.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "docker" => intermediate_rep.docker.push(<models::DockerConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dockerrun" => intermediate_rep.dockerrun.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "health" => intermediate_rep.health.push(<models::HealthConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "kubernetes" => intermediate_rep.kubernetes.push(<models::KubernetesConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "kuberun" => intermediate_rep.kuberun.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "security" => intermediate_rep.security.push(<models::SecurityConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sshproxy" => intermediate_rep.sshproxy.push(<models::SshProxyConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AppConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AppConfig {
            backend: intermediate_rep.backend.into_iter().next(),
            docker: intermediate_rep.docker.into_iter().next(),
            dockerrun: intermediate_rep.dockerrun.into_iter().next(),
            health: intermediate_rep.health.into_iter().next(),
            kubernetes: intermediate_rep.kubernetes.into_iter().next(),
            kuberun: intermediate_rep.kuberun.into_iter().next(),
            security: intermediate_rep.security.into_iter().next(),
            sshproxy: intermediate_rep.sshproxy.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AppConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AppConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AppConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AppConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AppConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AppConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AppConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// AuthConfig contains authorization information for connecting to a Registry



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuthConfig {
    #[serde(rename = "auth")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auth: Option<String>,

/// Email is an optional value associated with the username. This field is deprecated and will be removed in a later version of docker.
    #[serde(rename = "email")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,

/// IdentityToken is used to authenticate the user and get an access token for the registry.
    #[serde(rename = "identitytoken")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub identitytoken: Option<String>,

    #[serde(rename = "password")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub password: Option<String>,

/// RegistryToken is a bearer token to be sent to a registry
    #[serde(rename = "registrytoken")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub registrytoken: Option<String>,

    #[serde(rename = "serveraddress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub serveraddress: Option<String>,

    #[serde(rename = "username")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub username: Option<String>,

}


impl AuthConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuthConfig {
        AuthConfig {
            auth: None,
            email: None,
            identitytoken: None,
            password: None,
            registrytoken: None,
            serveraddress: None,
            username: None,
        }
    }
}

/// Converts the AuthConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AuthConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.auth.as_ref().map(|auth| {
                [
                    "auth".to_string(),
                    auth.to_string(),
                ].join(",")
            }),


            self.email.as_ref().map(|email| {
                [
                    "email".to_string(),
                    email.to_string(),
                ].join(",")
            }),


            self.identitytoken.as_ref().map(|identitytoken| {
                [
                    "identitytoken".to_string(),
                    identitytoken.to_string(),
                ].join(",")
            }),


            self.password.as_ref().map(|password| {
                [
                    "password".to_string(),
                    password.to_string(),
                ].join(",")
            }),


            self.registrytoken.as_ref().map(|registrytoken| {
                [
                    "registrytoken".to_string(),
                    registrytoken.to_string(),
                ].join(",")
            }),


            self.serveraddress.as_ref().map(|serveraddress| {
                [
                    "serveraddress".to_string(),
                    serveraddress.to_string(),
                ].join(",")
            }),


            self.username.as_ref().map(|username| {
                [
                    "username".to_string(),
                    username.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuthConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuthConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub auth: Vec<String>,
            pub email: Vec<String>,
            pub identitytoken: Vec<String>,
            pub password: Vec<String>,
            pub registrytoken: Vec<String>,
            pub serveraddress: Vec<String>,
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuthConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "auth" => intermediate_rep.auth.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "email" => intermediate_rep.email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "identitytoken" => intermediate_rep.identitytoken.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "password" => intermediate_rep.password.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "registrytoken" => intermediate_rep.registrytoken.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "serveraddress" => intermediate_rep.serveraddress.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuthConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuthConfig {
            auth: intermediate_rep.auth.into_iter().next(),
            email: intermediate_rep.email.into_iter().next(),
            identitytoken: intermediate_rep.identitytoken.into_iter().next(),
            password: intermediate_rep.password.into_iter().next(),
            registrytoken: intermediate_rep.registrytoken.into_iter().next(),
            serveraddress: intermediate_rep.serveraddress.into_iter().next(),
            username: intermediate_rep.username.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuthConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuthConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuthConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AuthConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuthConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuthConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AuthConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuthResponseBody {
/// AuthenticatedUsername contains the username that was actually verified. This may differ from LoginUsername when, for example OAuth2 or Kerberos authentication is used. This field is empty until the authentication phase is completed.
    #[serde(rename = "authenticatedUsername")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub authenticated_username: Option<String>,

/// ClientVersion contains the version string the connecting client sent if any. May be empty if the client did not provide a client version.
    #[serde(rename = "clientVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_version: Option<String>,

/// ConnectionID is an opaque ID to identify the SSH connection in question.
    #[serde(rename = "connectionId")]
    pub connection_id: String,

/// Environment is a set of key-value pairs provided by the authentication or configuration system and may be exposed by the backend.
    #[serde(rename = "environment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<std::collections::HashMap<String, models::MetadataValue>>,

/// Files is a key-value pair of file names and their content set by the authentication or configuration system and consumed by the backend.
    #[serde(rename = "files")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub files: Option<std::collections::HashMap<String, models::BinaryMetadataValue>>,

/// Metadata is a set of key-value pairs that carry additional information from the authentication and configuration system to the backends. Backends can expose this information as container labels, environment variables, or other places.
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, models::MetadataValue>>,

/// RemoteAddress is the IP address and port of the user trying to authenticate.
    #[serde(rename = "remoteAddress")]
    pub remote_address: String,

/// Success indicates if the authentication was successful.
    #[serde(rename = "success")]
    pub success: bool,

/// Username is the username provided on login by the client. This may, but must not necessarily match the authenticated username.
    #[serde(rename = "username")]
    pub username: String,

}


impl AuthResponseBody {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(connection_id: String, remote_address: String, success: bool, username: String, ) -> AuthResponseBody {
        AuthResponseBody {
            authenticated_username: None,
            client_version: None,
            connection_id,
            environment: None,
            files: None,
            metadata: None,
            remote_address,
            success,
            username,
        }
    }
}

/// Converts the AuthResponseBody value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AuthResponseBody {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.authenticated_username.as_ref().map(|authenticated_username| {
                [
                    "authenticatedUsername".to_string(),
                    authenticated_username.to_string(),
                ].join(",")
            }),


            self.client_version.as_ref().map(|client_version| {
                [
                    "clientVersion".to_string(),
                    client_version.to_string(),
                ].join(",")
            }),


            Some("connectionId".to_string()),
            Some(self.connection_id.to_string()),

            // Skipping environment in query parameter serialization
            // Skipping environment in query parameter serialization

            // Skipping files in query parameter serialization
            // Skipping files in query parameter serialization

            // Skipping metadata in query parameter serialization
            // Skipping metadata in query parameter serialization


            Some("remoteAddress".to_string()),
            Some(self.remote_address.to_string()),


            Some("success".to_string()),
            Some(self.success.to_string()),


            Some("username".to_string()),
            Some(self.username.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuthResponseBody value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuthResponseBody {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub authenticated_username: Vec<String>,
            pub client_version: Vec<String>,
            pub connection_id: Vec<String>,
            pub environment: Vec<std::collections::HashMap<String, models::MetadataValue>>,
            pub files: Vec<std::collections::HashMap<String, models::BinaryMetadataValue>>,
            pub metadata: Vec<std::collections::HashMap<String, models::MetadataValue>>,
            pub remote_address: Vec<String>,
            pub success: Vec<bool>,
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuthResponseBody".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "authenticatedUsername" => intermediate_rep.authenticated_username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "clientVersion" => intermediate_rep.client_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "connectionId" => intermediate_rep.connection_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "environment" => return std::result::Result::Err("Parsing a container in this style is not supported in AuthResponseBody".to_string()),
                    "files" => return std::result::Result::Err("Parsing a container in this style is not supported in AuthResponseBody".to_string()),
                    "metadata" => return std::result::Result::Err("Parsing a container in this style is not supported in AuthResponseBody".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "remoteAddress" => intermediate_rep.remote_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "success" => intermediate_rep.success.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuthResponseBody".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuthResponseBody {
            authenticated_username: intermediate_rep.authenticated_username.into_iter().next(),
            client_version: intermediate_rep.client_version.into_iter().next(),
            connection_id: intermediate_rep.connection_id.into_iter().next().ok_or_else(|| "connectionId missing in AuthResponseBody".to_string())?,
            environment: intermediate_rep.environment.into_iter().next(),
            files: intermediate_rep.files.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
            remote_address: intermediate_rep.remote_address.into_iter().next().ok_or_else(|| "remoteAddress missing in AuthResponseBody".to_string())?,
            success: intermediate_rep.success.into_iter().next().ok_or_else(|| "success missing in AuthResponseBody".to_string())?,
            username: intermediate_rep.username.into_iter().next().ok_or_else(|| "username missing in AuthResponseBody".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuthResponseBody> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuthResponseBody>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuthResponseBody>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AuthResponseBody - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuthResponseBody> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuthResponseBody as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AuthResponseBody - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// AuthenticateOKBody authenticate o k body



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuthenticateOkBody {
/// An opaque token used to authenticate a user after a successful login
    #[serde(rename = "IdentityToken")]
    pub identity_token: String,

/// The status of the authentication
    #[serde(rename = "Status")]
    pub status: String,

}


impl AuthenticateOkBody {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(identity_token: String, status: String, ) -> AuthenticateOkBody {
        AuthenticateOkBody {
            identity_token,
            status,
        }
    }
}

/// Converts the AuthenticateOkBody value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AuthenticateOkBody {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("IdentityToken".to_string()),
            Some(self.identity_token.to_string()),


            Some("Status".to_string()),
            Some(self.status.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuthenticateOkBody value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuthenticateOkBody {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub identity_token: Vec<String>,
            pub status: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuthenticateOkBody".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "IdentityToken" => intermediate_rep.identity_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuthenticateOkBody".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuthenticateOkBody {
            identity_token: intermediate_rep.identity_token.into_iter().next().ok_or_else(|| "IdentityToken missing in AuthenticateOkBody".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "Status missing in AuthenticateOkBody".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuthenticateOkBody> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuthenticateOkBody>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuthenticateOkBody>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AuthenticateOkBody - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuthenticateOkBody> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuthenticateOkBody as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AuthenticateOkBody - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// AuthorizationRequest is the authorization request used after some authentication methods (e.g. kerberos) to determine whether users are allowed to access the service



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuthorizationRequest {
/// AuthenticatedUsername contains the username that was actually verified. This may differ from LoginUsername when, for example OAuth2 or Kerberos authentication is used. This field is empty until the authentication phase is completed.
    #[serde(rename = "authenticatedUsername")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub authenticated_username: Option<String>,

/// ClientVersion contains the version string the connecting client sent if any. May be empty if the client did not provide a client version.
    #[serde(rename = "clientVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_version: Option<String>,

/// ConnectionID is an opaque ID to identify the SSH connection in question.
    #[serde(rename = "connectionId")]
    pub connection_id: String,

/// Environment is a set of key-value pairs provided by the authentication or configuration system and may be exposed by the backend.
    #[serde(rename = "environment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<std::collections::HashMap<String, models::MetadataValue>>,

/// Files is a key-value pair of file names and their content set by the authentication or configuration system and consumed by the backend.
    #[serde(rename = "files")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub files: Option<std::collections::HashMap<String, models::BinaryMetadataValue>>,

/// Metadata is a set of key-value pairs that carry additional information from the authentication and configuration system to the backends. Backends can expose this information as container labels, environment variables, or other places.
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, models::MetadataValue>>,

/// RemoteAddress is the IP address and port of the user trying to authenticate.
    #[serde(rename = "remoteAddress")]
    pub remote_address: String,

/// Username is the username provided on login by the client. This may, but must not necessarily match the authenticated username.
    #[serde(rename = "username")]
    pub username: String,

}


impl AuthorizationRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(connection_id: String, remote_address: String, username: String, ) -> AuthorizationRequest {
        AuthorizationRequest {
            authenticated_username: None,
            client_version: None,
            connection_id,
            environment: None,
            files: None,
            metadata: None,
            remote_address,
            username,
        }
    }
}

/// Converts the AuthorizationRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AuthorizationRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.authenticated_username.as_ref().map(|authenticated_username| {
                [
                    "authenticatedUsername".to_string(),
                    authenticated_username.to_string(),
                ].join(",")
            }),


            self.client_version.as_ref().map(|client_version| {
                [
                    "clientVersion".to_string(),
                    client_version.to_string(),
                ].join(",")
            }),


            Some("connectionId".to_string()),
            Some(self.connection_id.to_string()),

            // Skipping environment in query parameter serialization
            // Skipping environment in query parameter serialization

            // Skipping files in query parameter serialization
            // Skipping files in query parameter serialization

            // Skipping metadata in query parameter serialization
            // Skipping metadata in query parameter serialization


            Some("remoteAddress".to_string()),
            Some(self.remote_address.to_string()),


            Some("username".to_string()),
            Some(self.username.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuthorizationRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuthorizationRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub authenticated_username: Vec<String>,
            pub client_version: Vec<String>,
            pub connection_id: Vec<String>,
            pub environment: Vec<std::collections::HashMap<String, models::MetadataValue>>,
            pub files: Vec<std::collections::HashMap<String, models::BinaryMetadataValue>>,
            pub metadata: Vec<std::collections::HashMap<String, models::MetadataValue>>,
            pub remote_address: Vec<String>,
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuthorizationRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "authenticatedUsername" => intermediate_rep.authenticated_username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "clientVersion" => intermediate_rep.client_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "connectionId" => intermediate_rep.connection_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "environment" => return std::result::Result::Err("Parsing a container in this style is not supported in AuthorizationRequest".to_string()),
                    "files" => return std::result::Result::Err("Parsing a container in this style is not supported in AuthorizationRequest".to_string()),
                    "metadata" => return std::result::Result::Err("Parsing a container in this style is not supported in AuthorizationRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "remoteAddress" => intermediate_rep.remote_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuthorizationRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuthorizationRequest {
            authenticated_username: intermediate_rep.authenticated_username.into_iter().next(),
            client_version: intermediate_rep.client_version.into_iter().next(),
            connection_id: intermediate_rep.connection_id.into_iter().next().ok_or_else(|| "connectionId missing in AuthorizationRequest".to_string())?,
            environment: intermediate_rep.environment.into_iter().next(),
            files: intermediate_rep.files.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
            remote_address: intermediate_rep.remote_address.into_iter().next().ok_or_else(|| "remoteAddress missing in AuthorizationRequest".to_string())?,
            username: intermediate_rep.username.into_iter().next().ok_or_else(|| "username missing in AuthorizationRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuthorizationRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuthorizationRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuthorizationRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AuthorizationRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuthorizationRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuthorizationRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AuthorizationRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// An AWS EBS disk must exist before mounting to a container. The disk must also be in the same AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS volumes support ownership management and SELinux relabeling.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AwsElasticBlockStoreVolumeSource {
/// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine +optional
    #[serde(rename = "fsType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fs_type: Option<String>,

/// The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or you can leave the property empty). +optional
    #[serde(rename = "partition")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partition: Option<i32>,

/// Specify \"true\" to force and set the ReadOnly property in VolumeMounts to \"true\". If omitted, the default is \"false\". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore +optional
    #[serde(rename = "readOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

/// Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
    #[serde(rename = "volumeID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_id: Option<String>,

}


impl AwsElasticBlockStoreVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AwsElasticBlockStoreVolumeSource {
        AwsElasticBlockStoreVolumeSource {
            fs_type: None,
            partition: None,
            read_only: None,
            volume_id: None,
        }
    }
}

/// Converts the AwsElasticBlockStoreVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AwsElasticBlockStoreVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.fs_type.as_ref().map(|fs_type| {
                [
                    "fsType".to_string(),
                    fs_type.to_string(),
                ].join(",")
            }),


            self.partition.as_ref().map(|partition| {
                [
                    "partition".to_string(),
                    partition.to_string(),
                ].join(",")
            }),


            self.read_only.as_ref().map(|read_only| {
                [
                    "readOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),


            self.volume_id.as_ref().map(|volume_id| {
                [
                    "volumeID".to_string(),
                    volume_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AwsElasticBlockStoreVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AwsElasticBlockStoreVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub fs_type: Vec<String>,
            pub partition: Vec<i32>,
            pub read_only: Vec<bool>,
            pub volume_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AwsElasticBlockStoreVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "fsType" => intermediate_rep.fs_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partition" => intermediate_rep.partition.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "readOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "volumeID" => intermediate_rep.volume_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AwsElasticBlockStoreVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AwsElasticBlockStoreVolumeSource {
            fs_type: intermediate_rep.fs_type.into_iter().next(),
            partition: intermediate_rep.partition.into_iter().next(),
            read_only: intermediate_rep.read_only.into_iter().next(),
            volume_id: intermediate_rep.volume_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AwsElasticBlockStoreVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AwsElasticBlockStoreVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AwsElasticBlockStoreVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AwsElasticBlockStoreVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AwsElasticBlockStoreVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AwsElasticBlockStoreVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AwsElasticBlockStoreVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// +enum
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AzureDataDiskCachingMode(String);

impl validator::Validate for AzureDataDiskCachingMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for AzureDataDiskCachingMode {
    fn from(x: String) -> Self {
        AzureDataDiskCachingMode(x)
    }
}

impl std::string::ToString for AzureDataDiskCachingMode {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for AzureDataDiskCachingMode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(AzureDataDiskCachingMode(x.to_string()))
    }
}

impl std::convert::From<AzureDataDiskCachingMode> for String {
    fn from(x: AzureDataDiskCachingMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for AzureDataDiskCachingMode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for AzureDataDiskCachingMode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// +enum
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AzureDataDiskKind(String);

impl validator::Validate for AzureDataDiskKind {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for AzureDataDiskKind {
    fn from(x: String) -> Self {
        AzureDataDiskKind(x)
    }
}

impl std::string::ToString for AzureDataDiskKind {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for AzureDataDiskKind {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(AzureDataDiskKind(x.to_string()))
    }
}

impl std::convert::From<AzureDataDiskKind> for String {
    fn from(x: AzureDataDiskKind) -> Self {
        x.0
    }
}

impl std::ops::Deref for AzureDataDiskKind {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for AzureDataDiskKind {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AzureDiskVolumeSource {
/// +enum
    #[serde(rename = "cachingMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub caching_mode: Option<String>,

/// The Name of the data disk in the blob storage
    #[serde(rename = "diskName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub disk_name: Option<String>,

/// The URI the data disk in the blob storage
    #[serde(rename = "diskURI")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub disk_uri: Option<String>,

/// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. +optional
    #[serde(rename = "fsType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fs_type: Option<String>,

/// +enum
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kind: Option<String>,

/// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. +optional
    #[serde(rename = "readOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

}


impl AzureDiskVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AzureDiskVolumeSource {
        AzureDiskVolumeSource {
            caching_mode: None,
            disk_name: None,
            disk_uri: None,
            fs_type: None,
            kind: None,
            read_only: None,
        }
    }
}

/// Converts the AzureDiskVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AzureDiskVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.caching_mode.as_ref().map(|caching_mode| {
                [
                    "cachingMode".to_string(),
                    caching_mode.to_string(),
                ].join(",")
            }),


            self.disk_name.as_ref().map(|disk_name| {
                [
                    "diskName".to_string(),
                    disk_name.to_string(),
                ].join(",")
            }),


            self.disk_uri.as_ref().map(|disk_uri| {
                [
                    "diskURI".to_string(),
                    disk_uri.to_string(),
                ].join(",")
            }),


            self.fs_type.as_ref().map(|fs_type| {
                [
                    "fsType".to_string(),
                    fs_type.to_string(),
                ].join(",")
            }),


            self.kind.as_ref().map(|kind| {
                [
                    "kind".to_string(),
                    kind.to_string(),
                ].join(",")
            }),


            self.read_only.as_ref().map(|read_only| {
                [
                    "readOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AzureDiskVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AzureDiskVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub caching_mode: Vec<String>,
            pub disk_name: Vec<String>,
            pub disk_uri: Vec<String>,
            pub fs_type: Vec<String>,
            pub kind: Vec<String>,
            pub read_only: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AzureDiskVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "cachingMode" => intermediate_rep.caching_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "diskName" => intermediate_rep.disk_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "diskURI" => intermediate_rep.disk_uri.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fsType" => intermediate_rep.fs_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "kind" => intermediate_rep.kind.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "readOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AzureDiskVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AzureDiskVolumeSource {
            caching_mode: intermediate_rep.caching_mode.into_iter().next(),
            disk_name: intermediate_rep.disk_name.into_iter().next(),
            disk_uri: intermediate_rep.disk_uri.into_iter().next(),
            fs_type: intermediate_rep.fs_type.into_iter().next(),
            kind: intermediate_rep.kind.into_iter().next(),
            read_only: intermediate_rep.read_only.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AzureDiskVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AzureDiskVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AzureDiskVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AzureDiskVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AzureDiskVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AzureDiskVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AzureDiskVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AzureFileVolumeSource {
/// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. +optional
    #[serde(rename = "readOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

/// the name of secret that contains Azure Storage Account Name and Key
    #[serde(rename = "secretName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_name: Option<String>,

/// Share Name
    #[serde(rename = "shareName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub share_name: Option<String>,

}


impl AzureFileVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AzureFileVolumeSource {
        AzureFileVolumeSource {
            read_only: None,
            secret_name: None,
            share_name: None,
        }
    }
}

/// Converts the AzureFileVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AzureFileVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.read_only.as_ref().map(|read_only| {
                [
                    "readOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),


            self.secret_name.as_ref().map(|secret_name| {
                [
                    "secretName".to_string(),
                    secret_name.to_string(),
                ].join(",")
            }),


            self.share_name.as_ref().map(|share_name| {
                [
                    "shareName".to_string(),
                    share_name.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AzureFileVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AzureFileVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub read_only: Vec<bool>,
            pub secret_name: Vec<String>,
            pub share_name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AzureFileVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "readOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "secretName" => intermediate_rep.secret_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shareName" => intermediate_rep.share_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AzureFileVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AzureFileVolumeSource {
            read_only: intermediate_rep.read_only.into_iter().next(),
            secret_name: intermediate_rep.secret_name.into_iter().next(),
            share_name: intermediate_rep.share_name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AzureFileVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AzureFileVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AzureFileVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AzureFileVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AzureFileVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AzureFileVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AzureFileVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Backend(String);

impl validator::Validate for Backend {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for Backend {
    fn from(x: String) -> Self {
        Backend(x)
    }
}

impl std::string::ToString for Backend {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for Backend {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Backend(x.to_string()))
    }
}

impl std::convert::From<Backend> for String {
    fn from(x: Backend) -> Self {
        x.0
    }
}

impl std::ops::Deref for Backend {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Backend {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BinaryMetadataValue {
/// Sensitive indicates that the metadata value contains sensitive data and should not be transmitted to servers unnecessarily.
    #[serde(rename = "sensitive")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sensitive: Option<bool>,

/// Value contains the binary data for the current value.
    #[serde(rename = "value")]
    pub value: Vec<i32>,

}


impl BinaryMetadataValue {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(value: Vec<i32>, ) -> BinaryMetadataValue {
        BinaryMetadataValue {
            sensitive: None,
            value,
        }
    }
}

/// Converts the BinaryMetadataValue value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BinaryMetadataValue {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.sensitive.as_ref().map(|sensitive| {
                [
                    "sensitive".to_string(),
                    sensitive.to_string(),
                ].join(",")
            }),


            Some("value".to_string()),
            Some(self.value.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BinaryMetadataValue value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BinaryMetadataValue {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub sensitive: Vec<bool>,
            pub value: Vec<Vec<i32>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BinaryMetadataValue".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sensitive" => intermediate_rep.sensitive.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "value" => return std::result::Result::Err("Parsing a container in this style is not supported in BinaryMetadataValue".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing BinaryMetadataValue".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BinaryMetadataValue {
            sensitive: intermediate_rep.sensitive.into_iter().next(),
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "value missing in BinaryMetadataValue".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BinaryMetadataValue> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BinaryMetadataValue>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BinaryMetadataValue>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BinaryMetadataValue - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BinaryMetadataValue> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BinaryMetadataValue as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BinaryMetadataValue - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BindOptions {
    #[serde(rename = "NonRecursive")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub non_recursive: Option<bool>,

    #[serde(rename = "Propagation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub propagation: Option<String>,

}


impl BindOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BindOptions {
        BindOptions {
            non_recursive: None,
            propagation: None,
        }
    }
}

/// Converts the BindOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BindOptions {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.non_recursive.as_ref().map(|non_recursive| {
                [
                    "NonRecursive".to_string(),
                    non_recursive.to_string(),
                ].join(",")
            }),


            self.propagation.as_ref().map(|propagation| {
                [
                    "Propagation".to_string(),
                    propagation.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BindOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BindOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub non_recursive: Vec<bool>,
            pub propagation: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BindOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "NonRecursive" => intermediate_rep.non_recursive.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Propagation" => intermediate_rep.propagation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BindOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BindOptions {
            non_recursive: intermediate_rep.non_recursive.into_iter().next(),
            propagation: intermediate_rep.propagation.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BindOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BindOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BindOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BindOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BindOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BindOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BindOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Capabilities {
/// Added capabilities +optional
    #[serde(rename = "add")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub add: Option<Vec<models::Capability>>,

/// Removed capabilities +optional
    #[serde(rename = "drop")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub drop: Option<Vec<models::Capability>>,

}


impl Capabilities {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Capabilities {
        Capabilities {
            add: None,
            drop: None,
        }
    }
}

/// Converts the Capabilities value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Capabilities {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.add.as_ref().map(|add| {
                [
                    "add".to_string(),
                    add.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.drop.as_ref().map(|drop| {
                [
                    "drop".to_string(),
                    drop.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Capabilities value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Capabilities {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub add: Vec<Vec<models::Capability>>,
            pub drop: Vec<Vec<models::Capability>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Capabilities".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "add" => return std::result::Result::Err("Parsing a container in this style is not supported in Capabilities".to_string()),
                    "drop" => return std::result::Result::Err("Parsing a container in this style is not supported in Capabilities".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Capabilities".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Capabilities {
            add: intermediate_rep.add.into_iter().next(),
            drop: intermediate_rep.drop.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Capabilities> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Capabilities>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Capabilities>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Capabilities - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Capabilities> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Capabilities as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Capabilities - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Capability represent POSIX capabilities type
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Capability(String);

impl validator::Validate for Capability {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for Capability {
    fn from(x: String) -> Self {
        Capability(x)
    }
}

impl std::string::ToString for Capability {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for Capability {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Capability(x.to_string()))
    }
}

impl std::convert::From<Capability> for String {
    fn from(x: Capability) -> Self {
        x.0
    }
}

impl std::ops::Deref for Capability {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Capability {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CephFsVolumeSource {
/// Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    #[serde(rename = "monitors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub monitors: Option<Vec<String>>,

/// Optional: Used as the mounted root, rather than the full Ceph tree, default is / +optional
    #[serde(rename = "path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

/// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it +optional
    #[serde(rename = "readOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

/// Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it +optional
    #[serde(rename = "secretFile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_file: Option<String>,

    #[serde(rename = "secretRef")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_ref: Option<models::LocalObjectReference>,

/// Optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it +optional
    #[serde(rename = "user")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

}


impl CephFsVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CephFsVolumeSource {
        CephFsVolumeSource {
            monitors: None,
            path: None,
            read_only: None,
            secret_file: None,
            secret_ref: None,
            user: None,
        }
    }
}

/// Converts the CephFsVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CephFsVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.monitors.as_ref().map(|monitors| {
                [
                    "monitors".to_string(),
                    monitors.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.path.as_ref().map(|path| {
                [
                    "path".to_string(),
                    path.to_string(),
                ].join(",")
            }),


            self.read_only.as_ref().map(|read_only| {
                [
                    "readOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),


            self.secret_file.as_ref().map(|secret_file| {
                [
                    "secretFile".to_string(),
                    secret_file.to_string(),
                ].join(",")
            }),

            // Skipping secretRef in query parameter serialization


            self.user.as_ref().map(|user| {
                [
                    "user".to_string(),
                    user.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CephFsVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CephFsVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub monitors: Vec<Vec<String>>,
            pub path: Vec<String>,
            pub read_only: Vec<bool>,
            pub secret_file: Vec<String>,
            pub secret_ref: Vec<models::LocalObjectReference>,
            pub user: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CephFsVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "monitors" => return std::result::Result::Err("Parsing a container in this style is not supported in CephFsVolumeSource".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "readOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "secretFile" => intermediate_rep.secret_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "secretRef" => intermediate_rep.secret_ref.push(<models::LocalObjectReference as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "user" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CephFsVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CephFsVolumeSource {
            monitors: intermediate_rep.monitors.into_iter().next(),
            path: intermediate_rep.path.into_iter().next(),
            read_only: intermediate_rep.read_only.into_iter().next(),
            secret_file: intermediate_rep.secret_file.into_iter().next(),
            secret_ref: intermediate_rep.secret_ref.into_iter().next(),
            user: intermediate_rep.user.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CephFsVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CephFsVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CephFsVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CephFsVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CephFsVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CephFsVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CephFsVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CgroupSpec(String);

impl validator::Validate for CgroupSpec {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for CgroupSpec {
    fn from(x: String) -> Self {
        CgroupSpec(x)
    }
}

impl std::string::ToString for CgroupSpec {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for CgroupSpec {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(CgroupSpec(x.to_string()))
    }
}

impl std::convert::From<CgroupSpec> for String {
    fn from(x: CgroupSpec) -> Self {
        x.0
    }
}

impl std::ops::Deref for CgroupSpec {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for CgroupSpec {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// CgroupnsMode represents the cgroup namespace mode of the container
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CgroupnsMode(String);

impl validator::Validate for CgroupnsMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for CgroupnsMode {
    fn from(x: String) -> Self {
        CgroupnsMode(x)
    }
}

impl std::string::ToString for CgroupnsMode {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for CgroupnsMode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(CgroupnsMode(x.to_string()))
    }
}

impl std::convert::From<CgroupnsMode> for String {
    fn from(x: CgroupnsMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for CgroupnsMode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for CgroupnsMode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CinderVolumeSource {
/// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md +optional
    #[serde(rename = "fsType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fs_type: Option<String>,

/// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md +optional
    #[serde(rename = "readOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

    #[serde(rename = "secretRef")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_ref: Option<models::LocalObjectReference>,

/// volume id used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
    #[serde(rename = "volumeID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_id: Option<String>,

}


impl CinderVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CinderVolumeSource {
        CinderVolumeSource {
            fs_type: None,
            read_only: None,
            secret_ref: None,
            volume_id: None,
        }
    }
}

/// Converts the CinderVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CinderVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.fs_type.as_ref().map(|fs_type| {
                [
                    "fsType".to_string(),
                    fs_type.to_string(),
                ].join(",")
            }),


            self.read_only.as_ref().map(|read_only| {
                [
                    "readOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),

            // Skipping secretRef in query parameter serialization


            self.volume_id.as_ref().map(|volume_id| {
                [
                    "volumeID".to_string(),
                    volume_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CinderVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CinderVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub fs_type: Vec<String>,
            pub read_only: Vec<bool>,
            pub secret_ref: Vec<models::LocalObjectReference>,
            pub volume_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CinderVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "fsType" => intermediate_rep.fs_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "readOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "secretRef" => intermediate_rep.secret_ref.push(<models::LocalObjectReference as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "volumeID" => intermediate_rep.volume_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CinderVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CinderVolumeSource {
            fs_type: intermediate_rep.fs_type.into_iter().next(),
            read_only: intermediate_rep.read_only.into_iter().next(),
            secret_ref: intermediate_rep.secret_ref.into_iter().next(),
            volume_id: intermediate_rep.volume_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CinderVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CinderVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CinderVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CinderVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CinderVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CinderVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CinderVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CipherSuite(String);

impl validator::Validate for CipherSuite {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for CipherSuite {
    fn from(x: String) -> Self {
        CipherSuite(x)
    }
}

impl std::string::ToString for CipherSuite {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for CipherSuite {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(CipherSuite(x.to_string()))
    }
}

impl std::convert::From<CipherSuite> for String {
    fn from(x: CipherSuite) -> Self {
        x.0
    }
}

impl std::ops::Deref for CipherSuite {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for CipherSuite {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CommandConfig {
/// Allow takes effect when Mode is ExecutionPolicyFilter and only allows the specified commands to be executed. Note that the match an exact match is performed to avoid shell injections, etc.
    #[serde(rename = "allow")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow: Option<Vec<String>>,

    #[serde(rename = "mode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mode: Option<String>,

}


impl CommandConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CommandConfig {
        CommandConfig {
            allow: None,
            mode: None,
        }
    }
}

/// Converts the CommandConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CommandConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.allow.as_ref().map(|allow| {
                [
                    "allow".to_string(),
                    allow.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.mode.as_ref().map(|mode| {
                [
                    "mode".to_string(),
                    mode.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CommandConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CommandConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub allow: Vec<Vec<String>>,
            pub mode: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CommandConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "allow" => return std::result::Result::Err("Parsing a container in this style is not supported in CommandConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "mode" => intermediate_rep.mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CommandConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CommandConfig {
            allow: intermediate_rep.allow.into_iter().next(),
            mode: intermediate_rep.mode.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CommandConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CommandConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CommandConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CommandConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CommandConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CommandConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CommandConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// It should hold only portable information about the container. Here, \"portable\" means \"independent from the host we are running on\". Non-portable information *should* appear in HostConfig. All fields added to this struct must be marked `omitempty` to keep getting predictable hashes from the old `v1Compatibility` configuration.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Config {
    #[serde(rename = "ArgsEscaped")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub args_escaped: Option<bool>,

    #[serde(rename = "AttachStderr")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attach_stderr: Option<bool>,

    #[serde(rename = "AttachStdin")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attach_stdin: Option<bool>,

    #[serde(rename = "AttachStdout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attach_stdout: Option<bool>,

/// We need to override the json decoder to accept both options.
    #[serde(rename = "Cmd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cmd: Option<Vec<String>>,

    #[serde(rename = "Domainname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub domainname: Option<String>,

/// We need to override the json decoder to accept both options.
    #[serde(rename = "Entrypoint")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub entrypoint: Option<Vec<String>>,

    #[serde(rename = "Env")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub env: Option<Vec<String>>,

/// PortSet is a collection of structs indexed by Port
    #[serde(rename = "ExposedPorts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exposed_ports: Option<std::collections::HashMap<String, crate::types::Object>>,

    #[serde(rename = "Healthcheck")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub healthcheck: Option<models::HealthConfig>,

    #[serde(rename = "Hostname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostname: Option<String>,

    #[serde(rename = "Image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image: Option<String>,

    #[serde(rename = "Labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "MacAddress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mac_address: Option<String>,

    #[serde(rename = "NetworkDisabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_disabled: Option<bool>,

    #[serde(rename = "OnBuild")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub on_build: Option<Vec<String>>,

    #[serde(rename = "OpenStdin")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_stdin: Option<bool>,

/// We need to override the json decoder to accept both options.
    #[serde(rename = "Shell")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shell: Option<Vec<String>>,

    #[serde(rename = "StdinOnce")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stdin_once: Option<bool>,

    #[serde(rename = "StopSignal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stop_signal: Option<String>,

    #[serde(rename = "StopTimeout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stop_timeout: Option<i64>,

    #[serde(rename = "Tty")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tty: Option<bool>,

    #[serde(rename = "User")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

    #[serde(rename = "Volumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes: Option<std::collections::HashMap<String, crate::types::Object>>,

    #[serde(rename = "WorkingDir")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub working_dir: Option<String>,

}


impl Config {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Config {
        Config {
            args_escaped: None,
            attach_stderr: None,
            attach_stdin: None,
            attach_stdout: None,
            cmd: None,
            domainname: None,
            entrypoint: None,
            env: None,
            exposed_ports: None,
            healthcheck: None,
            hostname: None,
            image: None,
            labels: None,
            mac_address: None,
            network_disabled: None,
            on_build: None,
            open_stdin: None,
            shell: None,
            stdin_once: None,
            stop_signal: None,
            stop_timeout: None,
            tty: None,
            user: None,
            volumes: None,
            working_dir: None,
        }
    }
}

/// Converts the Config value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Config {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.args_escaped.as_ref().map(|args_escaped| {
                [
                    "ArgsEscaped".to_string(),
                    args_escaped.to_string(),
                ].join(",")
            }),


            self.attach_stderr.as_ref().map(|attach_stderr| {
                [
                    "AttachStderr".to_string(),
                    attach_stderr.to_string(),
                ].join(",")
            }),


            self.attach_stdin.as_ref().map(|attach_stdin| {
                [
                    "AttachStdin".to_string(),
                    attach_stdin.to_string(),
                ].join(",")
            }),


            self.attach_stdout.as_ref().map(|attach_stdout| {
                [
                    "AttachStdout".to_string(),
                    attach_stdout.to_string(),
                ].join(",")
            }),


            self.cmd.as_ref().map(|cmd| {
                [
                    "Cmd".to_string(),
                    cmd.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.domainname.as_ref().map(|domainname| {
                [
                    "Domainname".to_string(),
                    domainname.to_string(),
                ].join(",")
            }),


            self.entrypoint.as_ref().map(|entrypoint| {
                [
                    "Entrypoint".to_string(),
                    entrypoint.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.env.as_ref().map(|env| {
                [
                    "Env".to_string(),
                    env.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping ExposedPorts in query parameter serialization
            // Skipping ExposedPorts in query parameter serialization

            // Skipping Healthcheck in query parameter serialization


            self.hostname.as_ref().map(|hostname| {
                [
                    "Hostname".to_string(),
                    hostname.to_string(),
                ].join(",")
            }),


            self.image.as_ref().map(|image| {
                [
                    "Image".to_string(),
                    image.to_string(),
                ].join(",")
            }),

            // Skipping Labels in query parameter serialization


            self.mac_address.as_ref().map(|mac_address| {
                [
                    "MacAddress".to_string(),
                    mac_address.to_string(),
                ].join(",")
            }),


            self.network_disabled.as_ref().map(|network_disabled| {
                [
                    "NetworkDisabled".to_string(),
                    network_disabled.to_string(),
                ].join(",")
            }),


            self.on_build.as_ref().map(|on_build| {
                [
                    "OnBuild".to_string(),
                    on_build.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.open_stdin.as_ref().map(|open_stdin| {
                [
                    "OpenStdin".to_string(),
                    open_stdin.to_string(),
                ].join(",")
            }),


            self.shell.as_ref().map(|shell| {
                [
                    "Shell".to_string(),
                    shell.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.stdin_once.as_ref().map(|stdin_once| {
                [
                    "StdinOnce".to_string(),
                    stdin_once.to_string(),
                ].join(",")
            }),


            self.stop_signal.as_ref().map(|stop_signal| {
                [
                    "StopSignal".to_string(),
                    stop_signal.to_string(),
                ].join(",")
            }),


            self.stop_timeout.as_ref().map(|stop_timeout| {
                [
                    "StopTimeout".to_string(),
                    stop_timeout.to_string(),
                ].join(",")
            }),


            self.tty.as_ref().map(|tty| {
                [
                    "Tty".to_string(),
                    tty.to_string(),
                ].join(",")
            }),


            self.user.as_ref().map(|user| {
                [
                    "User".to_string(),
                    user.to_string(),
                ].join(",")
            }),

            // Skipping Volumes in query parameter serialization
            // Skipping Volumes in query parameter serialization


            self.working_dir.as_ref().map(|working_dir| {
                [
                    "WorkingDir".to_string(),
                    working_dir.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Config value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Config {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub args_escaped: Vec<bool>,
            pub attach_stderr: Vec<bool>,
            pub attach_stdin: Vec<bool>,
            pub attach_stdout: Vec<bool>,
            pub cmd: Vec<Vec<String>>,
            pub domainname: Vec<String>,
            pub entrypoint: Vec<Vec<String>>,
            pub env: Vec<Vec<String>>,
            pub exposed_ports: Vec<std::collections::HashMap<String, crate::types::Object>>,
            pub healthcheck: Vec<models::HealthConfig>,
            pub hostname: Vec<String>,
            pub image: Vec<String>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub mac_address: Vec<String>,
            pub network_disabled: Vec<bool>,
            pub on_build: Vec<Vec<String>>,
            pub open_stdin: Vec<bool>,
            pub shell: Vec<Vec<String>>,
            pub stdin_once: Vec<bool>,
            pub stop_signal: Vec<String>,
            pub stop_timeout: Vec<i64>,
            pub tty: Vec<bool>,
            pub user: Vec<String>,
            pub volumes: Vec<std::collections::HashMap<String, crate::types::Object>>,
            pub working_dir: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Config".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ArgsEscaped" => intermediate_rep.args_escaped.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AttachStderr" => intermediate_rep.attach_stderr.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AttachStdin" => intermediate_rep.attach_stdin.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AttachStdout" => intermediate_rep.attach_stdout.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Cmd" => return std::result::Result::Err("Parsing a container in this style is not supported in Config".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Domainname" => intermediate_rep.domainname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Entrypoint" => return std::result::Result::Err("Parsing a container in this style is not supported in Config".to_string()),
                    "Env" => return std::result::Result::Err("Parsing a container in this style is not supported in Config".to_string()),
                    "ExposedPorts" => return std::result::Result::Err("Parsing a container in this style is not supported in Config".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Healthcheck" => intermediate_rep.healthcheck.push(<models::HealthConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Hostname" => intermediate_rep.hostname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Image" => intermediate_rep.image.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in Config".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "MacAddress" => intermediate_rep.mac_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NetworkDisabled" => intermediate_rep.network_disabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "OnBuild" => return std::result::Result::Err("Parsing a container in this style is not supported in Config".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "OpenStdin" => intermediate_rep.open_stdin.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Shell" => return std::result::Result::Err("Parsing a container in this style is not supported in Config".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "StdinOnce" => intermediate_rep.stdin_once.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StopSignal" => intermediate_rep.stop_signal.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StopTimeout" => intermediate_rep.stop_timeout.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Tty" => intermediate_rep.tty.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "User" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in Config".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "WorkingDir" => intermediate_rep.working_dir.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Config".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Config {
            args_escaped: intermediate_rep.args_escaped.into_iter().next(),
            attach_stderr: intermediate_rep.attach_stderr.into_iter().next(),
            attach_stdin: intermediate_rep.attach_stdin.into_iter().next(),
            attach_stdout: intermediate_rep.attach_stdout.into_iter().next(),
            cmd: intermediate_rep.cmd.into_iter().next(),
            domainname: intermediate_rep.domainname.into_iter().next(),
            entrypoint: intermediate_rep.entrypoint.into_iter().next(),
            env: intermediate_rep.env.into_iter().next(),
            exposed_ports: intermediate_rep.exposed_ports.into_iter().next(),
            healthcheck: intermediate_rep.healthcheck.into_iter().next(),
            hostname: intermediate_rep.hostname.into_iter().next(),
            image: intermediate_rep.image.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            mac_address: intermediate_rep.mac_address.into_iter().next(),
            network_disabled: intermediate_rep.network_disabled.into_iter().next(),
            on_build: intermediate_rep.on_build.into_iter().next(),
            open_stdin: intermediate_rep.open_stdin.into_iter().next(),
            shell: intermediate_rep.shell.into_iter().next(),
            stdin_once: intermediate_rep.stdin_once.into_iter().next(),
            stop_signal: intermediate_rep.stop_signal.into_iter().next(),
            stop_timeout: intermediate_rep.stop_timeout.into_iter().next(),
            tty: intermediate_rep.tty.into_iter().next(),
            user: intermediate_rep.user.into_iter().next(),
            volumes: intermediate_rep.volumes.into_iter().next(),
            working_dir: intermediate_rep.working_dir.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Config> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Config>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Config>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Config - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Config> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Config as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Config - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConfigMapEnvSource {
/// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid? +optional
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Specify whether the ConfigMap must be defined +optional
    #[serde(rename = "optional")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional: Option<bool>,

}


impl ConfigMapEnvSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ConfigMapEnvSource {
        ConfigMapEnvSource {
            name: None,
            optional: None,
        }
    }
}

/// Converts the ConfigMapEnvSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ConfigMapEnvSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.optional.as_ref().map(|optional| {
                [
                    "optional".to_string(),
                    optional.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConfigMapEnvSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConfigMapEnvSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub optional: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConfigMapEnvSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "optional" => intermediate_rep.optional.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConfigMapEnvSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConfigMapEnvSource {
            name: intermediate_rep.name.into_iter().next(),
            optional: intermediate_rep.optional.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConfigMapEnvSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConfigMapEnvSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConfigMapEnvSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConfigMapEnvSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConfigMapEnvSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConfigMapEnvSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConfigMapEnvSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// +structType=atomic



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConfigMapKeySelector {
/// The key to select.
    #[serde(rename = "key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,

/// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid? +optional
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Specify whether the ConfigMap or its key must be defined +optional
    #[serde(rename = "optional")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional: Option<bool>,

}


impl ConfigMapKeySelector {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ConfigMapKeySelector {
        ConfigMapKeySelector {
            key: None,
            name: None,
            optional: None,
        }
    }
}

/// Converts the ConfigMapKeySelector value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ConfigMapKeySelector {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.key.as_ref().map(|key| {
                [
                    "key".to_string(),
                    key.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.optional.as_ref().map(|optional| {
                [
                    "optional".to_string(),
                    optional.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConfigMapKeySelector value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConfigMapKeySelector {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub key: Vec<String>,
            pub name: Vec<String>,
            pub optional: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConfigMapKeySelector".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "key" => intermediate_rep.key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "optional" => intermediate_rep.optional.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConfigMapKeySelector".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConfigMapKeySelector {
            key: intermediate_rep.key.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            optional: intermediate_rep.optional.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConfigMapKeySelector> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConfigMapKeySelector>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConfigMapKeySelector>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConfigMapKeySelector - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConfigMapKeySelector> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConfigMapKeySelector as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConfigMapKeySelector - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The contents of the target ConfigMap's Data field will be presented in a projected volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. Note that this is identical to a configmap volume source without the default mode.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConfigMapProjection {
/// If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'. +optional
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::KeyToPath>>,

/// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid? +optional
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Specify whether the ConfigMap or its keys must be defined +optional
    #[serde(rename = "optional")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional: Option<bool>,

}


impl ConfigMapProjection {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ConfigMapProjection {
        ConfigMapProjection {
            items: None,
            name: None,
            optional: None,
        }
    }
}

/// Converts the ConfigMapProjection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ConfigMapProjection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.optional.as_ref().map(|optional| {
                [
                    "optional".to_string(),
                    optional.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConfigMapProjection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConfigMapProjection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::KeyToPath>>,
            pub name: Vec<String>,
            pub optional: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConfigMapProjection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in ConfigMapProjection".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "optional" => intermediate_rep.optional.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConfigMapProjection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConfigMapProjection {
            items: intermediate_rep.items.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            optional: intermediate_rep.optional.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConfigMapProjection> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConfigMapProjection>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConfigMapProjection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConfigMapProjection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConfigMapProjection> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConfigMapProjection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConfigMapProjection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConfigMapVolumeSource {
/// Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. +optional
    #[serde(rename = "defaultMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_mode: Option<i32>,

/// If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'. +optional
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::KeyToPath>>,

/// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid? +optional
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Specify whether the ConfigMap or its keys must be defined +optional
    #[serde(rename = "optional")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional: Option<bool>,

}


impl ConfigMapVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ConfigMapVolumeSource {
        ConfigMapVolumeSource {
            default_mode: None,
            items: None,
            name: None,
            optional: None,
        }
    }
}

/// Converts the ConfigMapVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ConfigMapVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.default_mode.as_ref().map(|default_mode| {
                [
                    "defaultMode".to_string(),
                    default_mode.to_string(),
                ].join(",")
            }),

            // Skipping items in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.optional.as_ref().map(|optional| {
                [
                    "optional".to_string(),
                    optional.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConfigMapVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConfigMapVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub default_mode: Vec<i32>,
            pub items: Vec<Vec<models::KeyToPath>>,
            pub name: Vec<String>,
            pub optional: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConfigMapVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "defaultMode" => intermediate_rep.default_mode.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in ConfigMapVolumeSource".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "optional" => intermediate_rep.optional.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConfigMapVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConfigMapVolumeSource {
            default_mode: intermediate_rep.default_mode.into_iter().next(),
            items: intermediate_rep.items.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            optional: intermediate_rep.optional.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConfigMapVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConfigMapVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConfigMapVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConfigMapVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConfigMapVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConfigMapVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConfigMapVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConfigRequest {
/// AuthenticatedUsername contains the username that was actually verified. This may differ from LoginUsername when, for example OAuth2 or Kerberos authentication is used. This field is empty until the authentication phase is completed.
    #[serde(rename = "authenticatedUsername")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub authenticated_username: Option<String>,

/// ClientVersion contains the version string the connecting client sent if any. May be empty if the client did not provide a client version.
    #[serde(rename = "clientVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_version: Option<String>,

/// ConnectionID is an opaque ID to identify the SSH connection in question.
    #[serde(rename = "connectionId")]
    pub connection_id: String,

/// Environment is a set of key-value pairs provided by the authentication or configuration system and may be exposed by the backend.
    #[serde(rename = "environment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<std::collections::HashMap<String, models::MetadataValue>>,

/// Files is a key-value pair of file names and their content set by the authentication or configuration system and consumed by the backend.
    #[serde(rename = "files")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub files: Option<std::collections::HashMap<String, models::BinaryMetadataValue>>,

/// Metadata is a set of key-value pairs that carry additional information from the authentication and configuration system to the backends. Backends can expose this information as container labels, environment variables, or other places.
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, models::MetadataValue>>,

/// RemoteAddress is the IP address and port of the user trying to authenticate.
    #[serde(rename = "remoteAddress")]
    pub remote_address: String,

/// Username is the username provided on login by the client. This may, but must not necessarily match the authenticated username.
    #[serde(rename = "username")]
    pub username: String,

}


impl ConfigRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(connection_id: String, remote_address: String, username: String, ) -> ConfigRequest {
        ConfigRequest {
            authenticated_username: None,
            client_version: None,
            connection_id,
            environment: None,
            files: None,
            metadata: None,
            remote_address,
            username,
        }
    }
}

/// Converts the ConfigRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ConfigRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.authenticated_username.as_ref().map(|authenticated_username| {
                [
                    "authenticatedUsername".to_string(),
                    authenticated_username.to_string(),
                ].join(",")
            }),


            self.client_version.as_ref().map(|client_version| {
                [
                    "clientVersion".to_string(),
                    client_version.to_string(),
                ].join(",")
            }),


            Some("connectionId".to_string()),
            Some(self.connection_id.to_string()),

            // Skipping environment in query parameter serialization
            // Skipping environment in query parameter serialization

            // Skipping files in query parameter serialization
            // Skipping files in query parameter serialization

            // Skipping metadata in query parameter serialization
            // Skipping metadata in query parameter serialization


            Some("remoteAddress".to_string()),
            Some(self.remote_address.to_string()),


            Some("username".to_string()),
            Some(self.username.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConfigRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConfigRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub authenticated_username: Vec<String>,
            pub client_version: Vec<String>,
            pub connection_id: Vec<String>,
            pub environment: Vec<std::collections::HashMap<String, models::MetadataValue>>,
            pub files: Vec<std::collections::HashMap<String, models::BinaryMetadataValue>>,
            pub metadata: Vec<std::collections::HashMap<String, models::MetadataValue>>,
            pub remote_address: Vec<String>,
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConfigRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "authenticatedUsername" => intermediate_rep.authenticated_username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "clientVersion" => intermediate_rep.client_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "connectionId" => intermediate_rep.connection_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "environment" => return std::result::Result::Err("Parsing a container in this style is not supported in ConfigRequest".to_string()),
                    "files" => return std::result::Result::Err("Parsing a container in this style is not supported in ConfigRequest".to_string()),
                    "metadata" => return std::result::Result::Err("Parsing a container in this style is not supported in ConfigRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "remoteAddress" => intermediate_rep.remote_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConfigRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConfigRequest {
            authenticated_username: intermediate_rep.authenticated_username.into_iter().next(),
            client_version: intermediate_rep.client_version.into_iter().next(),
            connection_id: intermediate_rep.connection_id.into_iter().next().ok_or_else(|| "connectionId missing in ConfigRequest".to_string())?,
            environment: intermediate_rep.environment.into_iter().next(),
            files: intermediate_rep.files.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
            remote_address: intermediate_rep.remote_address.into_iter().next().ok_or_else(|| "remoteAddress missing in ConfigRequest".to_string())?,
            username: intermediate_rep.username.into_iter().next().ok_or_else(|| "username missing in ConfigRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConfigRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConfigRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConfigRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConfigRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConfigRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConfigRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConfigRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConfigResponseBody {
/// AuthenticatedUsername contains the username that was actually verified. This may differ from LoginUsername when, for example OAuth2 or Kerberos authentication is used. This field is empty until the authentication phase is completed.
    #[serde(rename = "authenticatedUsername")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub authenticated_username: Option<String>,

/// ClientVersion contains the version string the connecting client sent if any. May be empty if the client did not provide a client version.
    #[serde(rename = "clientVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_version: Option<String>,

    #[serde(rename = "config")]
    pub config: models::AppConfig,

/// ConnectionID is an opaque ID to identify the SSH connection in question.
    #[serde(rename = "connectionId")]
    pub connection_id: String,

/// Environment is a set of key-value pairs provided by the authentication or configuration system and may be exposed by the backend.
    #[serde(rename = "environment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<std::collections::HashMap<String, models::MetadataValue>>,

/// Files is a key-value pair of file names and their content set by the authentication or configuration system and consumed by the backend.
    #[serde(rename = "files")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub files: Option<std::collections::HashMap<String, models::BinaryMetadataValue>>,

/// Metadata is a set of key-value pairs that carry additional information from the authentication and configuration system to the backends. Backends can expose this information as container labels, environment variables, or other places.
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, models::MetadataValue>>,

/// RemoteAddress is the IP address and port of the user trying to authenticate.
    #[serde(rename = "remoteAddress")]
    pub remote_address: String,

/// Username is the username provided on login by the client. This may, but must not necessarily match the authenticated username.
    #[serde(rename = "username")]
    pub username: String,

}


impl ConfigResponseBody {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(config: models::AppConfig, connection_id: String, remote_address: String, username: String, ) -> ConfigResponseBody {
        ConfigResponseBody {
            authenticated_username: None,
            client_version: None,
            config,
            connection_id,
            environment: None,
            files: None,
            metadata: None,
            remote_address,
            username,
        }
    }
}

/// Converts the ConfigResponseBody value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ConfigResponseBody {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.authenticated_username.as_ref().map(|authenticated_username| {
                [
                    "authenticatedUsername".to_string(),
                    authenticated_username.to_string(),
                ].join(",")
            }),


            self.client_version.as_ref().map(|client_version| {
                [
                    "clientVersion".to_string(),
                    client_version.to_string(),
                ].join(",")
            }),

            // Skipping config in query parameter serialization


            Some("connectionId".to_string()),
            Some(self.connection_id.to_string()),

            // Skipping environment in query parameter serialization
            // Skipping environment in query parameter serialization

            // Skipping files in query parameter serialization
            // Skipping files in query parameter serialization

            // Skipping metadata in query parameter serialization
            // Skipping metadata in query parameter serialization


            Some("remoteAddress".to_string()),
            Some(self.remote_address.to_string()),


            Some("username".to_string()),
            Some(self.username.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConfigResponseBody value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConfigResponseBody {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub authenticated_username: Vec<String>,
            pub client_version: Vec<String>,
            pub config: Vec<models::AppConfig>,
            pub connection_id: Vec<String>,
            pub environment: Vec<std::collections::HashMap<String, models::MetadataValue>>,
            pub files: Vec<std::collections::HashMap<String, models::BinaryMetadataValue>>,
            pub metadata: Vec<std::collections::HashMap<String, models::MetadataValue>>,
            pub remote_address: Vec<String>,
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConfigResponseBody".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "authenticatedUsername" => intermediate_rep.authenticated_username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "clientVersion" => intermediate_rep.client_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "config" => intermediate_rep.config.push(<models::AppConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "connectionId" => intermediate_rep.connection_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "environment" => return std::result::Result::Err("Parsing a container in this style is not supported in ConfigResponseBody".to_string()),
                    "files" => return std::result::Result::Err("Parsing a container in this style is not supported in ConfigResponseBody".to_string()),
                    "metadata" => return std::result::Result::Err("Parsing a container in this style is not supported in ConfigResponseBody".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "remoteAddress" => intermediate_rep.remote_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConfigResponseBody".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConfigResponseBody {
            authenticated_username: intermediate_rep.authenticated_username.into_iter().next(),
            client_version: intermediate_rep.client_version.into_iter().next(),
            config: intermediate_rep.config.into_iter().next().ok_or_else(|| "config missing in ConfigResponseBody".to_string())?,
            connection_id: intermediate_rep.connection_id.into_iter().next().ok_or_else(|| "connectionId missing in ConfigResponseBody".to_string())?,
            environment: intermediate_rep.environment.into_iter().next(),
            files: intermediate_rep.files.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
            remote_address: intermediate_rep.remote_address.into_iter().next().ok_or_else(|| "remoteAddress missing in ConfigResponseBody".to_string())?,
            username: intermediate_rep.username.into_iter().next().ok_or_else(|| "username missing in ConfigResponseBody".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConfigResponseBody> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConfigResponseBody>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConfigResponseBody>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConfigResponseBody - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConfigResponseBody> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConfigResponseBody as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConfigResponseBody - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ConnectionAuthPendingMetadata is a variant of ConnectionMetadata which is used when the client has already provided a Username, but the authentication has not completed yet.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConnectionAuthPendingMetadata {
/// ClientVersion contains the version string the connecting client sent if any. May be empty if the client did not provide a client version.
    #[serde(rename = "clientVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_version: Option<String>,

/// ConnectionID is an opaque ID to identify the SSH connection in question.
    #[serde(rename = "connectionId")]
    pub connection_id: String,

/// Environment is a set of key-value pairs provided by the authentication or configuration system and may be exposed by the backend.
    #[serde(rename = "environment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<std::collections::HashMap<String, models::MetadataValue>>,

/// Files is a key-value pair of file names and their content set by the authentication or configuration system and consumed by the backend.
    #[serde(rename = "files")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub files: Option<std::collections::HashMap<String, models::BinaryMetadataValue>>,

/// Metadata is a set of key-value pairs that carry additional information from the authentication and configuration system to the backends. Backends can expose this information as container labels, environment variables, or other places.
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, models::MetadataValue>>,

/// RemoteAddress is the IP address and port of the user trying to authenticate.
    #[serde(rename = "remoteAddress")]
    pub remote_address: String,

/// Username is the username provided on login by the client. This may, but must not necessarily match the authenticated username.
    #[serde(rename = "username")]
    pub username: String,

}


impl ConnectionAuthPendingMetadata {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(connection_id: String, remote_address: String, username: String, ) -> ConnectionAuthPendingMetadata {
        ConnectionAuthPendingMetadata {
            client_version: None,
            connection_id,
            environment: None,
            files: None,
            metadata: None,
            remote_address,
            username,
        }
    }
}

/// Converts the ConnectionAuthPendingMetadata value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ConnectionAuthPendingMetadata {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.client_version.as_ref().map(|client_version| {
                [
                    "clientVersion".to_string(),
                    client_version.to_string(),
                ].join(",")
            }),


            Some("connectionId".to_string()),
            Some(self.connection_id.to_string()),

            // Skipping environment in query parameter serialization
            // Skipping environment in query parameter serialization

            // Skipping files in query parameter serialization
            // Skipping files in query parameter serialization

            // Skipping metadata in query parameter serialization
            // Skipping metadata in query parameter serialization


            Some("remoteAddress".to_string()),
            Some(self.remote_address.to_string()),


            Some("username".to_string()),
            Some(self.username.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConnectionAuthPendingMetadata value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConnectionAuthPendingMetadata {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub client_version: Vec<String>,
            pub connection_id: Vec<String>,
            pub environment: Vec<std::collections::HashMap<String, models::MetadataValue>>,
            pub files: Vec<std::collections::HashMap<String, models::BinaryMetadataValue>>,
            pub metadata: Vec<std::collections::HashMap<String, models::MetadataValue>>,
            pub remote_address: Vec<String>,
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConnectionAuthPendingMetadata".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "clientVersion" => intermediate_rep.client_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "connectionId" => intermediate_rep.connection_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "environment" => return std::result::Result::Err("Parsing a container in this style is not supported in ConnectionAuthPendingMetadata".to_string()),
                    "files" => return std::result::Result::Err("Parsing a container in this style is not supported in ConnectionAuthPendingMetadata".to_string()),
                    "metadata" => return std::result::Result::Err("Parsing a container in this style is not supported in ConnectionAuthPendingMetadata".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "remoteAddress" => intermediate_rep.remote_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConnectionAuthPendingMetadata".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConnectionAuthPendingMetadata {
            client_version: intermediate_rep.client_version.into_iter().next(),
            connection_id: intermediate_rep.connection_id.into_iter().next().ok_or_else(|| "connectionId missing in ConnectionAuthPendingMetadata".to_string())?,
            environment: intermediate_rep.environment.into_iter().next(),
            files: intermediate_rep.files.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
            remote_address: intermediate_rep.remote_address.into_iter().next().ok_or_else(|| "remoteAddress missing in ConnectionAuthPendingMetadata".to_string())?,
            username: intermediate_rep.username.into_iter().next().ok_or_else(|| "username missing in ConnectionAuthPendingMetadata".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConnectionAuthPendingMetadata> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConnectionAuthPendingMetadata>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConnectionAuthPendingMetadata>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConnectionAuthPendingMetadata - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConnectionAuthPendingMetadata> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConnectionAuthPendingMetadata as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConnectionAuthPendingMetadata - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ConnectionAuthenticatedMetadata is a variant of ConnectionMetadata which is used once the authentication has been completed. It contains the AuthenticatedUsername provided by the authentication system.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConnectionAuthenticatedMetadata {
/// AuthenticatedUsername contains the username that was actually verified. This may differ from LoginUsername when, for example OAuth2 or Kerberos authentication is used. This field is empty until the authentication phase is completed.
    #[serde(rename = "authenticatedUsername")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub authenticated_username: Option<String>,

/// ClientVersion contains the version string the connecting client sent if any. May be empty if the client did not provide a client version.
    #[serde(rename = "clientVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_version: Option<String>,

/// ConnectionID is an opaque ID to identify the SSH connection in question.
    #[serde(rename = "connectionId")]
    pub connection_id: String,

/// Environment is a set of key-value pairs provided by the authentication or configuration system and may be exposed by the backend.
    #[serde(rename = "environment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<std::collections::HashMap<String, models::MetadataValue>>,

/// Files is a key-value pair of file names and their content set by the authentication or configuration system and consumed by the backend.
    #[serde(rename = "files")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub files: Option<std::collections::HashMap<String, models::BinaryMetadataValue>>,

/// Metadata is a set of key-value pairs that carry additional information from the authentication and configuration system to the backends. Backends can expose this information as container labels, environment variables, or other places.
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, models::MetadataValue>>,

/// RemoteAddress is the IP address and port of the user trying to authenticate.
    #[serde(rename = "remoteAddress")]
    pub remote_address: String,

/// Username is the username provided on login by the client. This may, but must not necessarily match the authenticated username.
    #[serde(rename = "username")]
    pub username: String,

}


impl ConnectionAuthenticatedMetadata {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(connection_id: String, remote_address: String, username: String, ) -> ConnectionAuthenticatedMetadata {
        ConnectionAuthenticatedMetadata {
            authenticated_username: None,
            client_version: None,
            connection_id,
            environment: None,
            files: None,
            metadata: None,
            remote_address,
            username,
        }
    }
}

/// Converts the ConnectionAuthenticatedMetadata value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ConnectionAuthenticatedMetadata {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.authenticated_username.as_ref().map(|authenticated_username| {
                [
                    "authenticatedUsername".to_string(),
                    authenticated_username.to_string(),
                ].join(",")
            }),


            self.client_version.as_ref().map(|client_version| {
                [
                    "clientVersion".to_string(),
                    client_version.to_string(),
                ].join(",")
            }),


            Some("connectionId".to_string()),
            Some(self.connection_id.to_string()),

            // Skipping environment in query parameter serialization
            // Skipping environment in query parameter serialization

            // Skipping files in query parameter serialization
            // Skipping files in query parameter serialization

            // Skipping metadata in query parameter serialization
            // Skipping metadata in query parameter serialization


            Some("remoteAddress".to_string()),
            Some(self.remote_address.to_string()),


            Some("username".to_string()),
            Some(self.username.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConnectionAuthenticatedMetadata value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConnectionAuthenticatedMetadata {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub authenticated_username: Vec<String>,
            pub client_version: Vec<String>,
            pub connection_id: Vec<String>,
            pub environment: Vec<std::collections::HashMap<String, models::MetadataValue>>,
            pub files: Vec<std::collections::HashMap<String, models::BinaryMetadataValue>>,
            pub metadata: Vec<std::collections::HashMap<String, models::MetadataValue>>,
            pub remote_address: Vec<String>,
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConnectionAuthenticatedMetadata".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "authenticatedUsername" => intermediate_rep.authenticated_username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "clientVersion" => intermediate_rep.client_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "connectionId" => intermediate_rep.connection_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "environment" => return std::result::Result::Err("Parsing a container in this style is not supported in ConnectionAuthenticatedMetadata".to_string()),
                    "files" => return std::result::Result::Err("Parsing a container in this style is not supported in ConnectionAuthenticatedMetadata".to_string()),
                    "metadata" => return std::result::Result::Err("Parsing a container in this style is not supported in ConnectionAuthenticatedMetadata".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "remoteAddress" => intermediate_rep.remote_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConnectionAuthenticatedMetadata".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConnectionAuthenticatedMetadata {
            authenticated_username: intermediate_rep.authenticated_username.into_iter().next(),
            client_version: intermediate_rep.client_version.into_iter().next(),
            connection_id: intermediate_rep.connection_id.into_iter().next().ok_or_else(|| "connectionId missing in ConnectionAuthenticatedMetadata".to_string())?,
            environment: intermediate_rep.environment.into_iter().next(),
            files: intermediate_rep.files.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
            remote_address: intermediate_rep.remote_address.into_iter().next().ok_or_else(|| "remoteAddress missing in ConnectionAuthenticatedMetadata".to_string())?,
            username: intermediate_rep.username.into_iter().next().ok_or_else(|| "username missing in ConnectionAuthenticatedMetadata".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConnectionAuthenticatedMetadata> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConnectionAuthenticatedMetadata>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConnectionAuthenticatedMetadata>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConnectionAuthenticatedMetadata - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConnectionAuthenticatedMetadata> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConnectionAuthenticatedMetadata as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConnectionAuthenticatedMetadata - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ConnectionMetadata holds a metadata structure passed around with a metadata. Its main purpose is to allow an authentication or authorization module to configure data exposed to the configuration server or the backend.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConnectionMetadata {
/// ConnectionID is an opaque ID to identify the SSH connection in question.
    #[serde(rename = "connectionId")]
    pub connection_id: String,

/// Environment is a set of key-value pairs provided by the authentication or configuration system and may be exposed by the backend.
    #[serde(rename = "environment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<std::collections::HashMap<String, models::MetadataValue>>,

/// Files is a key-value pair of file names and their content set by the authentication or configuration system and consumed by the backend.
    #[serde(rename = "files")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub files: Option<std::collections::HashMap<String, models::BinaryMetadataValue>>,

/// Metadata is a set of key-value pairs that carry additional information from the authentication and configuration system to the backends. Backends can expose this information as container labels, environment variables, or other places.
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, models::MetadataValue>>,

/// RemoteAddress is the IP address and port of the user trying to authenticate.
    #[serde(rename = "remoteAddress")]
    pub remote_address: String,

}


impl ConnectionMetadata {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(connection_id: String, remote_address: String, ) -> ConnectionMetadata {
        ConnectionMetadata {
            connection_id,
            environment: None,
            files: None,
            metadata: None,
            remote_address,
        }
    }
}

/// Converts the ConnectionMetadata value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ConnectionMetadata {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("connectionId".to_string()),
            Some(self.connection_id.to_string()),

            // Skipping environment in query parameter serialization
            // Skipping environment in query parameter serialization

            // Skipping files in query parameter serialization
            // Skipping files in query parameter serialization

            // Skipping metadata in query parameter serialization
            // Skipping metadata in query parameter serialization


            Some("remoteAddress".to_string()),
            Some(self.remote_address.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConnectionMetadata value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConnectionMetadata {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub connection_id: Vec<String>,
            pub environment: Vec<std::collections::HashMap<String, models::MetadataValue>>,
            pub files: Vec<std::collections::HashMap<String, models::BinaryMetadataValue>>,
            pub metadata: Vec<std::collections::HashMap<String, models::MetadataValue>>,
            pub remote_address: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConnectionMetadata".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "connectionId" => intermediate_rep.connection_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "environment" => return std::result::Result::Err("Parsing a container in this style is not supported in ConnectionMetadata".to_string()),
                    "files" => return std::result::Result::Err("Parsing a container in this style is not supported in ConnectionMetadata".to_string()),
                    "metadata" => return std::result::Result::Err("Parsing a container in this style is not supported in ConnectionMetadata".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "remoteAddress" => intermediate_rep.remote_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConnectionMetadata".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConnectionMetadata {
            connection_id: intermediate_rep.connection_id.into_iter().next().ok_or_else(|| "connectionId missing in ConnectionMetadata".to_string())?,
            environment: intermediate_rep.environment.into_iter().next(),
            files: intermediate_rep.files.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
            remote_address: intermediate_rep.remote_address.into_iter().next().ok_or_else(|| "remoteAddress missing in ConnectionMetadata".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConnectionMetadata> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConnectionMetadata>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConnectionMetadata>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConnectionMetadata - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConnectionMetadata> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConnectionMetadata as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConnectionMetadata - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Consistency(String);

impl validator::Validate for Consistency {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for Consistency {
    fn from(x: String) -> Self {
        Consistency(x)
    }
}

impl std::string::ToString for Consistency {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for Consistency {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Consistency(x.to_string()))
    }
}

impl std::convert::From<Consistency> for String {
    fn from(x: Consistency) -> Self {
        x.0
    }
}

impl std::ops::Deref for Consistency {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Consistency {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Container {
/// Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell +optional
    #[serde(rename = "args")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub args: Option<Vec<String>>,

/// Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell +optional
    #[serde(rename = "command")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub command: Option<Vec<String>>,

/// List of environment variables to set in the container. Cannot be updated. +optional +patchMergeKey=name +patchStrategy=merge
    #[serde(rename = "env")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub env: Option<Vec<models::EnvVar>>,

/// List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated. +optional
    #[serde(rename = "envFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub env_from: Option<Vec<models::EnvFromSource>>,

/// Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets. +optional
    #[serde(rename = "image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image: Option<String>,

/// PullPolicy describes a policy for if/when to pull a container image +enum
    #[serde(rename = "imagePullPolicy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_pull_policy: Option<String>,

    #[serde(rename = "lifecycle")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lifecycle: Option<models::Lifecycle>,

    #[serde(rename = "livenessProbe")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub liveness_probe: Option<models::Probe>,

/// Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \"0.0.0.0\" address inside a container will be accessible from the network. Cannot be updated. +optional +patchMergeKey=containerPort +patchStrategy=merge +listType=map +listMapKey=containerPort +listMapKey=protocol
    #[serde(rename = "ports")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ports: Option<Vec<models::ContainerPort>>,

    #[serde(rename = "readinessProbe")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub readiness_probe: Option<models::Probe>,

    #[serde(rename = "resources")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resources: Option<models::ResourceRequirements>,

    #[serde(rename = "securityContext")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_context: Option<models::SecurityContext>,

    #[serde(rename = "startupProbe")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub startup_probe: Option<models::Probe>,

/// Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false. +optional
    #[serde(rename = "stdin")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stdin: Option<bool>,

/// Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false +optional
    #[serde(rename = "stdinOnce")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stdin_once: Option<bool>,

/// Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated. +optional
    #[serde(rename = "terminationMessagePath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub termination_message_path: Option<String>,

/// +enum
    #[serde(rename = "terminationMessagePolicy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub termination_message_policy: Option<String>,

/// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false. +optional
    #[serde(rename = "tty")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tty: Option<bool>,

/// volumeDevices is the list of block devices to be used by the container. +patchMergeKey=devicePath +patchStrategy=merge +optional
    #[serde(rename = "volumeDevices")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_devices: Option<Vec<models::VolumeDevice>>,

/// Pod volumes to mount into the container's filesystem. Cannot be updated. +optional +patchMergeKey=mountPath +patchStrategy=merge
    #[serde(rename = "volumeMounts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_mounts: Option<Vec<models::VolumeMount>>,

/// Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated. +optional
    #[serde(rename = "workingDir")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub working_dir: Option<String>,

}


impl Container {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Container {
        Container {
            args: None,
            command: None,
            env: None,
            env_from: None,
            image: None,
            image_pull_policy: None,
            lifecycle: None,
            liveness_probe: None,
            name: None,
            ports: None,
            readiness_probe: None,
            resources: None,
            security_context: None,
            startup_probe: None,
            stdin: None,
            stdin_once: None,
            termination_message_path: None,
            termination_message_policy: None,
            tty: None,
            volume_devices: None,
            volume_mounts: None,
            working_dir: None,
        }
    }
}

/// Converts the Container value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Container {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.args.as_ref().map(|args| {
                [
                    "args".to_string(),
                    args.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.command.as_ref().map(|command| {
                [
                    "command".to_string(),
                    command.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping env in query parameter serialization

            // Skipping envFrom in query parameter serialization


            self.image.as_ref().map(|image| {
                [
                    "image".to_string(),
                    image.to_string(),
                ].join(",")
            }),


            self.image_pull_policy.as_ref().map(|image_pull_policy| {
                [
                    "imagePullPolicy".to_string(),
                    image_pull_policy.to_string(),
                ].join(",")
            }),

            // Skipping lifecycle in query parameter serialization

            // Skipping livenessProbe in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping ports in query parameter serialization

            // Skipping readinessProbe in query parameter serialization

            // Skipping resources in query parameter serialization

            // Skipping securityContext in query parameter serialization

            // Skipping startupProbe in query parameter serialization


            self.stdin.as_ref().map(|stdin| {
                [
                    "stdin".to_string(),
                    stdin.to_string(),
                ].join(",")
            }),


            self.stdin_once.as_ref().map(|stdin_once| {
                [
                    "stdinOnce".to_string(),
                    stdin_once.to_string(),
                ].join(",")
            }),


            self.termination_message_path.as_ref().map(|termination_message_path| {
                [
                    "terminationMessagePath".to_string(),
                    termination_message_path.to_string(),
                ].join(",")
            }),


            self.termination_message_policy.as_ref().map(|termination_message_policy| {
                [
                    "terminationMessagePolicy".to_string(),
                    termination_message_policy.to_string(),
                ].join(",")
            }),


            self.tty.as_ref().map(|tty| {
                [
                    "tty".to_string(),
                    tty.to_string(),
                ].join(",")
            }),

            // Skipping volumeDevices in query parameter serialization

            // Skipping volumeMounts in query parameter serialization


            self.working_dir.as_ref().map(|working_dir| {
                [
                    "workingDir".to_string(),
                    working_dir.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Container value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Container {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub args: Vec<Vec<String>>,
            pub command: Vec<Vec<String>>,
            pub env: Vec<Vec<models::EnvVar>>,
            pub env_from: Vec<Vec<models::EnvFromSource>>,
            pub image: Vec<String>,
            pub image_pull_policy: Vec<String>,
            pub lifecycle: Vec<models::Lifecycle>,
            pub liveness_probe: Vec<models::Probe>,
            pub name: Vec<String>,
            pub ports: Vec<Vec<models::ContainerPort>>,
            pub readiness_probe: Vec<models::Probe>,
            pub resources: Vec<models::ResourceRequirements>,
            pub security_context: Vec<models::SecurityContext>,
            pub startup_probe: Vec<models::Probe>,
            pub stdin: Vec<bool>,
            pub stdin_once: Vec<bool>,
            pub termination_message_path: Vec<String>,
            pub termination_message_policy: Vec<String>,
            pub tty: Vec<bool>,
            pub volume_devices: Vec<Vec<models::VolumeDevice>>,
            pub volume_mounts: Vec<Vec<models::VolumeMount>>,
            pub working_dir: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Container".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "args" => return std::result::Result::Err("Parsing a container in this style is not supported in Container".to_string()),
                    "command" => return std::result::Result::Err("Parsing a container in this style is not supported in Container".to_string()),
                    "env" => return std::result::Result::Err("Parsing a container in this style is not supported in Container".to_string()),
                    "envFrom" => return std::result::Result::Err("Parsing a container in this style is not supported in Container".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "image" => intermediate_rep.image.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "imagePullPolicy" => intermediate_rep.image_pull_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lifecycle" => intermediate_rep.lifecycle.push(<models::Lifecycle as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "livenessProbe" => intermediate_rep.liveness_probe.push(<models::Probe as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ports" => return std::result::Result::Err("Parsing a container in this style is not supported in Container".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "readinessProbe" => intermediate_rep.readiness_probe.push(<models::Probe as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "resources" => intermediate_rep.resources.push(<models::ResourceRequirements as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "securityContext" => intermediate_rep.security_context.push(<models::SecurityContext as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "startupProbe" => intermediate_rep.startup_probe.push(<models::Probe as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stdin" => intermediate_rep.stdin.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stdinOnce" => intermediate_rep.stdin_once.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "terminationMessagePath" => intermediate_rep.termination_message_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "terminationMessagePolicy" => intermediate_rep.termination_message_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tty" => intermediate_rep.tty.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "volumeDevices" => return std::result::Result::Err("Parsing a container in this style is not supported in Container".to_string()),
                    "volumeMounts" => return std::result::Result::Err("Parsing a container in this style is not supported in Container".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "workingDir" => intermediate_rep.working_dir.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Container".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Container {
            args: intermediate_rep.args.into_iter().next(),
            command: intermediate_rep.command.into_iter().next(),
            env: intermediate_rep.env.into_iter().next(),
            env_from: intermediate_rep.env_from.into_iter().next(),
            image: intermediate_rep.image.into_iter().next(),
            image_pull_policy: intermediate_rep.image_pull_policy.into_iter().next(),
            lifecycle: intermediate_rep.lifecycle.into_iter().next(),
            liveness_probe: intermediate_rep.liveness_probe.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            ports: intermediate_rep.ports.into_iter().next(),
            readiness_probe: intermediate_rep.readiness_probe.into_iter().next(),
            resources: intermediate_rep.resources.into_iter().next(),
            security_context: intermediate_rep.security_context.into_iter().next(),
            startup_probe: intermediate_rep.startup_probe.into_iter().next(),
            stdin: intermediate_rep.stdin.into_iter().next(),
            stdin_once: intermediate_rep.stdin_once.into_iter().next(),
            termination_message_path: intermediate_rep.termination_message_path.into_iter().next(),
            termination_message_policy: intermediate_rep.termination_message_policy.into_iter().next(),
            tty: intermediate_rep.tty.into_iter().next(),
            volume_devices: intermediate_rep.volume_devices.into_iter().next(),
            volume_mounts: intermediate_rep.volume_mounts.into_iter().next(),
            working_dir: intermediate_rep.working_dir.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Container> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Container>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Container>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Container - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Container> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Container as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Container - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ContainerChangeResponseItem change item in response to ContainerChanges operation



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerChangeResponseItem {
/// Kind of change
    #[serde(rename = "Kind")]
    pub kind: i32,

/// Path to file that has changed
    #[serde(rename = "Path")]
    pub path: String,

}


impl ContainerChangeResponseItem {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(kind: i32, path: String, ) -> ContainerChangeResponseItem {
        ContainerChangeResponseItem {
            kind,
            path,
        }
    }
}

/// Converts the ContainerChangeResponseItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ContainerChangeResponseItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("Kind".to_string()),
            Some(self.kind.to_string()),


            Some("Path".to_string()),
            Some(self.path.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerChangeResponseItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerChangeResponseItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub kind: Vec<i32>,
            pub path: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerChangeResponseItem".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Kind" => intermediate_rep.kind.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerChangeResponseItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerChangeResponseItem {
            kind: intermediate_rep.kind.into_iter().next().ok_or_else(|| "Kind missing in ContainerChangeResponseItem".to_string())?,
            path: intermediate_rep.path.into_iter().next().ok_or_else(|| "Path missing in ContainerChangeResponseItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerChangeResponseItem> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerChangeResponseItem>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerChangeResponseItem>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerChangeResponseItem - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerChangeResponseItem> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerChangeResponseItem as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerChangeResponseItem - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ContainerCreateCreatedBody OK response to ContainerCreate operation



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerCreateCreatedBody {
/// The ID of the created container
    #[serde(rename = "Id")]
    pub id: String,

/// Warnings encountered when creating the container
    #[serde(rename = "Warnings")]
    pub warnings: Vec<String>,

}


impl ContainerCreateCreatedBody {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, warnings: Vec<String>, ) -> ContainerCreateCreatedBody {
        ContainerCreateCreatedBody {
            id,
            warnings,
        }
    }
}

/// Converts the ContainerCreateCreatedBody value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ContainerCreateCreatedBody {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("Id".to_string()),
            Some(self.id.to_string()),


            Some("Warnings".to_string()),
            Some(self.warnings.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerCreateCreatedBody value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerCreateCreatedBody {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub warnings: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerCreateCreatedBody".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Warnings" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerCreateCreatedBody".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerCreateCreatedBody".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerCreateCreatedBody {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "Id missing in ContainerCreateCreatedBody".to_string())?,
            warnings: intermediate_rep.warnings.into_iter().next().ok_or_else(|| "Warnings missing in ContainerCreateCreatedBody".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerCreateCreatedBody> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerCreateCreatedBody>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerCreateCreatedBody>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerCreateCreatedBody - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerCreateCreatedBody> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerCreateCreatedBody as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerCreateCreatedBody - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerPort {
/// Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
    #[serde(rename = "containerPort")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_port: Option<i32>,

/// What host IP to bind the external port to. +optional
    #[serde(rename = "hostIP")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_ip: Option<String>,

/// Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this. +optional
    #[serde(rename = "hostPort")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_port: Option<i32>,

/// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services. +optional
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// +enum
    #[serde(rename = "protocol")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub protocol: Option<String>,

}


impl ContainerPort {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainerPort {
        ContainerPort {
            container_port: None,
            host_ip: None,
            host_port: None,
            name: None,
            protocol: None,
        }
    }
}

/// Converts the ContainerPort value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ContainerPort {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.container_port.as_ref().map(|container_port| {
                [
                    "containerPort".to_string(),
                    container_port.to_string(),
                ].join(",")
            }),


            self.host_ip.as_ref().map(|host_ip| {
                [
                    "hostIP".to_string(),
                    host_ip.to_string(),
                ].join(",")
            }),


            self.host_port.as_ref().map(|host_port| {
                [
                    "hostPort".to_string(),
                    host_port.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.protocol.as_ref().map(|protocol| {
                [
                    "protocol".to_string(),
                    protocol.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerPort value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerPort {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub container_port: Vec<i32>,
            pub host_ip: Vec<String>,
            pub host_port: Vec<i32>,
            pub name: Vec<String>,
            pub protocol: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerPort".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "containerPort" => intermediate_rep.container_port.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hostIP" => intermediate_rep.host_ip.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hostPort" => intermediate_rep.host_port.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "protocol" => intermediate_rep.protocol.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerPort".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerPort {
            container_port: intermediate_rep.container_port.into_iter().next(),
            host_ip: intermediate_rep.host_ip.into_iter().next(),
            host_port: intermediate_rep.host_port.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            protocol: intermediate_rep.protocol.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerPort> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerPort>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerPort>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerPort - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerPort> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerPort as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerPort - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ContainerTopOKBody OK response to ContainerTop operation



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerTopOkBody {
/// Each process running in the container, where each is process is an array of values corresponding to the titles.
    #[serde(rename = "Processes")]
    pub processes: Vec<Vec<String>>,

/// The ps column titles
    #[serde(rename = "Titles")]
    pub titles: Vec<String>,

}


impl ContainerTopOkBody {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(processes: Vec<Vec<String>>, titles: Vec<String>, ) -> ContainerTopOkBody {
        ContainerTopOkBody {
            processes,
            titles,
        }
    }
}

/// Converts the ContainerTopOkBody value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ContainerTopOkBody {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping Processes in query parameter serialization


            Some("Titles".to_string()),
            Some(self.titles.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerTopOkBody value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerTopOkBody {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub processes: Vec<Vec<Vec<String>>>,
            pub titles: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerTopOkBody".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Processes" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerTopOkBody".to_string()),
                    "Titles" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerTopOkBody".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerTopOkBody".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerTopOkBody {
            processes: intermediate_rep.processes.into_iter().next().ok_or_else(|| "Processes missing in ContainerTopOkBody".to_string())?,
            titles: intermediate_rep.titles.into_iter().next().ok_or_else(|| "Titles missing in ContainerTopOkBody".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerTopOkBody> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerTopOkBody>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerTopOkBody>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerTopOkBody - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerTopOkBody> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerTopOkBody as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerTopOkBody - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ContainerUpdateOKBody OK response to ContainerUpdate operation



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerUpdateOkBody {
/// warnings
    #[serde(rename = "Warnings")]
    pub warnings: Vec<String>,

}


impl ContainerUpdateOkBody {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(warnings: Vec<String>, ) -> ContainerUpdateOkBody {
        ContainerUpdateOkBody {
            warnings,
        }
    }
}

/// Converts the ContainerUpdateOkBody value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ContainerUpdateOkBody {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("Warnings".to_string()),
            Some(self.warnings.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerUpdateOkBody value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerUpdateOkBody {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub warnings: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerUpdateOkBody".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Warnings" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerUpdateOkBody".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerUpdateOkBody".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerUpdateOkBody {
            warnings: intermediate_rep.warnings.into_iter().next().ok_or_else(|| "Warnings missing in ContainerUpdateOkBody".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerUpdateOkBody> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerUpdateOkBody>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerUpdateOkBody>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerUpdateOkBody - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerUpdateOkBody> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerUpdateOkBody as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerUpdateOkBody - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ContainerWaitOKBody OK response to ContainerWait operation



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerWaitOkBody {
    #[serde(rename = "Error")]
    pub error: models::ContainerWaitOkBodyError,

/// Exit code of the container
    #[serde(rename = "StatusCode")]
    pub status_code: i64,

}


impl ContainerWaitOkBody {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(error: models::ContainerWaitOkBodyError, status_code: i64, ) -> ContainerWaitOkBody {
        ContainerWaitOkBody {
            error,
            status_code,
        }
    }
}

/// Converts the ContainerWaitOkBody value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ContainerWaitOkBody {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping Error in query parameter serialization


            Some("StatusCode".to_string()),
            Some(self.status_code.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerWaitOkBody value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerWaitOkBody {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub error: Vec<models::ContainerWaitOkBodyError>,
            pub status_code: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerWaitOkBody".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Error" => intermediate_rep.error.push(<models::ContainerWaitOkBodyError as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StatusCode" => intermediate_rep.status_code.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerWaitOkBody".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerWaitOkBody {
            error: intermediate_rep.error.into_iter().next().ok_or_else(|| "Error missing in ContainerWaitOkBody".to_string())?,
            status_code: intermediate_rep.status_code.into_iter().next().ok_or_else(|| "StatusCode missing in ContainerWaitOkBody".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerWaitOkBody> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerWaitOkBody>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerWaitOkBody>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerWaitOkBody - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerWaitOkBody> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerWaitOkBody as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerWaitOkBody - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ContainerWaitOKBodyError container waiting error, if any



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerWaitOkBodyError {
/// Details of an error
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

}


impl ContainerWaitOkBodyError {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainerWaitOkBodyError {
        ContainerWaitOkBodyError {
            message: None,
        }
    }
}

/// Converts the ContainerWaitOkBodyError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ContainerWaitOkBodyError {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.message.as_ref().map(|message| {
                [
                    "Message".to_string(),
                    message.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerWaitOkBodyError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerWaitOkBodyError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerWaitOkBodyError".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerWaitOkBodyError".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerWaitOkBodyError {
            message: intermediate_rep.message.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerWaitOkBodyError> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerWaitOkBodyError>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerWaitOkBodyError>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerWaitOkBodyError - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerWaitOkBodyError> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerWaitOkBodyError as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerWaitOkBodyError - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Represents a source location of a volume to mount, managed by an external CSI driver



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CsiVolumeSource {
/// Driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
    #[serde(rename = "driver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver: Option<String>,

/// Filesystem type to mount. Ex. \"ext4\", \"xfs\", \"ntfs\". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply. +optional
    #[serde(rename = "fsType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fs_type: Option<String>,

    #[serde(rename = "nodePublishSecretRef")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_publish_secret_ref: Option<models::LocalObjectReference>,

/// Specifies a read-only configuration for the volume. Defaults to false (read/write). +optional
    #[serde(rename = "readOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

/// VolumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values. +optional
    #[serde(rename = "volumeAttributes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_attributes: Option<std::collections::HashMap<String, String>>,

}


impl CsiVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CsiVolumeSource {
        CsiVolumeSource {
            driver: None,
            fs_type: None,
            node_publish_secret_ref: None,
            read_only: None,
            volume_attributes: None,
        }
    }
}

/// Converts the CsiVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CsiVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.driver.as_ref().map(|driver| {
                [
                    "driver".to_string(),
                    driver.to_string(),
                ].join(",")
            }),


            self.fs_type.as_ref().map(|fs_type| {
                [
                    "fsType".to_string(),
                    fs_type.to_string(),
                ].join(",")
            }),

            // Skipping nodePublishSecretRef in query parameter serialization


            self.read_only.as_ref().map(|read_only| {
                [
                    "readOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),

            // Skipping volumeAttributes in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CsiVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CsiVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub driver: Vec<String>,
            pub fs_type: Vec<String>,
            pub node_publish_secret_ref: Vec<models::LocalObjectReference>,
            pub read_only: Vec<bool>,
            pub volume_attributes: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CsiVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "driver" => intermediate_rep.driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fsType" => intermediate_rep.fs_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "nodePublishSecretRef" => intermediate_rep.node_publish_secret_ref.push(<models::LocalObjectReference as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "readOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "volumeAttributes" => return std::result::Result::Err("Parsing a container in this style is not supported in CsiVolumeSource".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CsiVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CsiVolumeSource {
            driver: intermediate_rep.driver.into_iter().next(),
            fs_type: intermediate_rep.fs_type.into_iter().next(),
            node_publish_secret_ref: intermediate_rep.node_publish_secret_ref.into_iter().next(),
            read_only: intermediate_rep.read_only.into_iter().next(),
            volume_attributes: intermediate_rep.volume_attributes.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CsiVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CsiVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CsiVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CsiVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CsiVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CsiVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CsiVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeviceMapping {
    #[serde(rename = "CgroupPermissions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_permissions: Option<String>,

    #[serde(rename = "PathInContainer")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path_in_container: Option<String>,

    #[serde(rename = "PathOnHost")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path_on_host: Option<String>,

}


impl DeviceMapping {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> DeviceMapping {
        DeviceMapping {
            cgroup_permissions: None,
            path_in_container: None,
            path_on_host: None,
        }
    }
}

/// Converts the DeviceMapping value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeviceMapping {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.cgroup_permissions.as_ref().map(|cgroup_permissions| {
                [
                    "CgroupPermissions".to_string(),
                    cgroup_permissions.to_string(),
                ].join(",")
            }),


            self.path_in_container.as_ref().map(|path_in_container| {
                [
                    "PathInContainer".to_string(),
                    path_in_container.to_string(),
                ].join(",")
            }),


            self.path_on_host.as_ref().map(|path_on_host| {
                [
                    "PathOnHost".to_string(),
                    path_on_host.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeviceMapping value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeviceMapping {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cgroup_permissions: Vec<String>,
            pub path_in_container: Vec<String>,
            pub path_on_host: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeviceMapping".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "CgroupPermissions" => intermediate_rep.cgroup_permissions.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PathInContainer" => intermediate_rep.path_in_container.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PathOnHost" => intermediate_rep.path_on_host.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeviceMapping".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeviceMapping {
            cgroup_permissions: intermediate_rep.cgroup_permissions.into_iter().next(),
            path_in_container: intermediate_rep.path_in_container.into_iter().next(),
            path_on_host: intermediate_rep.path_on_host.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeviceMapping> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DeviceMapping>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeviceMapping>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeviceMapping - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DeviceMapping> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeviceMapping as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeviceMapping - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Used by GPU device drivers.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeviceRequest {
    #[serde(rename = "Capabilities")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub capabilities: Option<Vec<Vec<String>>>,

    #[serde(rename = "Count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i64>,

    #[serde(rename = "DeviceIDs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_ids: Option<Vec<String>>,

    #[serde(rename = "Driver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver: Option<String>,

    #[serde(rename = "Options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<std::collections::HashMap<String, String>>,

}


impl DeviceRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> DeviceRequest {
        DeviceRequest {
            capabilities: None,
            count: None,
            device_ids: None,
            driver: None,
            options: None,
        }
    }
}

/// Converts the DeviceRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeviceRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping Capabilities in query parameter serialization


            self.count.as_ref().map(|count| {
                [
                    "Count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.device_ids.as_ref().map(|device_ids| {
                [
                    "DeviceIDs".to_string(),
                    device_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.driver.as_ref().map(|driver| {
                [
                    "Driver".to_string(),
                    driver.to_string(),
                ].join(",")
            }),

            // Skipping Options in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeviceRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeviceRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub capabilities: Vec<Vec<Vec<String>>>,
            pub count: Vec<i64>,
            pub device_ids: Vec<Vec<String>>,
            pub driver: Vec<String>,
            pub options: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeviceRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Capabilities" => return std::result::Result::Err("Parsing a container in this style is not supported in DeviceRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Count" => intermediate_rep.count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "DeviceIDs" => return std::result::Result::Err("Parsing a container in this style is not supported in DeviceRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Driver" => intermediate_rep.driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Options" => return std::result::Result::Err("Parsing a container in this style is not supported in DeviceRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeviceRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeviceRequest {
            capabilities: intermediate_rep.capabilities.into_iter().next(),
            count: intermediate_rep.count.into_iter().next(),
            device_ids: intermediate_rep.device_ids.into_iter().next(),
            driver: intermediate_rep.driver.into_iter().next(),
            options: intermediate_rep.options.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeviceRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DeviceRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeviceRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeviceRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DeviceRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeviceRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeviceRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// +enum
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DnsPolicy(String);

impl validator::Validate for DnsPolicy {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for DnsPolicy {
    fn from(x: String) -> Self {
        DnsPolicy(x)
    }
}

impl std::string::ToString for DnsPolicy {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for DnsPolicy {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(DnsPolicy(x.to_string()))
    }
}

impl std::convert::From<DnsPolicy> for String {
    fn from(x: DnsPolicy) -> Self {
        x.0
    }
}

impl std::ops::Deref for DnsPolicy {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for DnsPolicy {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DockerConfig {
    #[serde(rename = "connection")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connection: Option<models::DockerConnectionConfig>,

    #[serde(rename = "execution")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub execution: Option<models::DockerExecutionConfig>,

    #[serde(rename = "timeouts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeouts: Option<models::DockerTimeoutConfig>,

}


impl DockerConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> DockerConfig {
        DockerConfig {
            connection: None,
            execution: None,
            timeouts: None,
        }
    }
}

/// Converts the DockerConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DockerConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping connection in query parameter serialization

            // Skipping execution in query parameter serialization

            // Skipping timeouts in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DockerConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DockerConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub connection: Vec<models::DockerConnectionConfig>,
            pub execution: Vec<models::DockerExecutionConfig>,
            pub timeouts: Vec<models::DockerTimeoutConfig>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DockerConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "connection" => intermediate_rep.connection.push(<models::DockerConnectionConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "execution" => intermediate_rep.execution.push(<models::DockerExecutionConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "timeouts" => intermediate_rep.timeouts.push(<models::DockerTimeoutConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DockerConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DockerConfig {
            connection: intermediate_rep.connection.into_iter().next(),
            execution: intermediate_rep.execution.into_iter().next(),
            timeouts: intermediate_rep.timeouts.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DockerConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DockerConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DockerConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DockerConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DockerConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DockerConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DockerConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DockerConnectionConfig {
/// CaCert is the CA certificate for Docker connection embedded in the configuration in PEM format.
    #[serde(rename = "cacert")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cacert: Option<String>,

/// Cert is the client certificate in PEM format embedded in the configuration.
    #[serde(rename = "cert")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cert: Option<String>,

/// Host is the docker connect URL.
    #[serde(rename = "host")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host: Option<String>,

/// Key is the client key in PEM format embedded in the configuration.
    #[serde(rename = "key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,

}


impl DockerConnectionConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> DockerConnectionConfig {
        DockerConnectionConfig {
            cacert: None,
            cert: None,
            host: None,
            key: None,
        }
    }
}

/// Converts the DockerConnectionConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DockerConnectionConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.cacert.as_ref().map(|cacert| {
                [
                    "cacert".to_string(),
                    cacert.to_string(),
                ].join(",")
            }),


            self.cert.as_ref().map(|cert| {
                [
                    "cert".to_string(),
                    cert.to_string(),
                ].join(",")
            }),


            self.host.as_ref().map(|host| {
                [
                    "host".to_string(),
                    host.to_string(),
                ].join(",")
            }),


            self.key.as_ref().map(|key| {
                [
                    "key".to_string(),
                    key.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DockerConnectionConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DockerConnectionConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cacert: Vec<String>,
            pub cert: Vec<String>,
            pub host: Vec<String>,
            pub key: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DockerConnectionConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "cacert" => intermediate_rep.cacert.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cert" => intermediate_rep.cert.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "host" => intermediate_rep.host.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "key" => intermediate_rep.key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DockerConnectionConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DockerConnectionConfig {
            cacert: intermediate_rep.cacert.into_iter().next(),
            cert: intermediate_rep.cert.into_iter().next(),
            host: intermediate_rep.host.into_iter().next(),
            key: intermediate_rep.key.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DockerConnectionConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DockerConnectionConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DockerConnectionConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DockerConnectionConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DockerConnectionConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DockerConnectionConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DockerConnectionConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// goland:noinspection GoVetStructTag



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DockerExecutionConfig {
/// AgentPath contains the path to the ContainerSSH Guest Agent.
    #[serde(rename = "agentPath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub agent_path: Option<String>,

    #[serde(rename = "auth")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auth: Option<models::AuthConfig>,

    #[serde(rename = "container")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container: Option<models::Config>,

/// ContainerName is the name of the container to launch. It is recommended to leave this empty, otherwise ContainerSSH may not be able to start the container if a container with the same name already exists.
    #[serde(rename = "containername")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub containername: Option<String>,

/// DisableAgent enables using the ContainerSSH Guest Agent.
    #[serde(rename = "disableAgent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub disable_agent: Option<bool>,

/// ExposeAuthMetadataAsEnv lets you expose the authentication metadata (e.g. GITHUB_TOKEN) as an environment variable in the container. In contrast to the environment variables set in the SSH connection these environment variables are available to all processes in the container, including the idle command.
    #[serde(rename = "exposeAuthMetadataAsEnv")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expose_auth_metadata_as_env: Option<bool>,

    #[serde(rename = "host")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host: Option<models::HostConfig>,

/// IdleCommand is the command that runs as the first process in the container in DockerExecutionModeConnection. Ignored in DockerExecutionModeSession.
    #[serde(rename = "idleCommand")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub idle_command: Option<Vec<String>>,

/// ImagePullPolicyAlways means that the container image will be pulled on every connection. ImagePullPolicyIfNotPresent means the image will be pulled if the image is not present locally, an empty tag, or the \"latest\" tag was specified. ImagePullPolicyNever means that the image will never be pulled, and if the image is not available locally the connection will fail.
    #[serde(rename = "imagePullPolicy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_pull_policy: Option<String>,

/// DockerExecutionModeConnection launches one container per SSH connection (default), while DockerExecutionModeSession launches one container per SSH session.
    #[serde(rename = "mode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mode: Option<String>,

    #[serde(rename = "network")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network: Option<models::NetworkingConfig>,

    #[serde(rename = "platform")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub platform: Option<models::Platform>,

/// ShellCommand is the command used for launching shells when the container is in DockerExecutionModeConnection. Ignored in DockerExecutionModeSession.
    #[serde(rename = "shellCommand")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shell_command: Option<Vec<String>>,

/// Subsystems contains a map of subsystem names and their corresponding binaries in the container.
    #[serde(rename = "subsystems")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subsystems: Option<std::collections::HashMap<String, String>>,

}


impl DockerExecutionConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> DockerExecutionConfig {
        DockerExecutionConfig {
            agent_path: None,
            auth: None,
            container: None,
            containername: None,
            disable_agent: None,
            expose_auth_metadata_as_env: None,
            host: None,
            idle_command: None,
            image_pull_policy: None,
            mode: None,
            network: None,
            platform: None,
            shell_command: None,
            subsystems: None,
        }
    }
}

/// Converts the DockerExecutionConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DockerExecutionConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.agent_path.as_ref().map(|agent_path| {
                [
                    "agentPath".to_string(),
                    agent_path.to_string(),
                ].join(",")
            }),

            // Skipping auth in query parameter serialization

            // Skipping container in query parameter serialization


            self.containername.as_ref().map(|containername| {
                [
                    "containername".to_string(),
                    containername.to_string(),
                ].join(",")
            }),


            self.disable_agent.as_ref().map(|disable_agent| {
                [
                    "disableAgent".to_string(),
                    disable_agent.to_string(),
                ].join(",")
            }),


            self.expose_auth_metadata_as_env.as_ref().map(|expose_auth_metadata_as_env| {
                [
                    "exposeAuthMetadataAsEnv".to_string(),
                    expose_auth_metadata_as_env.to_string(),
                ].join(",")
            }),

            // Skipping host in query parameter serialization


            self.idle_command.as_ref().map(|idle_command| {
                [
                    "idleCommand".to_string(),
                    idle_command.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.image_pull_policy.as_ref().map(|image_pull_policy| {
                [
                    "imagePullPolicy".to_string(),
                    image_pull_policy.to_string(),
                ].join(",")
            }),


            self.mode.as_ref().map(|mode| {
                [
                    "mode".to_string(),
                    mode.to_string(),
                ].join(",")
            }),

            // Skipping network in query parameter serialization

            // Skipping platform in query parameter serialization


            self.shell_command.as_ref().map(|shell_command| {
                [
                    "shellCommand".to_string(),
                    shell_command.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping subsystems in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DockerExecutionConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DockerExecutionConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub agent_path: Vec<String>,
            pub auth: Vec<models::AuthConfig>,
            pub container: Vec<models::Config>,
            pub containername: Vec<String>,
            pub disable_agent: Vec<bool>,
            pub expose_auth_metadata_as_env: Vec<bool>,
            pub host: Vec<models::HostConfig>,
            pub idle_command: Vec<Vec<String>>,
            pub image_pull_policy: Vec<String>,
            pub mode: Vec<String>,
            pub network: Vec<models::NetworkingConfig>,
            pub platform: Vec<models::Platform>,
            pub shell_command: Vec<Vec<String>>,
            pub subsystems: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DockerExecutionConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "agentPath" => intermediate_rep.agent_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "auth" => intermediate_rep.auth.push(<models::AuthConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "container" => intermediate_rep.container.push(<models::Config as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "containername" => intermediate_rep.containername.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "disableAgent" => intermediate_rep.disable_agent.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "exposeAuthMetadataAsEnv" => intermediate_rep.expose_auth_metadata_as_env.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "host" => intermediate_rep.host.push(<models::HostConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "idleCommand" => return std::result::Result::Err("Parsing a container in this style is not supported in DockerExecutionConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "imagePullPolicy" => intermediate_rep.image_pull_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mode" => intermediate_rep.mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "network" => intermediate_rep.network.push(<models::NetworkingConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "platform" => intermediate_rep.platform.push(<models::Platform as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "shellCommand" => return std::result::Result::Err("Parsing a container in this style is not supported in DockerExecutionConfig".to_string()),
                    "subsystems" => return std::result::Result::Err("Parsing a container in this style is not supported in DockerExecutionConfig".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DockerExecutionConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DockerExecutionConfig {
            agent_path: intermediate_rep.agent_path.into_iter().next(),
            auth: intermediate_rep.auth.into_iter().next(),
            container: intermediate_rep.container.into_iter().next(),
            containername: intermediate_rep.containername.into_iter().next(),
            disable_agent: intermediate_rep.disable_agent.into_iter().next(),
            expose_auth_metadata_as_env: intermediate_rep.expose_auth_metadata_as_env.into_iter().next(),
            host: intermediate_rep.host.into_iter().next(),
            idle_command: intermediate_rep.idle_command.into_iter().next(),
            image_pull_policy: intermediate_rep.image_pull_policy.into_iter().next(),
            mode: intermediate_rep.mode.into_iter().next(),
            network: intermediate_rep.network.into_iter().next(),
            platform: intermediate_rep.platform.into_iter().next(),
            shell_command: intermediate_rep.shell_command.into_iter().next(),
            subsystems: intermediate_rep.subsystems.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DockerExecutionConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DockerExecutionConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DockerExecutionConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DockerExecutionConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DockerExecutionConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DockerExecutionConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DockerExecutionConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// DockerExecutionModeConnection launches one container per SSH connection (default), while DockerExecutionModeSession launches one container per SSH session.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DockerExecutionMode(String);

impl validator::Validate for DockerExecutionMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for DockerExecutionMode {
    fn from(x: String) -> Self {
        DockerExecutionMode(x)
    }
}

impl std::string::ToString for DockerExecutionMode {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for DockerExecutionMode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(DockerExecutionMode(x.to_string()))
    }
}

impl std::convert::From<DockerExecutionMode> for String {
    fn from(x: DockerExecutionMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for DockerExecutionMode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for DockerExecutionMode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// ImagePullPolicyAlways means that the container image will be pulled on every connection. ImagePullPolicyIfNotPresent means the image will be pulled if the image is not present locally, an empty tag, or the \"latest\" tag was specified. ImagePullPolicyNever means that the image will never be pulled, and if the image is not available locally the connection will fail.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DockerImagePullPolicy(String);

impl validator::Validate for DockerImagePullPolicy {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for DockerImagePullPolicy {
    fn from(x: String) -> Self {
        DockerImagePullPolicy(x)
    }
}

impl std::string::ToString for DockerImagePullPolicy {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for DockerImagePullPolicy {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(DockerImagePullPolicy(x.to_string()))
    }
}

impl std::convert::From<DockerImagePullPolicy> for String {
    fn from(x: DockerImagePullPolicy) -> Self {
        x.0
    }
}

impl std::ops::Deref for DockerImagePullPolicy {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for DockerImagePullPolicy {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DockerLaunchConfig {
    #[serde(rename = "container")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container: Option<models::Config>,

/// ContainerName is the name of the container to launch. It is recommended to leave this empty, otherwise ContainerSSH may not be able to start the container if a container with the same name already exists.
    #[serde(rename = "containername")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub containername: Option<String>,

    #[serde(rename = "host")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host: Option<models::HostConfig>,

    #[serde(rename = "network")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network: Option<models::NetworkingConfig>,

    #[serde(rename = "platform")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub platform: Option<models::Platform>,

}


impl DockerLaunchConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> DockerLaunchConfig {
        DockerLaunchConfig {
            container: None,
            containername: None,
            host: None,
            network: None,
            platform: None,
        }
    }
}

/// Converts the DockerLaunchConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DockerLaunchConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping container in query parameter serialization


            self.containername.as_ref().map(|containername| {
                [
                    "containername".to_string(),
                    containername.to_string(),
                ].join(",")
            }),

            // Skipping host in query parameter serialization

            // Skipping network in query parameter serialization

            // Skipping platform in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DockerLaunchConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DockerLaunchConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub container: Vec<models::Config>,
            pub containername: Vec<String>,
            pub host: Vec<models::HostConfig>,
            pub network: Vec<models::NetworkingConfig>,
            pub platform: Vec<models::Platform>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DockerLaunchConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "container" => intermediate_rep.container.push(<models::Config as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "containername" => intermediate_rep.containername.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "host" => intermediate_rep.host.push(<models::HostConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "network" => intermediate_rep.network.push(<models::NetworkingConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "platform" => intermediate_rep.platform.push(<models::Platform as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DockerLaunchConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DockerLaunchConfig {
            container: intermediate_rep.container.into_iter().next(),
            containername: intermediate_rep.containername.into_iter().next(),
            host: intermediate_rep.host.into_iter().next(),
            network: intermediate_rep.network.into_iter().next(),
            platform: intermediate_rep.platform.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DockerLaunchConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DockerLaunchConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DockerLaunchConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DockerLaunchConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DockerLaunchConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DockerLaunchConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DockerLaunchConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DockerTimeoutConfig {
/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "commandStart")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub command_start: Option<i64>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "containerStart")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_start: Option<i64>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "containerStop")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_stop: Option<i64>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "http")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub http: Option<i64>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "signal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub signal: Option<i64>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "window")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub window: Option<i64>,

}


impl DockerTimeoutConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> DockerTimeoutConfig {
        DockerTimeoutConfig {
            command_start: None,
            container_start: None,
            container_stop: None,
            http: None,
            signal: None,
            window: None,
        }
    }
}

/// Converts the DockerTimeoutConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DockerTimeoutConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.command_start.as_ref().map(|command_start| {
                [
                    "commandStart".to_string(),
                    command_start.to_string(),
                ].join(",")
            }),


            self.container_start.as_ref().map(|container_start| {
                [
                    "containerStart".to_string(),
                    container_start.to_string(),
                ].join(",")
            }),


            self.container_stop.as_ref().map(|container_stop| {
                [
                    "containerStop".to_string(),
                    container_stop.to_string(),
                ].join(",")
            }),


            self.http.as_ref().map(|http| {
                [
                    "http".to_string(),
                    http.to_string(),
                ].join(",")
            }),


            self.signal.as_ref().map(|signal| {
                [
                    "signal".to_string(),
                    signal.to_string(),
                ].join(",")
            }),


            self.window.as_ref().map(|window| {
                [
                    "window".to_string(),
                    window.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DockerTimeoutConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DockerTimeoutConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub command_start: Vec<i64>,
            pub container_start: Vec<i64>,
            pub container_stop: Vec<i64>,
            pub http: Vec<i64>,
            pub signal: Vec<i64>,
            pub window: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DockerTimeoutConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "commandStart" => intermediate_rep.command_start.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "containerStart" => intermediate_rep.container_start.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "containerStop" => intermediate_rep.container_stop.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "http" => intermediate_rep.http.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "signal" => intermediate_rep.signal.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "window" => intermediate_rep.window.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DockerTimeoutConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DockerTimeoutConfig {
            command_start: intermediate_rep.command_start.into_iter().next(),
            container_start: intermediate_rep.container_start.into_iter().next(),
            container_stop: intermediate_rep.container_stop.into_iter().next(),
            http: intermediate_rep.http.into_iter().next(),
            signal: intermediate_rep.signal.into_iter().next(),
            window: intermediate_rep.window.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DockerTimeoutConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DockerTimeoutConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DockerTimeoutConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DockerTimeoutConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DockerTimeoutConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DockerTimeoutConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DockerTimeoutConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Note that this is identical to a downwardAPI volume source without the default mode.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DownwardApiProjection {
/// Items is a list of DownwardAPIVolume file +optional
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::DownwardApiVolumeFile>>,

}


impl DownwardApiProjection {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> DownwardApiProjection {
        DownwardApiProjection {
            items: None,
        }
    }
}

/// Converts the DownwardApiProjection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DownwardApiProjection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DownwardApiProjection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DownwardApiProjection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::DownwardApiVolumeFile>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DownwardApiProjection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in DownwardApiProjection".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DownwardApiProjection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DownwardApiProjection {
            items: intermediate_rep.items.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DownwardApiProjection> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DownwardApiProjection>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DownwardApiProjection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DownwardApiProjection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DownwardApiProjection> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DownwardApiProjection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DownwardApiProjection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// DownwardAPIVolumeFile represents information to create the file containing the pod field



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DownwardApiVolumeFile {
    #[serde(rename = "fieldRef")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub field_ref: Option<models::ObjectFieldSelector>,

/// Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. +optional
    #[serde(rename = "mode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mode: Option<i32>,

/// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    #[serde(rename = "path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

    #[serde(rename = "resourceFieldRef")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resource_field_ref: Option<models::ResourceFieldSelector>,

}


impl DownwardApiVolumeFile {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> DownwardApiVolumeFile {
        DownwardApiVolumeFile {
            field_ref: None,
            mode: None,
            path: None,
            resource_field_ref: None,
        }
    }
}

/// Converts the DownwardApiVolumeFile value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DownwardApiVolumeFile {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping fieldRef in query parameter serialization


            self.mode.as_ref().map(|mode| {
                [
                    "mode".to_string(),
                    mode.to_string(),
                ].join(",")
            }),


            self.path.as_ref().map(|path| {
                [
                    "path".to_string(),
                    path.to_string(),
                ].join(",")
            }),

            // Skipping resourceFieldRef in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DownwardApiVolumeFile value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DownwardApiVolumeFile {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub field_ref: Vec<models::ObjectFieldSelector>,
            pub mode: Vec<i32>,
            pub path: Vec<String>,
            pub resource_field_ref: Vec<models::ResourceFieldSelector>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DownwardApiVolumeFile".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "fieldRef" => intermediate_rep.field_ref.push(<models::ObjectFieldSelector as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mode" => intermediate_rep.mode.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "resourceFieldRef" => intermediate_rep.resource_field_ref.push(<models::ResourceFieldSelector as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DownwardApiVolumeFile".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DownwardApiVolumeFile {
            field_ref: intermediate_rep.field_ref.into_iter().next(),
            mode: intermediate_rep.mode.into_iter().next(),
            path: intermediate_rep.path.into_iter().next(),
            resource_field_ref: intermediate_rep.resource_field_ref.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DownwardApiVolumeFile> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DownwardApiVolumeFile>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DownwardApiVolumeFile>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DownwardApiVolumeFile - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DownwardApiVolumeFile> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DownwardApiVolumeFile as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DownwardApiVolumeFile - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Downward API volumes support ownership management and SELinux relabeling.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DownwardApiVolumeSource {
/// Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. +optional
    #[serde(rename = "defaultMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_mode: Option<i32>,

/// Items is a list of downward API volume file +optional
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::DownwardApiVolumeFile>>,

}


impl DownwardApiVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> DownwardApiVolumeSource {
        DownwardApiVolumeSource {
            default_mode: None,
            items: None,
        }
    }
}

/// Converts the DownwardApiVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DownwardApiVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.default_mode.as_ref().map(|default_mode| {
                [
                    "defaultMode".to_string(),
                    default_mode.to_string(),
                ].join(",")
            }),

            // Skipping items in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DownwardApiVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DownwardApiVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub default_mode: Vec<i32>,
            pub items: Vec<Vec<models::DownwardApiVolumeFile>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DownwardApiVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "defaultMode" => intermediate_rep.default_mode.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in DownwardApiVolumeSource".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DownwardApiVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DownwardApiVolumeSource {
            default_mode: intermediate_rep.default_mode.into_iter().next(),
            items: intermediate_rep.items.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DownwardApiVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DownwardApiVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DownwardApiVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DownwardApiVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DownwardApiVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DownwardApiVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DownwardApiVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Driver {
    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "Options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<std::collections::HashMap<String, String>>,

}


impl Driver {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Driver {
        Driver {
            name: None,
            options: None,
        }
    }
}

/// Converts the Driver value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Driver {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping Options in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Driver value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Driver {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub options: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Driver".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Options" => return std::result::Result::Err("Parsing a container in this style is not supported in Driver".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Driver".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Driver {
            name: intermediate_rep.name.into_iter().next(),
            options: intermediate_rep.options.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Driver> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Driver>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Driver>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Driver - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Driver> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Driver as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Driver - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Duration(i64);

impl validator::Validate for Duration {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<i64> for Duration {
    fn from(x: i64) -> Self {
        Duration(x)
    }
}

impl std::convert::From<Duration> for i64 {
    fn from(x: Duration) -> Self {
        x.0
    }
}

impl std::ops::Deref for Duration {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}

impl std::ops::DerefMut for Duration {
    fn deref_mut(&mut self) -> &mut i64 {
        &mut self.0
    }
}



#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EcdhCurve(String);

impl validator::Validate for EcdhCurve {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for EcdhCurve {
    fn from(x: String) -> Self {
        EcdhCurve(x)
    }
}

impl std::string::ToString for EcdhCurve {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for EcdhCurve {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(EcdhCurve(x.to_string()))
    }
}

impl std::convert::From<EcdhCurve> for String {
    fn from(x: EcdhCurve) -> Self {
        x.0
    }
}

impl std::ops::Deref for EcdhCurve {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for EcdhCurve {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// Empty directory volumes support ownership management and SELinux relabeling.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EmptyDirVolumeSource {
    #[serde(rename = "medium")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub medium: Option<String>,

/// The serialization format is:  <quantity>        ::= <signedNumber><suffix> (Note that <suffix> may be empty, from the \"\" case in <decimalSI>.) <digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= \"+\" | \"-\" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html) <decimalSI>       ::= m | \"\" | k | M | G | T | P | E (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.) <decimalExponent> ::= \"e\" <signedNumber> | \"E\" <signedNumber>  No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.  When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.  Before serializing, Quantity will be put in \"canonical form\". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that: a. No precision is lost b. No fractional digits will be emitted c. The exponent (or suffix) is as large as possible. The sign will be omitted unless the number is negative.  Examples: 1.5 will be serialized as \"1500m\" 1.5Gi will be serialized as \"1536Mi\"  Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.  Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)  This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.  +protobuf=true +protobuf.embed=string +protobuf.options.marshal=false +protobuf.options.(gogoproto.goproto_stringer)=false +k8s:deepcopy-gen=true +k8s:openapi-gen=true
    #[serde(rename = "sizeLimit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_limit: Option<crate::types::Object>,

}


impl EmptyDirVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> EmptyDirVolumeSource {
        EmptyDirVolumeSource {
            medium: None,
            size_limit: None,
        }
    }
}

/// Converts the EmptyDirVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EmptyDirVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.medium.as_ref().map(|medium| {
                [
                    "medium".to_string(),
                    medium.to_string(),
                ].join(",")
            }),

            // Skipping sizeLimit in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EmptyDirVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EmptyDirVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub medium: Vec<String>,
            pub size_limit: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EmptyDirVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "medium" => intermediate_rep.medium.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sizeLimit" => intermediate_rep.size_limit.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EmptyDirVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EmptyDirVolumeSource {
            medium: intermediate_rep.medium.into_iter().next(),
            size_limit: intermediate_rep.size_limit.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EmptyDirVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EmptyDirVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EmptyDirVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for EmptyDirVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EmptyDirVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EmptyDirVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into EmptyDirVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// EndpointIPAMConfig represents IPAM configurations for the endpoint



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EndpointIpamConfig {
    #[serde(rename = "IPv4Address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipv4_address: Option<String>,

    #[serde(rename = "IPv6Address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipv6_address: Option<String>,

    #[serde(rename = "LinkLocalIPs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link_local_ips: Option<Vec<String>>,

}


impl EndpointIpamConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> EndpointIpamConfig {
        EndpointIpamConfig {
            ipv4_address: None,
            ipv6_address: None,
            link_local_ips: None,
        }
    }
}

/// Converts the EndpointIpamConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EndpointIpamConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.ipv4_address.as_ref().map(|ipv4_address| {
                [
                    "IPv4Address".to_string(),
                    ipv4_address.to_string(),
                ].join(",")
            }),


            self.ipv6_address.as_ref().map(|ipv6_address| {
                [
                    "IPv6Address".to_string(),
                    ipv6_address.to_string(),
                ].join(",")
            }),


            self.link_local_ips.as_ref().map(|link_local_ips| {
                [
                    "LinkLocalIPs".to_string(),
                    link_local_ips.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EndpointIpamConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EndpointIpamConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ipv4_address: Vec<String>,
            pub ipv6_address: Vec<String>,
            pub link_local_ips: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EndpointIpamConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "IPv4Address" => intermediate_rep.ipv4_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPv6Address" => intermediate_rep.ipv6_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "LinkLocalIPs" => return std::result::Result::Err("Parsing a container in this style is not supported in EndpointIpamConfig".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing EndpointIpamConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EndpointIpamConfig {
            ipv4_address: intermediate_rep.ipv4_address.into_iter().next(),
            ipv6_address: intermediate_rep.ipv6_address.into_iter().next(),
            link_local_ips: intermediate_rep.link_local_ips.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EndpointIpamConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EndpointIpamConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EndpointIpamConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for EndpointIpamConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EndpointIpamConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EndpointIpamConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into EndpointIpamConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// EndpointSettings stores the network endpoint details



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EndpointSettings {
    #[serde(rename = "Aliases")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub aliases: Option<Vec<String>>,

    #[serde(rename = "DriverOpts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver_opts: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "EndpointID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub endpoint_id: Option<String>,

    #[serde(rename = "Gateway")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gateway: Option<String>,

    #[serde(rename = "GlobalIPv6Address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub global_ipv6_address: Option<String>,

    #[serde(rename = "GlobalIPv6PrefixLen")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub global_ipv6_prefix_len: Option<i64>,

    #[serde(rename = "IPAMConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipam_config: Option<models::EndpointIpamConfig>,

    #[serde(rename = "IPAddress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ip_address: Option<String>,

    #[serde(rename = "IPPrefixLen")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ip_prefix_len: Option<i64>,

    #[serde(rename = "IPv6Gateway")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipv6_gateway: Option<String>,

    #[serde(rename = "Links")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub links: Option<Vec<String>>,

    #[serde(rename = "MacAddress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mac_address: Option<String>,

/// Operational data
    #[serde(rename = "NetworkID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_id: Option<String>,

}


impl EndpointSettings {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> EndpointSettings {
        EndpointSettings {
            aliases: None,
            driver_opts: None,
            endpoint_id: None,
            gateway: None,
            global_ipv6_address: None,
            global_ipv6_prefix_len: None,
            ipam_config: None,
            ip_address: None,
            ip_prefix_len: None,
            ipv6_gateway: None,
            links: None,
            mac_address: None,
            network_id: None,
        }
    }
}

/// Converts the EndpointSettings value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EndpointSettings {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.aliases.as_ref().map(|aliases| {
                [
                    "Aliases".to_string(),
                    aliases.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping DriverOpts in query parameter serialization


            self.endpoint_id.as_ref().map(|endpoint_id| {
                [
                    "EndpointID".to_string(),
                    endpoint_id.to_string(),
                ].join(",")
            }),


            self.gateway.as_ref().map(|gateway| {
                [
                    "Gateway".to_string(),
                    gateway.to_string(),
                ].join(",")
            }),


            self.global_ipv6_address.as_ref().map(|global_ipv6_address| {
                [
                    "GlobalIPv6Address".to_string(),
                    global_ipv6_address.to_string(),
                ].join(",")
            }),


            self.global_ipv6_prefix_len.as_ref().map(|global_ipv6_prefix_len| {
                [
                    "GlobalIPv6PrefixLen".to_string(),
                    global_ipv6_prefix_len.to_string(),
                ].join(",")
            }),

            // Skipping IPAMConfig in query parameter serialization


            self.ip_address.as_ref().map(|ip_address| {
                [
                    "IPAddress".to_string(),
                    ip_address.to_string(),
                ].join(",")
            }),


            self.ip_prefix_len.as_ref().map(|ip_prefix_len| {
                [
                    "IPPrefixLen".to_string(),
                    ip_prefix_len.to_string(),
                ].join(",")
            }),


            self.ipv6_gateway.as_ref().map(|ipv6_gateway| {
                [
                    "IPv6Gateway".to_string(),
                    ipv6_gateway.to_string(),
                ].join(",")
            }),


            self.links.as_ref().map(|links| {
                [
                    "Links".to_string(),
                    links.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.mac_address.as_ref().map(|mac_address| {
                [
                    "MacAddress".to_string(),
                    mac_address.to_string(),
                ].join(",")
            }),


            self.network_id.as_ref().map(|network_id| {
                [
                    "NetworkID".to_string(),
                    network_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EndpointSettings value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EndpointSettings {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub aliases: Vec<Vec<String>>,
            pub driver_opts: Vec<std::collections::HashMap<String, String>>,
            pub endpoint_id: Vec<String>,
            pub gateway: Vec<String>,
            pub global_ipv6_address: Vec<String>,
            pub global_ipv6_prefix_len: Vec<i64>,
            pub ipam_config: Vec<models::EndpointIpamConfig>,
            pub ip_address: Vec<String>,
            pub ip_prefix_len: Vec<i64>,
            pub ipv6_gateway: Vec<String>,
            pub links: Vec<Vec<String>>,
            pub mac_address: Vec<String>,
            pub network_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EndpointSettings".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Aliases" => return std::result::Result::Err("Parsing a container in this style is not supported in EndpointSettings".to_string()),
                    "DriverOpts" => return std::result::Result::Err("Parsing a container in this style is not supported in EndpointSettings".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "EndpointID" => intermediate_rep.endpoint_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Gateway" => intermediate_rep.gateway.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "GlobalIPv6Address" => intermediate_rep.global_ipv6_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "GlobalIPv6PrefixLen" => intermediate_rep.global_ipv6_prefix_len.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPAMConfig" => intermediate_rep.ipam_config.push(<models::EndpointIpamConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPAddress" => intermediate_rep.ip_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPPrefixLen" => intermediate_rep.ip_prefix_len.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPv6Gateway" => intermediate_rep.ipv6_gateway.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Links" => return std::result::Result::Err("Parsing a container in this style is not supported in EndpointSettings".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "MacAddress" => intermediate_rep.mac_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NetworkID" => intermediate_rep.network_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EndpointSettings".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EndpointSettings {
            aliases: intermediate_rep.aliases.into_iter().next(),
            driver_opts: intermediate_rep.driver_opts.into_iter().next(),
            endpoint_id: intermediate_rep.endpoint_id.into_iter().next(),
            gateway: intermediate_rep.gateway.into_iter().next(),
            global_ipv6_address: intermediate_rep.global_ipv6_address.into_iter().next(),
            global_ipv6_prefix_len: intermediate_rep.global_ipv6_prefix_len.into_iter().next(),
            ipam_config: intermediate_rep.ipam_config.into_iter().next(),
            ip_address: intermediate_rep.ip_address.into_iter().next(),
            ip_prefix_len: intermediate_rep.ip_prefix_len.into_iter().next(),
            ipv6_gateway: intermediate_rep.ipv6_gateway.into_iter().next(),
            links: intermediate_rep.links.into_iter().next(),
            mac_address: intermediate_rep.mac_address.into_iter().next(),
            network_id: intermediate_rep.network_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EndpointSettings> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EndpointSettings>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EndpointSettings>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for EndpointSettings - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EndpointSettings> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EndpointSettings as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into EndpointSettings - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// EnvFromSource represents the source of a set of ConfigMaps



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EnvFromSource {
    #[serde(rename = "configMapRef")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub config_map_ref: Option<models::ConfigMapEnvSource>,

/// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER. +optional
    #[serde(rename = "prefix")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub prefix: Option<String>,

    #[serde(rename = "secretRef")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_ref: Option<models::SecretEnvSource>,

}


impl EnvFromSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> EnvFromSource {
        EnvFromSource {
            config_map_ref: None,
            prefix: None,
            secret_ref: None,
        }
    }
}

/// Converts the EnvFromSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EnvFromSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping configMapRef in query parameter serialization


            self.prefix.as_ref().map(|prefix| {
                [
                    "prefix".to_string(),
                    prefix.to_string(),
                ].join(",")
            }),

            // Skipping secretRef in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EnvFromSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EnvFromSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub config_map_ref: Vec<models::ConfigMapEnvSource>,
            pub prefix: Vec<String>,
            pub secret_ref: Vec<models::SecretEnvSource>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EnvFromSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "configMapRef" => intermediate_rep.config_map_ref.push(<models::ConfigMapEnvSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "prefix" => intermediate_rep.prefix.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "secretRef" => intermediate_rep.secret_ref.push(<models::SecretEnvSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EnvFromSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EnvFromSource {
            config_map_ref: intermediate_rep.config_map_ref.into_iter().next(),
            prefix: intermediate_rep.prefix.into_iter().next(),
            secret_ref: intermediate_rep.secret_ref.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EnvFromSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EnvFromSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EnvFromSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for EnvFromSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EnvFromSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EnvFromSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into EnvFromSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EnvVar {
/// Name of the environment variable. Must be a C_IDENTIFIER.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to \"\". +optional
    #[serde(rename = "value")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,

    #[serde(rename = "valueFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub value_from: Option<models::EnvVarSource>,

}


impl EnvVar {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> EnvVar {
        EnvVar {
            name: None,
            value: None,
            value_from: None,
        }
    }
}

/// Converts the EnvVar value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EnvVar {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.value.as_ref().map(|value| {
                [
                    "value".to_string(),
                    value.to_string(),
                ].join(",")
            }),

            // Skipping valueFrom in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EnvVar value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EnvVar {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub value: Vec<String>,
            pub value_from: Vec<models::EnvVarSource>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EnvVar".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "valueFrom" => intermediate_rep.value_from.push(<models::EnvVarSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EnvVar".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EnvVar {
            name: intermediate_rep.name.into_iter().next(),
            value: intermediate_rep.value.into_iter().next(),
            value_from: intermediate_rep.value_from.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EnvVar> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EnvVar>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EnvVar>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for EnvVar - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EnvVar> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EnvVar as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into EnvVar - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EnvVarSource {
    #[serde(rename = "configMapKeyRef")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub config_map_key_ref: Option<models::ConfigMapKeySelector>,

    #[serde(rename = "fieldRef")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub field_ref: Option<models::ObjectFieldSelector>,

    #[serde(rename = "resourceFieldRef")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resource_field_ref: Option<models::ResourceFieldSelector>,

    #[serde(rename = "secretKeyRef")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_key_ref: Option<models::SecretKeySelector>,

}


impl EnvVarSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> EnvVarSource {
        EnvVarSource {
            config_map_key_ref: None,
            field_ref: None,
            resource_field_ref: None,
            secret_key_ref: None,
        }
    }
}

/// Converts the EnvVarSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EnvVarSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping configMapKeyRef in query parameter serialization

            // Skipping fieldRef in query parameter serialization

            // Skipping resourceFieldRef in query parameter serialization

            // Skipping secretKeyRef in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EnvVarSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EnvVarSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub config_map_key_ref: Vec<models::ConfigMapKeySelector>,
            pub field_ref: Vec<models::ObjectFieldSelector>,
            pub resource_field_ref: Vec<models::ResourceFieldSelector>,
            pub secret_key_ref: Vec<models::SecretKeySelector>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EnvVarSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "configMapKeyRef" => intermediate_rep.config_map_key_ref.push(<models::ConfigMapKeySelector as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fieldRef" => intermediate_rep.field_ref.push(<models::ObjectFieldSelector as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "resourceFieldRef" => intermediate_rep.resource_field_ref.push(<models::ResourceFieldSelector as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "secretKeyRef" => intermediate_rep.secret_key_ref.push(<models::SecretKeySelector as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EnvVarSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EnvVarSource {
            config_map_key_ref: intermediate_rep.config_map_key_ref.into_iter().next(),
            field_ref: intermediate_rep.field_ref.into_iter().next(),
            resource_field_ref: intermediate_rep.resource_field_ref.into_iter().next(),
            secret_key_ref: intermediate_rep.secret_key_ref.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EnvVarSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EnvVarSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EnvVarSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for EnvVarSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EnvVarSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EnvVarSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into EnvVarSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// To add an ephemeral container, use the ephemeralcontainers subresource of an existing Pod. Ephemeral containers may not be removed or restarted.  This is a beta feature available on clusters that haven't disabled the EphemeralContainers feature gate.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EphemeralContainer {
/// Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell +optional
    #[serde(rename = "args")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub args: Option<Vec<String>>,

/// Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell +optional
    #[serde(rename = "command")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub command: Option<Vec<String>>,

/// List of environment variables to set in the container. Cannot be updated. +optional +patchMergeKey=name +patchStrategy=merge
    #[serde(rename = "env")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub env: Option<Vec<models::EnvVar>>,

/// List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated. +optional
    #[serde(rename = "envFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub env_from: Option<Vec<models::EnvFromSource>>,

/// Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images
    #[serde(rename = "image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image: Option<String>,

/// PullPolicy describes a policy for if/when to pull a container image +enum
    #[serde(rename = "imagePullPolicy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_pull_policy: Option<String>,

    #[serde(rename = "lifecycle")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lifecycle: Option<models::Lifecycle>,

    #[serde(rename = "livenessProbe")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub liveness_probe: Option<models::Probe>,

/// Name of the ephemeral container specified as a DNS_LABEL. This name must be unique among all containers, init containers and ephemeral containers.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Ports are not allowed for ephemeral containers. +optional +patchMergeKey=containerPort +patchStrategy=merge +listType=map +listMapKey=containerPort +listMapKey=protocol
    #[serde(rename = "ports")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ports: Option<Vec<models::ContainerPort>>,

    #[serde(rename = "readinessProbe")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub readiness_probe: Option<models::Probe>,

    #[serde(rename = "resources")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resources: Option<models::ResourceRequirements>,

    #[serde(rename = "securityContext")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_context: Option<models::SecurityContext>,

    #[serde(rename = "startupProbe")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub startup_probe: Option<models::Probe>,

/// Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false. +optional
    #[serde(rename = "stdin")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stdin: Option<bool>,

/// Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false +optional
    #[serde(rename = "stdinOnce")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stdin_once: Option<bool>,

/// If set, the name of the container from PodSpec that this ephemeral container targets. The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container. If not set then the ephemeral container uses the namespaces configured in the Pod spec.  The container runtime must implement support for this feature. If the runtime does not support namespace targeting then the result of setting this field is undefined. +optional
    #[serde(rename = "targetContainerName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_container_name: Option<String>,

/// Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated. +optional
    #[serde(rename = "terminationMessagePath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub termination_message_path: Option<String>,

/// +enum
    #[serde(rename = "terminationMessagePolicy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub termination_message_policy: Option<String>,

/// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false. +optional
    #[serde(rename = "tty")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tty: Option<bool>,

/// volumeDevices is the list of block devices to be used by the container. +patchMergeKey=devicePath +patchStrategy=merge +optional
    #[serde(rename = "volumeDevices")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_devices: Option<Vec<models::VolumeDevice>>,

/// Pod volumes to mount into the container's filesystem. Subpath mounts are not allowed for ephemeral containers. Cannot be updated. +optional +patchMergeKey=mountPath +patchStrategy=merge
    #[serde(rename = "volumeMounts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_mounts: Option<Vec<models::VolumeMount>>,

/// Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated. +optional
    #[serde(rename = "workingDir")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub working_dir: Option<String>,

}


impl EphemeralContainer {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> EphemeralContainer {
        EphemeralContainer {
            args: None,
            command: None,
            env: None,
            env_from: None,
            image: None,
            image_pull_policy: None,
            lifecycle: None,
            liveness_probe: None,
            name: None,
            ports: None,
            readiness_probe: None,
            resources: None,
            security_context: None,
            startup_probe: None,
            stdin: None,
            stdin_once: None,
            target_container_name: None,
            termination_message_path: None,
            termination_message_policy: None,
            tty: None,
            volume_devices: None,
            volume_mounts: None,
            working_dir: None,
        }
    }
}

/// Converts the EphemeralContainer value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EphemeralContainer {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.args.as_ref().map(|args| {
                [
                    "args".to_string(),
                    args.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.command.as_ref().map(|command| {
                [
                    "command".to_string(),
                    command.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping env in query parameter serialization

            // Skipping envFrom in query parameter serialization


            self.image.as_ref().map(|image| {
                [
                    "image".to_string(),
                    image.to_string(),
                ].join(",")
            }),


            self.image_pull_policy.as_ref().map(|image_pull_policy| {
                [
                    "imagePullPolicy".to_string(),
                    image_pull_policy.to_string(),
                ].join(",")
            }),

            // Skipping lifecycle in query parameter serialization

            // Skipping livenessProbe in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping ports in query parameter serialization

            // Skipping readinessProbe in query parameter serialization

            // Skipping resources in query parameter serialization

            // Skipping securityContext in query parameter serialization

            // Skipping startupProbe in query parameter serialization


            self.stdin.as_ref().map(|stdin| {
                [
                    "stdin".to_string(),
                    stdin.to_string(),
                ].join(",")
            }),


            self.stdin_once.as_ref().map(|stdin_once| {
                [
                    "stdinOnce".to_string(),
                    stdin_once.to_string(),
                ].join(",")
            }),


            self.target_container_name.as_ref().map(|target_container_name| {
                [
                    "targetContainerName".to_string(),
                    target_container_name.to_string(),
                ].join(",")
            }),


            self.termination_message_path.as_ref().map(|termination_message_path| {
                [
                    "terminationMessagePath".to_string(),
                    termination_message_path.to_string(),
                ].join(",")
            }),


            self.termination_message_policy.as_ref().map(|termination_message_policy| {
                [
                    "terminationMessagePolicy".to_string(),
                    termination_message_policy.to_string(),
                ].join(",")
            }),


            self.tty.as_ref().map(|tty| {
                [
                    "tty".to_string(),
                    tty.to_string(),
                ].join(",")
            }),

            // Skipping volumeDevices in query parameter serialization

            // Skipping volumeMounts in query parameter serialization


            self.working_dir.as_ref().map(|working_dir| {
                [
                    "workingDir".to_string(),
                    working_dir.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EphemeralContainer value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EphemeralContainer {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub args: Vec<Vec<String>>,
            pub command: Vec<Vec<String>>,
            pub env: Vec<Vec<models::EnvVar>>,
            pub env_from: Vec<Vec<models::EnvFromSource>>,
            pub image: Vec<String>,
            pub image_pull_policy: Vec<String>,
            pub lifecycle: Vec<models::Lifecycle>,
            pub liveness_probe: Vec<models::Probe>,
            pub name: Vec<String>,
            pub ports: Vec<Vec<models::ContainerPort>>,
            pub readiness_probe: Vec<models::Probe>,
            pub resources: Vec<models::ResourceRequirements>,
            pub security_context: Vec<models::SecurityContext>,
            pub startup_probe: Vec<models::Probe>,
            pub stdin: Vec<bool>,
            pub stdin_once: Vec<bool>,
            pub target_container_name: Vec<String>,
            pub termination_message_path: Vec<String>,
            pub termination_message_policy: Vec<String>,
            pub tty: Vec<bool>,
            pub volume_devices: Vec<Vec<models::VolumeDevice>>,
            pub volume_mounts: Vec<Vec<models::VolumeMount>>,
            pub working_dir: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EphemeralContainer".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "args" => return std::result::Result::Err("Parsing a container in this style is not supported in EphemeralContainer".to_string()),
                    "command" => return std::result::Result::Err("Parsing a container in this style is not supported in EphemeralContainer".to_string()),
                    "env" => return std::result::Result::Err("Parsing a container in this style is not supported in EphemeralContainer".to_string()),
                    "envFrom" => return std::result::Result::Err("Parsing a container in this style is not supported in EphemeralContainer".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "image" => intermediate_rep.image.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "imagePullPolicy" => intermediate_rep.image_pull_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lifecycle" => intermediate_rep.lifecycle.push(<models::Lifecycle as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "livenessProbe" => intermediate_rep.liveness_probe.push(<models::Probe as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ports" => return std::result::Result::Err("Parsing a container in this style is not supported in EphemeralContainer".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "readinessProbe" => intermediate_rep.readiness_probe.push(<models::Probe as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "resources" => intermediate_rep.resources.push(<models::ResourceRequirements as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "securityContext" => intermediate_rep.security_context.push(<models::SecurityContext as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "startupProbe" => intermediate_rep.startup_probe.push(<models::Probe as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stdin" => intermediate_rep.stdin.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stdinOnce" => intermediate_rep.stdin_once.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "targetContainerName" => intermediate_rep.target_container_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "terminationMessagePath" => intermediate_rep.termination_message_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "terminationMessagePolicy" => intermediate_rep.termination_message_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tty" => intermediate_rep.tty.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "volumeDevices" => return std::result::Result::Err("Parsing a container in this style is not supported in EphemeralContainer".to_string()),
                    "volumeMounts" => return std::result::Result::Err("Parsing a container in this style is not supported in EphemeralContainer".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "workingDir" => intermediate_rep.working_dir.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EphemeralContainer".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EphemeralContainer {
            args: intermediate_rep.args.into_iter().next(),
            command: intermediate_rep.command.into_iter().next(),
            env: intermediate_rep.env.into_iter().next(),
            env_from: intermediate_rep.env_from.into_iter().next(),
            image: intermediate_rep.image.into_iter().next(),
            image_pull_policy: intermediate_rep.image_pull_policy.into_iter().next(),
            lifecycle: intermediate_rep.lifecycle.into_iter().next(),
            liveness_probe: intermediate_rep.liveness_probe.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            ports: intermediate_rep.ports.into_iter().next(),
            readiness_probe: intermediate_rep.readiness_probe.into_iter().next(),
            resources: intermediate_rep.resources.into_iter().next(),
            security_context: intermediate_rep.security_context.into_iter().next(),
            startup_probe: intermediate_rep.startup_probe.into_iter().next(),
            stdin: intermediate_rep.stdin.into_iter().next(),
            stdin_once: intermediate_rep.stdin_once.into_iter().next(),
            target_container_name: intermediate_rep.target_container_name.into_iter().next(),
            termination_message_path: intermediate_rep.termination_message_path.into_iter().next(),
            termination_message_policy: intermediate_rep.termination_message_policy.into_iter().next(),
            tty: intermediate_rep.tty.into_iter().next(),
            volume_devices: intermediate_rep.volume_devices.into_iter().next(),
            volume_mounts: intermediate_rep.volume_mounts.into_iter().next(),
            working_dir: intermediate_rep.working_dir.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EphemeralContainer> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EphemeralContainer>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EphemeralContainer>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for EphemeralContainer - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EphemeralContainer> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EphemeralContainer as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into EphemeralContainer - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// EphemeralContainerCommon is a copy of all fields in Container to be inlined in EphemeralContainer. This separate type allows easy conversion from EphemeralContainer to Container and allows separate documentation for the fields of EphemeralContainer. When a new field is added to Container it must be added here as well.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EphemeralContainerCommon {
/// Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell +optional
    #[serde(rename = "args")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub args: Option<Vec<String>>,

/// Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell +optional
    #[serde(rename = "command")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub command: Option<Vec<String>>,

/// List of environment variables to set in the container. Cannot be updated. +optional +patchMergeKey=name +patchStrategy=merge
    #[serde(rename = "env")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub env: Option<Vec<models::EnvVar>>,

/// List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated. +optional
    #[serde(rename = "envFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub env_from: Option<Vec<models::EnvFromSource>>,

/// Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images
    #[serde(rename = "image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image: Option<String>,

/// PullPolicy describes a policy for if/when to pull a container image +enum
    #[serde(rename = "imagePullPolicy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_pull_policy: Option<String>,

    #[serde(rename = "lifecycle")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lifecycle: Option<models::Lifecycle>,

    #[serde(rename = "livenessProbe")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub liveness_probe: Option<models::Probe>,

/// Name of the ephemeral container specified as a DNS_LABEL. This name must be unique among all containers, init containers and ephemeral containers.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Ports are not allowed for ephemeral containers. +optional +patchMergeKey=containerPort +patchStrategy=merge +listType=map +listMapKey=containerPort +listMapKey=protocol
    #[serde(rename = "ports")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ports: Option<Vec<models::ContainerPort>>,

    #[serde(rename = "readinessProbe")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub readiness_probe: Option<models::Probe>,

    #[serde(rename = "resources")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resources: Option<models::ResourceRequirements>,

    #[serde(rename = "securityContext")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_context: Option<models::SecurityContext>,

    #[serde(rename = "startupProbe")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub startup_probe: Option<models::Probe>,

/// Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false. +optional
    #[serde(rename = "stdin")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stdin: Option<bool>,

/// Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false +optional
    #[serde(rename = "stdinOnce")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stdin_once: Option<bool>,

/// Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated. +optional
    #[serde(rename = "terminationMessagePath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub termination_message_path: Option<String>,

/// +enum
    #[serde(rename = "terminationMessagePolicy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub termination_message_policy: Option<String>,

/// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false. +optional
    #[serde(rename = "tty")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tty: Option<bool>,

/// volumeDevices is the list of block devices to be used by the container. +patchMergeKey=devicePath +patchStrategy=merge +optional
    #[serde(rename = "volumeDevices")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_devices: Option<Vec<models::VolumeDevice>>,

/// Pod volumes to mount into the container's filesystem. Subpath mounts are not allowed for ephemeral containers. Cannot be updated. +optional +patchMergeKey=mountPath +patchStrategy=merge
    #[serde(rename = "volumeMounts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_mounts: Option<Vec<models::VolumeMount>>,

/// Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated. +optional
    #[serde(rename = "workingDir")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub working_dir: Option<String>,

}


impl EphemeralContainerCommon {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> EphemeralContainerCommon {
        EphemeralContainerCommon {
            args: None,
            command: None,
            env: None,
            env_from: None,
            image: None,
            image_pull_policy: None,
            lifecycle: None,
            liveness_probe: None,
            name: None,
            ports: None,
            readiness_probe: None,
            resources: None,
            security_context: None,
            startup_probe: None,
            stdin: None,
            stdin_once: None,
            termination_message_path: None,
            termination_message_policy: None,
            tty: None,
            volume_devices: None,
            volume_mounts: None,
            working_dir: None,
        }
    }
}

/// Converts the EphemeralContainerCommon value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EphemeralContainerCommon {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.args.as_ref().map(|args| {
                [
                    "args".to_string(),
                    args.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.command.as_ref().map(|command| {
                [
                    "command".to_string(),
                    command.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping env in query parameter serialization

            // Skipping envFrom in query parameter serialization


            self.image.as_ref().map(|image| {
                [
                    "image".to_string(),
                    image.to_string(),
                ].join(",")
            }),


            self.image_pull_policy.as_ref().map(|image_pull_policy| {
                [
                    "imagePullPolicy".to_string(),
                    image_pull_policy.to_string(),
                ].join(",")
            }),

            // Skipping lifecycle in query parameter serialization

            // Skipping livenessProbe in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping ports in query parameter serialization

            // Skipping readinessProbe in query parameter serialization

            // Skipping resources in query parameter serialization

            // Skipping securityContext in query parameter serialization

            // Skipping startupProbe in query parameter serialization


            self.stdin.as_ref().map(|stdin| {
                [
                    "stdin".to_string(),
                    stdin.to_string(),
                ].join(",")
            }),


            self.stdin_once.as_ref().map(|stdin_once| {
                [
                    "stdinOnce".to_string(),
                    stdin_once.to_string(),
                ].join(",")
            }),


            self.termination_message_path.as_ref().map(|termination_message_path| {
                [
                    "terminationMessagePath".to_string(),
                    termination_message_path.to_string(),
                ].join(",")
            }),


            self.termination_message_policy.as_ref().map(|termination_message_policy| {
                [
                    "terminationMessagePolicy".to_string(),
                    termination_message_policy.to_string(),
                ].join(",")
            }),


            self.tty.as_ref().map(|tty| {
                [
                    "tty".to_string(),
                    tty.to_string(),
                ].join(",")
            }),

            // Skipping volumeDevices in query parameter serialization

            // Skipping volumeMounts in query parameter serialization


            self.working_dir.as_ref().map(|working_dir| {
                [
                    "workingDir".to_string(),
                    working_dir.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EphemeralContainerCommon value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EphemeralContainerCommon {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub args: Vec<Vec<String>>,
            pub command: Vec<Vec<String>>,
            pub env: Vec<Vec<models::EnvVar>>,
            pub env_from: Vec<Vec<models::EnvFromSource>>,
            pub image: Vec<String>,
            pub image_pull_policy: Vec<String>,
            pub lifecycle: Vec<models::Lifecycle>,
            pub liveness_probe: Vec<models::Probe>,
            pub name: Vec<String>,
            pub ports: Vec<Vec<models::ContainerPort>>,
            pub readiness_probe: Vec<models::Probe>,
            pub resources: Vec<models::ResourceRequirements>,
            pub security_context: Vec<models::SecurityContext>,
            pub startup_probe: Vec<models::Probe>,
            pub stdin: Vec<bool>,
            pub stdin_once: Vec<bool>,
            pub termination_message_path: Vec<String>,
            pub termination_message_policy: Vec<String>,
            pub tty: Vec<bool>,
            pub volume_devices: Vec<Vec<models::VolumeDevice>>,
            pub volume_mounts: Vec<Vec<models::VolumeMount>>,
            pub working_dir: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EphemeralContainerCommon".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "args" => return std::result::Result::Err("Parsing a container in this style is not supported in EphemeralContainerCommon".to_string()),
                    "command" => return std::result::Result::Err("Parsing a container in this style is not supported in EphemeralContainerCommon".to_string()),
                    "env" => return std::result::Result::Err("Parsing a container in this style is not supported in EphemeralContainerCommon".to_string()),
                    "envFrom" => return std::result::Result::Err("Parsing a container in this style is not supported in EphemeralContainerCommon".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "image" => intermediate_rep.image.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "imagePullPolicy" => intermediate_rep.image_pull_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lifecycle" => intermediate_rep.lifecycle.push(<models::Lifecycle as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "livenessProbe" => intermediate_rep.liveness_probe.push(<models::Probe as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ports" => return std::result::Result::Err("Parsing a container in this style is not supported in EphemeralContainerCommon".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "readinessProbe" => intermediate_rep.readiness_probe.push(<models::Probe as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "resources" => intermediate_rep.resources.push(<models::ResourceRequirements as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "securityContext" => intermediate_rep.security_context.push(<models::SecurityContext as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "startupProbe" => intermediate_rep.startup_probe.push(<models::Probe as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stdin" => intermediate_rep.stdin.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stdinOnce" => intermediate_rep.stdin_once.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "terminationMessagePath" => intermediate_rep.termination_message_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "terminationMessagePolicy" => intermediate_rep.termination_message_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tty" => intermediate_rep.tty.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "volumeDevices" => return std::result::Result::Err("Parsing a container in this style is not supported in EphemeralContainerCommon".to_string()),
                    "volumeMounts" => return std::result::Result::Err("Parsing a container in this style is not supported in EphemeralContainerCommon".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "workingDir" => intermediate_rep.working_dir.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EphemeralContainerCommon".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EphemeralContainerCommon {
            args: intermediate_rep.args.into_iter().next(),
            command: intermediate_rep.command.into_iter().next(),
            env: intermediate_rep.env.into_iter().next(),
            env_from: intermediate_rep.env_from.into_iter().next(),
            image: intermediate_rep.image.into_iter().next(),
            image_pull_policy: intermediate_rep.image_pull_policy.into_iter().next(),
            lifecycle: intermediate_rep.lifecycle.into_iter().next(),
            liveness_probe: intermediate_rep.liveness_probe.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            ports: intermediate_rep.ports.into_iter().next(),
            readiness_probe: intermediate_rep.readiness_probe.into_iter().next(),
            resources: intermediate_rep.resources.into_iter().next(),
            security_context: intermediate_rep.security_context.into_iter().next(),
            startup_probe: intermediate_rep.startup_probe.into_iter().next(),
            stdin: intermediate_rep.stdin.into_iter().next(),
            stdin_once: intermediate_rep.stdin_once.into_iter().next(),
            termination_message_path: intermediate_rep.termination_message_path.into_iter().next(),
            termination_message_policy: intermediate_rep.termination_message_policy.into_iter().next(),
            tty: intermediate_rep.tty.into_iter().next(),
            volume_devices: intermediate_rep.volume_devices.into_iter().next(),
            volume_mounts: intermediate_rep.volume_mounts.into_iter().next(),
            working_dir: intermediate_rep.working_dir.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EphemeralContainerCommon> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EphemeralContainerCommon>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EphemeralContainerCommon>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for EphemeralContainerCommon - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EphemeralContainerCommon> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EphemeralContainerCommon as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into EphemeralContainerCommon - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EphemeralVolumeSource {
    #[serde(rename = "volumeClaimTemplate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_claim_template: Option<models::PersistentVolumeClaimTemplate>,

}


impl EphemeralVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> EphemeralVolumeSource {
        EphemeralVolumeSource {
            volume_claim_template: None,
        }
    }
}

/// Converts the EphemeralVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EphemeralVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping volumeClaimTemplate in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EphemeralVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EphemeralVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub volume_claim_template: Vec<models::PersistentVolumeClaimTemplate>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EphemeralVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "volumeClaimTemplate" => intermediate_rep.volume_claim_template.push(<models::PersistentVolumeClaimTemplate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EphemeralVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EphemeralVolumeSource {
            volume_claim_template: intermediate_rep.volume_claim_template.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EphemeralVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EphemeralVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EphemeralVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for EphemeralVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EphemeralVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EphemeralVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into EphemeralVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ErrorResponse {
/// The error message.
    #[serde(rename = "message")]
    pub message: String,

}


impl ErrorResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(message: String, ) -> ErrorResponse {
        ErrorResponse {
            message,
        }
    }
}

/// Converts the ErrorResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ErrorResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("message".to_string()),
            Some(self.message.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ErrorResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ErrorResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ErrorResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ErrorResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ErrorResponse {
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in ErrorResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ErrorResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ErrorResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ErrorResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ErrorResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ErrorResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ErrorResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ErrorResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ExecAction {
/// Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. +optional
    #[serde(rename = "command")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub command: Option<Vec<String>>,

}


impl ExecAction {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ExecAction {
        ExecAction {
            command: None,
        }
    }
}

/// Converts the ExecAction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ExecAction {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.command.as_ref().map(|command| {
                [
                    "command".to_string(),
                    command.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ExecAction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ExecAction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub command: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ExecAction".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "command" => return std::result::Result::Err("Parsing a container in this style is not supported in ExecAction".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ExecAction".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ExecAction {
            command: intermediate_rep.command.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ExecAction> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ExecAction>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ExecAction>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ExecAction - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ExecAction> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ExecAction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ExecAction - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Fibre Channel volumes can only be mounted as read/write once. Fibre Channel volumes support ownership management and SELinux relabeling.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FcVolumeSource {
/// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine +optional
    #[serde(rename = "fsType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fs_type: Option<String>,

/// Optional: FC target lun number +optional
    #[serde(rename = "lun")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lun: Option<i32>,

/// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. +optional
    #[serde(rename = "readOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

/// Optional: FC target worldwide names (WWNs) +optional
    #[serde(rename = "targetWWNs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_wwns: Option<Vec<String>>,

/// Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously. +optional
    #[serde(rename = "wwids")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub wwids: Option<Vec<String>>,

}


impl FcVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> FcVolumeSource {
        FcVolumeSource {
            fs_type: None,
            lun: None,
            read_only: None,
            target_wwns: None,
            wwids: None,
        }
    }
}

/// Converts the FcVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FcVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.fs_type.as_ref().map(|fs_type| {
                [
                    "fsType".to_string(),
                    fs_type.to_string(),
                ].join(",")
            }),


            self.lun.as_ref().map(|lun| {
                [
                    "lun".to_string(),
                    lun.to_string(),
                ].join(",")
            }),


            self.read_only.as_ref().map(|read_only| {
                [
                    "readOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),


            self.target_wwns.as_ref().map(|target_wwns| {
                [
                    "targetWWNs".to_string(),
                    target_wwns.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.wwids.as_ref().map(|wwids| {
                [
                    "wwids".to_string(),
                    wwids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FcVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FcVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub fs_type: Vec<String>,
            pub lun: Vec<i32>,
            pub read_only: Vec<bool>,
            pub target_wwns: Vec<Vec<String>>,
            pub wwids: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FcVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "fsType" => intermediate_rep.fs_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lun" => intermediate_rep.lun.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "readOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "targetWWNs" => return std::result::Result::Err("Parsing a container in this style is not supported in FcVolumeSource".to_string()),
                    "wwids" => return std::result::Result::Err("Parsing a container in this style is not supported in FcVolumeSource".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing FcVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FcVolumeSource {
            fs_type: intermediate_rep.fs_type.into_iter().next(),
            lun: intermediate_rep.lun.into_iter().next(),
            read_only: intermediate_rep.read_only.into_iter().next(),
            target_wwns: intermediate_rep.target_wwns.into_iter().next(),
            wwids: intermediate_rep.wwids.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FcVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FcVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FcVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FcVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FcVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FcVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FcVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The bits have the same definition on all systems, so that information about files can be moved from one system to another portably. Not all bits apply to all systems. The only required bit is ModeDir for directories.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FileMode(i32);

impl validator::Validate for FileMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<i32> for FileMode {
    fn from(x: i32) -> Self {
        FileMode(x)
    }
}

impl std::convert::From<FileMode> for i32 {
    fn from(x: FileMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for FileMode {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for FileMode {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}



/// FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FlexVolumeSource {
/// Driver is the name of the driver to use for this volume.
    #[serde(rename = "driver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver: Option<String>,

/// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". The default filesystem depends on FlexVolume script. +optional
    #[serde(rename = "fsType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fs_type: Option<String>,

/// Optional: Extra command options if any. +optional
    #[serde(rename = "options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<std::collections::HashMap<String, String>>,

/// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. +optional
    #[serde(rename = "readOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

    #[serde(rename = "secretRef")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_ref: Option<models::LocalObjectReference>,

}


impl FlexVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> FlexVolumeSource {
        FlexVolumeSource {
            driver: None,
            fs_type: None,
            options: None,
            read_only: None,
            secret_ref: None,
        }
    }
}

/// Converts the FlexVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FlexVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.driver.as_ref().map(|driver| {
                [
                    "driver".to_string(),
                    driver.to_string(),
                ].join(",")
            }),


            self.fs_type.as_ref().map(|fs_type| {
                [
                    "fsType".to_string(),
                    fs_type.to_string(),
                ].join(",")
            }),

            // Skipping options in query parameter serialization


            self.read_only.as_ref().map(|read_only| {
                [
                    "readOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),

            // Skipping secretRef in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FlexVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FlexVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub driver: Vec<String>,
            pub fs_type: Vec<String>,
            pub options: Vec<std::collections::HashMap<String, String>>,
            pub read_only: Vec<bool>,
            pub secret_ref: Vec<models::LocalObjectReference>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FlexVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "driver" => intermediate_rep.driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fsType" => intermediate_rep.fs_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "options" => return std::result::Result::Err("Parsing a container in this style is not supported in FlexVolumeSource".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "readOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "secretRef" => intermediate_rep.secret_ref.push(<models::LocalObjectReference as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FlexVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FlexVolumeSource {
            driver: intermediate_rep.driver.into_iter().next(),
            fs_type: intermediate_rep.fs_type.into_iter().next(),
            options: intermediate_rep.options.into_iter().next(),
            read_only: intermediate_rep.read_only.into_iter().next(),
            secret_ref: intermediate_rep.secret_ref.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FlexVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FlexVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FlexVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FlexVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FlexVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FlexVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FlexVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// One and only one of datasetName and datasetUUID should be set. Flocker volumes do not support ownership management or SELinux relabeling.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FlockerVolumeSource {
/// Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated +optional
    #[serde(rename = "datasetName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dataset_name: Option<String>,

/// UUID of the dataset. This is unique identifier of a Flocker dataset +optional
    #[serde(rename = "datasetUUID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dataset_uuid: Option<String>,

}


impl FlockerVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> FlockerVolumeSource {
        FlockerVolumeSource {
            dataset_name: None,
            dataset_uuid: None,
        }
    }
}

/// Converts the FlockerVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FlockerVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.dataset_name.as_ref().map(|dataset_name| {
                [
                    "datasetName".to_string(),
                    dataset_name.to_string(),
                ].join(",")
            }),


            self.dataset_uuid.as_ref().map(|dataset_uuid| {
                [
                    "datasetUUID".to_string(),
                    dataset_uuid.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FlockerVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FlockerVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dataset_name: Vec<String>,
            pub dataset_uuid: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FlockerVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "datasetName" => intermediate_rep.dataset_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "datasetUUID" => intermediate_rep.dataset_uuid.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FlockerVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FlockerVolumeSource {
            dataset_name: intermediate_rep.dataset_name.into_iter().next(),
            dataset_uuid: intermediate_rep.dataset_uuid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FlockerVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FlockerVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FlockerVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FlockerVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FlockerVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FlockerVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FlockerVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ForwardingConfig {
    #[serde(rename = "forwardingMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub forwarding_mode: Option<String>,

    #[serde(rename = "reverseForwardingMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reverse_forwarding_mode: Option<String>,

    #[serde(rename = "socketForwardingMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub socket_forwarding_mode: Option<String>,

    #[serde(rename = "socketListenMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub socket_listen_mode: Option<String>,

    #[serde(rename = "x11ForwardingMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub x11_forwarding_mode: Option<String>,

}


impl ForwardingConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ForwardingConfig {
        ForwardingConfig {
            forwarding_mode: None,
            reverse_forwarding_mode: None,
            socket_forwarding_mode: None,
            socket_listen_mode: None,
            x11_forwarding_mode: None,
        }
    }
}

/// Converts the ForwardingConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ForwardingConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.forwarding_mode.as_ref().map(|forwarding_mode| {
                [
                    "forwardingMode".to_string(),
                    forwarding_mode.to_string(),
                ].join(",")
            }),


            self.reverse_forwarding_mode.as_ref().map(|reverse_forwarding_mode| {
                [
                    "reverseForwardingMode".to_string(),
                    reverse_forwarding_mode.to_string(),
                ].join(",")
            }),


            self.socket_forwarding_mode.as_ref().map(|socket_forwarding_mode| {
                [
                    "socketForwardingMode".to_string(),
                    socket_forwarding_mode.to_string(),
                ].join(",")
            }),


            self.socket_listen_mode.as_ref().map(|socket_listen_mode| {
                [
                    "socketListenMode".to_string(),
                    socket_listen_mode.to_string(),
                ].join(",")
            }),


            self.x11_forwarding_mode.as_ref().map(|x11_forwarding_mode| {
                [
                    "x11ForwardingMode".to_string(),
                    x11_forwarding_mode.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ForwardingConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ForwardingConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub forwarding_mode: Vec<String>,
            pub reverse_forwarding_mode: Vec<String>,
            pub socket_forwarding_mode: Vec<String>,
            pub socket_listen_mode: Vec<String>,
            pub x11_forwarding_mode: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ForwardingConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "forwardingMode" => intermediate_rep.forwarding_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "reverseForwardingMode" => intermediate_rep.reverse_forwarding_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "socketForwardingMode" => intermediate_rep.socket_forwarding_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "socketListenMode" => intermediate_rep.socket_listen_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "x11ForwardingMode" => intermediate_rep.x11_forwarding_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ForwardingConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ForwardingConfig {
            forwarding_mode: intermediate_rep.forwarding_mode.into_iter().next(),
            reverse_forwarding_mode: intermediate_rep.reverse_forwarding_mode.into_iter().next(),
            socket_forwarding_mode: intermediate_rep.socket_forwarding_mode.into_iter().next(),
            socket_listen_mode: intermediate_rep.socket_listen_mode.into_iter().next(),
            x11_forwarding_mode: intermediate_rep.x11_forwarding_mode.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ForwardingConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ForwardingConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ForwardingConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ForwardingConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ForwardingConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ForwardingConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ForwardingConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A GCE PD must exist before mounting to a container. The disk must also be in the same GCE project and zone as the kubelet. A GCE PD can only be mounted as read/write once or read-only many times. GCE PDs support ownership management and SELinux relabeling.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GcePersistentDiskVolumeSource {
/// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine +optional
    #[serde(rename = "fsType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fs_type: Option<String>,

/// The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk +optional
    #[serde(rename = "partition")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partition: Option<i32>,

/// Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    #[serde(rename = "pdName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pd_name: Option<String>,

/// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk +optional
    #[serde(rename = "readOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

}


impl GcePersistentDiskVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GcePersistentDiskVolumeSource {
        GcePersistentDiskVolumeSource {
            fs_type: None,
            partition: None,
            pd_name: None,
            read_only: None,
        }
    }
}

/// Converts the GcePersistentDiskVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GcePersistentDiskVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.fs_type.as_ref().map(|fs_type| {
                [
                    "fsType".to_string(),
                    fs_type.to_string(),
                ].join(",")
            }),


            self.partition.as_ref().map(|partition| {
                [
                    "partition".to_string(),
                    partition.to_string(),
                ].join(",")
            }),


            self.pd_name.as_ref().map(|pd_name| {
                [
                    "pdName".to_string(),
                    pd_name.to_string(),
                ].join(",")
            }),


            self.read_only.as_ref().map(|read_only| {
                [
                    "readOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GcePersistentDiskVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GcePersistentDiskVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub fs_type: Vec<String>,
            pub partition: Vec<i32>,
            pub pd_name: Vec<String>,
            pub read_only: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GcePersistentDiskVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "fsType" => intermediate_rep.fs_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partition" => intermediate_rep.partition.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pdName" => intermediate_rep.pd_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "readOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GcePersistentDiskVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GcePersistentDiskVolumeSource {
            fs_type: intermediate_rep.fs_type.into_iter().next(),
            partition: intermediate_rep.partition.into_iter().next(),
            pd_name: intermediate_rep.pd_name.into_iter().next(),
            read_only: intermediate_rep.read_only.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GcePersistentDiskVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GcePersistentDiskVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GcePersistentDiskVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GcePersistentDiskVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GcePersistentDiskVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GcePersistentDiskVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GcePersistentDiskVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GitRepoVolumeSource {
/// Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name. +optional
    #[serde(rename = "directory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub directory: Option<String>,

/// Repository URL
    #[serde(rename = "repository")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<String>,

/// Commit hash for the specified revision. +optional
    #[serde(rename = "revision")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub revision: Option<String>,

}


impl GitRepoVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GitRepoVolumeSource {
        GitRepoVolumeSource {
            directory: None,
            repository: None,
            revision: None,
        }
    }
}

/// Converts the GitRepoVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GitRepoVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.directory.as_ref().map(|directory| {
                [
                    "directory".to_string(),
                    directory.to_string(),
                ].join(",")
            }),


            self.repository.as_ref().map(|repository| {
                [
                    "repository".to_string(),
                    repository.to_string(),
                ].join(",")
            }),


            self.revision.as_ref().map(|revision| {
                [
                    "revision".to_string(),
                    revision.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GitRepoVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GitRepoVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub directory: Vec<String>,
            pub repository: Vec<String>,
            pub revision: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GitRepoVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "directory" => intermediate_rep.directory.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "repository" => intermediate_rep.repository.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "revision" => intermediate_rep.revision.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GitRepoVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GitRepoVolumeSource {
            directory: intermediate_rep.directory.into_iter().next(),
            repository: intermediate_rep.repository.into_iter().next(),
            revision: intermediate_rep.revision.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GitRepoVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GitRepoVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GitRepoVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GitRepoVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GitRepoVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GitRepoVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GitRepoVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Glusterfs volumes do not support ownership management or SELinux relabeling.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GlusterfsVolumeSource {
/// EndpointsName is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
    #[serde(rename = "endpoints")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub endpoints: Option<String>,

/// Path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
    #[serde(rename = "path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

/// ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod +optional
    #[serde(rename = "readOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

}


impl GlusterfsVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GlusterfsVolumeSource {
        GlusterfsVolumeSource {
            endpoints: None,
            path: None,
            read_only: None,
        }
    }
}

/// Converts the GlusterfsVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GlusterfsVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.endpoints.as_ref().map(|endpoints| {
                [
                    "endpoints".to_string(),
                    endpoints.to_string(),
                ].join(",")
            }),


            self.path.as_ref().map(|path| {
                [
                    "path".to_string(),
                    path.to_string(),
                ].join(",")
            }),


            self.read_only.as_ref().map(|read_only| {
                [
                    "readOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GlusterfsVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GlusterfsVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub endpoints: Vec<String>,
            pub path: Vec<String>,
            pub read_only: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GlusterfsVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "endpoints" => intermediate_rep.endpoints.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "readOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GlusterfsVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GlusterfsVolumeSource {
            endpoints: intermediate_rep.endpoints.into_iter().next(),
            path: intermediate_rep.path.into_iter().next(),
            read_only: intermediate_rep.read_only.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GlusterfsVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GlusterfsVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GlusterfsVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GlusterfsVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GlusterfsVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GlusterfsVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GlusterfsVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GraphDriverData {
/// data
    #[serde(rename = "Data")]
    pub data: std::collections::HashMap<String, String>,

/// name
    #[serde(rename = "Name")]
    pub name: String,

}


impl GraphDriverData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(data: std::collections::HashMap<String, String>, name: String, ) -> GraphDriverData {
        GraphDriverData {
            data,
            name,
        }
    }
}

/// Converts the GraphDriverData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GraphDriverData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping Data in query parameter serialization


            Some("Name".to_string()),
            Some(self.name.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GraphDriverData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GraphDriverData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<std::collections::HashMap<String, String>>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GraphDriverData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Data" => return std::result::Result::Err("Parsing a container in this style is not supported in GraphDriverData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GraphDriverData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GraphDriverData {
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "Data missing in GraphDriverData".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "Name missing in GraphDriverData".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GraphDriverData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GraphDriverData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GraphDriverData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GraphDriverData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GraphDriverData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GraphDriverData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GraphDriverData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GrpcAction {
/// Port number of the gRPC service. Number must be in the range 1 to 65535.
    #[serde(rename = "port")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub port: Option<i32>,

/// Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).  If this is not specified, the default behavior is defined by gRPC. +optional +default=\"\"
    #[serde(rename = "service")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub service: Option<String>,

}


impl GrpcAction {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GrpcAction {
        GrpcAction {
            port: None,
            service: None,
        }
    }
}

/// Converts the GrpcAction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GrpcAction {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.port.as_ref().map(|port| {
                [
                    "port".to_string(),
                    port.to_string(),
                ].join(",")
            }),


            self.service.as_ref().map(|service| {
                [
                    "service".to_string(),
                    service.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GrpcAction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GrpcAction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub port: Vec<i32>,
            pub service: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GrpcAction".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "port" => intermediate_rep.port.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "service" => intermediate_rep.service.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GrpcAction".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GrpcAction {
            port: intermediate_rep.port.into_iter().next(),
            service: intermediate_rep.service.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GrpcAction> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GrpcAction>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GrpcAction>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GrpcAction - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GrpcAction> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GrpcAction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GrpcAction - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HealthConfig {
/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "Interval")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub interval: Option<i64>,

/// Retries is the number of consecutive failures needed to consider a container as unhealthy. Zero means inherit.
    #[serde(rename = "Retries")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub retries: Option<i64>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "StartPeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_period: Option<i64>,

/// Test is the test to perform to check that the container is healthy. An empty slice means to inherit the default. The options are: {} : inherit healthcheck {\"NONE\"} : disable healthcheck {\"CMD\", args...} : exec arguments directly {\"CMD-SHELL\", command} : run command with system's default shell
    #[serde(rename = "Test")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub test: Option<Vec<String>>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "Timeout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeout: Option<i64>,

}


impl HealthConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> HealthConfig {
        HealthConfig {
            interval: None,
            retries: None,
            start_period: None,
            test: None,
            timeout: None,
        }
    }
}

/// Converts the HealthConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for HealthConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.interval.as_ref().map(|interval| {
                [
                    "Interval".to_string(),
                    interval.to_string(),
                ].join(",")
            }),


            self.retries.as_ref().map(|retries| {
                [
                    "Retries".to_string(),
                    retries.to_string(),
                ].join(",")
            }),


            self.start_period.as_ref().map(|start_period| {
                [
                    "StartPeriod".to_string(),
                    start_period.to_string(),
                ].join(",")
            }),


            self.test.as_ref().map(|test| {
                [
                    "Test".to_string(),
                    test.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.timeout.as_ref().map(|timeout| {
                [
                    "Timeout".to_string(),
                    timeout.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HealthConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HealthConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub interval: Vec<i64>,
            pub retries: Vec<i64>,
            pub start_period: Vec<i64>,
            pub test: Vec<Vec<String>>,
            pub timeout: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing HealthConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Interval" => intermediate_rep.interval.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Retries" => intermediate_rep.retries.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StartPeriod" => intermediate_rep.start_period.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Test" => return std::result::Result::Err("Parsing a container in this style is not supported in HealthConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Timeout" => intermediate_rep.timeout.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing HealthConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HealthConfig {
            interval: intermediate_rep.interval.into_iter().next(),
            retries: intermediate_rep.retries.into_iter().next(),
            start_period: intermediate_rep.start_period.into_iter().next(),
            test: intermediate_rep.test.into_iter().next(),
            timeout: intermediate_rep.timeout.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HealthConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<HealthConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<HealthConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for HealthConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<HealthConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <HealthConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into HealthConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// HistoryResponseItem individual image layer information in response to ImageHistory operation



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HistoryResponseItem {
/// comment
    #[serde(rename = "Comment")]
    pub comment: String,

/// created
    #[serde(rename = "Created")]
    pub created: i64,

/// created by
    #[serde(rename = "CreatedBy")]
    pub created_by: String,

/// Id
    #[serde(rename = "Id")]
    pub id: String,

/// size
    #[serde(rename = "Size")]
    pub size: i64,

/// tags
    #[serde(rename = "Tags")]
    pub tags: Vec<String>,

}


impl HistoryResponseItem {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(comment: String, created: i64, created_by: String, id: String, size: i64, tags: Vec<String>, ) -> HistoryResponseItem {
        HistoryResponseItem {
            comment,
            created,
            created_by,
            id,
            size,
            tags,
        }
    }
}

/// Converts the HistoryResponseItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for HistoryResponseItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("Comment".to_string()),
            Some(self.comment.to_string()),


            Some("Created".to_string()),
            Some(self.created.to_string()),


            Some("CreatedBy".to_string()),
            Some(self.created_by.to_string()),


            Some("Id".to_string()),
            Some(self.id.to_string()),


            Some("Size".to_string()),
            Some(self.size.to_string()),


            Some("Tags".to_string()),
            Some(self.tags.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HistoryResponseItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HistoryResponseItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub comment: Vec<String>,
            pub created: Vec<i64>,
            pub created_by: Vec<String>,
            pub id: Vec<String>,
            pub size: Vec<i64>,
            pub tags: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing HistoryResponseItem".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Comment" => intermediate_rep.comment.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Created" => intermediate_rep.created.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CreatedBy" => intermediate_rep.created_by.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Size" => intermediate_rep.size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Tags" => return std::result::Result::Err("Parsing a container in this style is not supported in HistoryResponseItem".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing HistoryResponseItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HistoryResponseItem {
            comment: intermediate_rep.comment.into_iter().next().ok_or_else(|| "Comment missing in HistoryResponseItem".to_string())?,
            created: intermediate_rep.created.into_iter().next().ok_or_else(|| "Created missing in HistoryResponseItem".to_string())?,
            created_by: intermediate_rep.created_by.into_iter().next().ok_or_else(|| "CreatedBy missing in HistoryResponseItem".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "Id missing in HistoryResponseItem".to_string())?,
            size: intermediate_rep.size.into_iter().next().ok_or_else(|| "Size missing in HistoryResponseItem".to_string())?,
            tags: intermediate_rep.tags.into_iter().next().ok_or_else(|| "Tags missing in HistoryResponseItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HistoryResponseItem> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<HistoryResponseItem>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<HistoryResponseItem>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for HistoryResponseItem - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<HistoryResponseItem> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <HistoryResponseItem as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into HistoryResponseItem - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HostAlias {
/// Hostnames for the above IP address.
    #[serde(rename = "hostnames")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostnames: Option<Vec<String>>,

/// IP address of the host file entry.
    #[serde(rename = "ip")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ip: Option<String>,

}


impl HostAlias {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> HostAlias {
        HostAlias {
            hostnames: None,
            ip: None,
        }
    }
}

/// Converts the HostAlias value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for HostAlias {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.hostnames.as_ref().map(|hostnames| {
                [
                    "hostnames".to_string(),
                    hostnames.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.ip.as_ref().map(|ip| {
                [
                    "ip".to_string(),
                    ip.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HostAlias value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HostAlias {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hostnames: Vec<Vec<String>>,
            pub ip: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing HostAlias".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "hostnames" => return std::result::Result::Err("Parsing a container in this style is not supported in HostAlias".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ip" => intermediate_rep.ip.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing HostAlias".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HostAlias {
            hostnames: intermediate_rep.hostnames.into_iter().next(),
            ip: intermediate_rep.ip.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HostAlias> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<HostAlias>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<HostAlias>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for HostAlias - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<HostAlias> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <HostAlias as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into HostAlias - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Here, \"non-portable\" means \"dependent of the host we are running on\". Portable information *should* appear in Config.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HostConfig {
    #[serde(rename = "AutoRemove")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_remove: Option<bool>,

/// Applicable to all platforms
    #[serde(rename = "Binds")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub binds: Option<Vec<String>>,

    #[serde(rename = "BlkioDeviceReadBps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_read_bps: Option<Vec<models::ThrottleDevice>>,

    #[serde(rename = "BlkioDeviceReadIOps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_read_i_ops: Option<Vec<models::ThrottleDevice>>,

    #[serde(rename = "BlkioDeviceWriteBps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_write_bps: Option<Vec<models::ThrottleDevice>>,

    #[serde(rename = "BlkioDeviceWriteIOps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_write_i_ops: Option<Vec<models::ThrottleDevice>>,

    #[serde(rename = "BlkioWeight")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_weight: Option<i32>,

    #[serde(rename = "BlkioWeightDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_weight_device: Option<Vec<models::WeightDevice>>,

/// We need to override the json decoder to accept both options.
    #[serde(rename = "CapAdd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cap_add: Option<Vec<String>>,

/// We need to override the json decoder to accept both options.
    #[serde(rename = "CapDrop")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cap_drop: Option<Vec<String>>,

    #[serde(rename = "Cgroup")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup: Option<String>,

/// Applicable to UNIX platforms
    #[serde(rename = "CgroupParent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_parent: Option<String>,

/// CgroupnsMode represents the cgroup namespace mode of the container
    #[serde(rename = "CgroupnsMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroupns_mode: Option<String>,

/// Applicable to Windows
    #[serde(rename = "ConsoleSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub console_size: Option<Vec<i32>>,

    #[serde(rename = "ContainerIDFile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_id_file: Option<String>,

/// Applicable to Windows
    #[serde(rename = "CpuCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_count: Option<i64>,

    #[serde(rename = "CpuPercent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_percent: Option<i64>,

    #[serde(rename = "CpuPeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_period: Option<i64>,

    #[serde(rename = "CpuQuota")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_quota: Option<i64>,

    #[serde(rename = "CpuRealtimePeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_realtime_period: Option<i64>,

    #[serde(rename = "CpuRealtimeRuntime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_realtime_runtime: Option<i64>,

/// Applicable to all platforms
    #[serde(rename = "CpuShares")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_shares: Option<i64>,

    #[serde(rename = "CpusetCpus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpuset_cpus: Option<String>,

    #[serde(rename = "CpusetMems")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpuset_mems: Option<String>,

    #[serde(rename = "DeviceCgroupRules")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_cgroup_rules: Option<Vec<String>>,

    #[serde(rename = "DeviceRequests")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_requests: Option<Vec<models::DeviceRequest>>,

    #[serde(rename = "Devices")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub devices: Option<Vec<models::DeviceMapping>>,

    #[serde(rename = "Dns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns: Option<Vec<String>>,

    #[serde(rename = "DnsOptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_options: Option<Vec<String>>,

    #[serde(rename = "DnsSearch")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_search: Option<Vec<String>>,

    #[serde(rename = "ExtraHosts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub extra_hosts: Option<Vec<String>>,

    #[serde(rename = "GroupAdd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub group_add: Option<Vec<String>>,

    #[serde(rename = "IOMaximumBandwidth")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub io_maximum_bandwidth: Option<i32>,

    #[serde(rename = "IOMaximumIOps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub io_maximum_i_ops: Option<i32>,

/// Run a custom init inside the container, if null, use the daemon's configured settings
    #[serde(rename = "Init")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub init: Option<bool>,

    #[serde(rename = "IpcMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipc_mode: Option<String>,

/// Isolation represents the isolation technology of a container. The supported values are platform specific
    #[serde(rename = "Isolation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub isolation: Option<String>,

    #[serde(rename = "KernelMemory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kernel_memory: Option<i64>,

    #[serde(rename = "KernelMemoryTCP")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kernel_memory_tcp: Option<i64>,

    #[serde(rename = "Links")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub links: Option<Vec<String>>,

    #[serde(rename = "LogConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub log_config: Option<models::LogConfig>,

/// MaskedPaths is the list of paths to be masked inside the container (this overrides the default set of paths)
    #[serde(rename = "MaskedPaths")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub masked_paths: Option<Vec<String>>,

    #[serde(rename = "Memory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory: Option<i64>,

    #[serde(rename = "MemoryReservation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_reservation: Option<i64>,

    #[serde(rename = "MemorySwap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_swap: Option<i64>,

    #[serde(rename = "MemorySwappiness")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_swappiness: Option<i64>,

/// Mounts specs used by the container
    #[serde(rename = "Mounts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mounts: Option<Vec<models::Mount>>,

    #[serde(rename = "NanoCpus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub nano_cpus: Option<i64>,

    #[serde(rename = "NetworkMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_mode: Option<String>,

    #[serde(rename = "OomKillDisable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub oom_kill_disable: Option<bool>,

    #[serde(rename = "OomScoreAdj")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub oom_score_adj: Option<i64>,

    #[serde(rename = "PidMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pid_mode: Option<String>,

    #[serde(rename = "PidsLimit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pids_limit: Option<i64>,

/// PortMap is a collection of PortBinding indexed by Port
    #[serde(rename = "PortBindings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub port_bindings: Option<std::collections::HashMap<String, Vec<models::PortBinding>>>,

    #[serde(rename = "Privileged")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub privileged: Option<bool>,

    #[serde(rename = "PublishAllPorts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub publish_all_ports: Option<bool>,

/// ReadonlyPaths is the list of paths to be set as read-only inside the container (this overrides the default set of paths)
    #[serde(rename = "ReadonlyPaths")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub readonly_paths: Option<Vec<String>>,

    #[serde(rename = "ReadonlyRootfs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub readonly_rootfs: Option<bool>,

/// Only one of the following restart policies may be specified. If none of the following policies is specified, the default one is RestartPolicyAlways. +enum
    #[serde(rename = "RestartPolicy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restart_policy: Option<String>,

    #[serde(rename = "Runtime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub runtime: Option<String>,

    #[serde(rename = "SecurityOpt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_opt: Option<Vec<String>>,

    #[serde(rename = "ShmSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shm_size: Option<i64>,

    #[serde(rename = "StorageOpt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_opt: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "Sysctls")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sysctls: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "Tmpfs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tmpfs: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "UTSMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub uts_mode: Option<String>,

    #[serde(rename = "Ulimits")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ulimits: Option<Vec<models::Ulimit>>,

    #[serde(rename = "UsernsMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub userns_mode: Option<String>,

    #[serde(rename = "VolumeDriver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_driver: Option<String>,

    #[serde(rename = "VolumesFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes_from: Option<Vec<String>>,

}


impl HostConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> HostConfig {
        HostConfig {
            auto_remove: None,
            binds: None,
            blkio_device_read_bps: None,
            blkio_device_read_i_ops: None,
            blkio_device_write_bps: None,
            blkio_device_write_i_ops: None,
            blkio_weight: None,
            blkio_weight_device: None,
            cap_add: None,
            cap_drop: None,
            cgroup: None,
            cgroup_parent: None,
            cgroupns_mode: None,
            console_size: None,
            container_id_file: None,
            cpu_count: None,
            cpu_percent: None,
            cpu_period: None,
            cpu_quota: None,
            cpu_realtime_period: None,
            cpu_realtime_runtime: None,
            cpu_shares: None,
            cpuset_cpus: None,
            cpuset_mems: None,
            device_cgroup_rules: None,
            device_requests: None,
            devices: None,
            dns: None,
            dns_options: None,
            dns_search: None,
            extra_hosts: None,
            group_add: None,
            io_maximum_bandwidth: None,
            io_maximum_i_ops: None,
            init: None,
            ipc_mode: None,
            isolation: None,
            kernel_memory: None,
            kernel_memory_tcp: None,
            links: None,
            log_config: None,
            masked_paths: None,
            memory: None,
            memory_reservation: None,
            memory_swap: None,
            memory_swappiness: None,
            mounts: None,
            nano_cpus: None,
            network_mode: None,
            oom_kill_disable: None,
            oom_score_adj: None,
            pid_mode: None,
            pids_limit: None,
            port_bindings: None,
            privileged: None,
            publish_all_ports: None,
            readonly_paths: None,
            readonly_rootfs: None,
            restart_policy: None,
            runtime: None,
            security_opt: None,
            shm_size: None,
            storage_opt: None,
            sysctls: None,
            tmpfs: None,
            uts_mode: None,
            ulimits: None,
            userns_mode: None,
            volume_driver: None,
            volumes_from: None,
        }
    }
}

/// Converts the HostConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for HostConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.auto_remove.as_ref().map(|auto_remove| {
                [
                    "AutoRemove".to_string(),
                    auto_remove.to_string(),
                ].join(",")
            }),


            self.binds.as_ref().map(|binds| {
                [
                    "Binds".to_string(),
                    binds.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping BlkioDeviceReadBps in query parameter serialization

            // Skipping BlkioDeviceReadIOps in query parameter serialization

            // Skipping BlkioDeviceWriteBps in query parameter serialization

            // Skipping BlkioDeviceWriteIOps in query parameter serialization


            self.blkio_weight.as_ref().map(|blkio_weight| {
                [
                    "BlkioWeight".to_string(),
                    blkio_weight.to_string(),
                ].join(",")
            }),

            // Skipping BlkioWeightDevice in query parameter serialization


            self.cap_add.as_ref().map(|cap_add| {
                [
                    "CapAdd".to_string(),
                    cap_add.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.cap_drop.as_ref().map(|cap_drop| {
                [
                    "CapDrop".to_string(),
                    cap_drop.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.cgroup.as_ref().map(|cgroup| {
                [
                    "Cgroup".to_string(),
                    cgroup.to_string(),
                ].join(",")
            }),


            self.cgroup_parent.as_ref().map(|cgroup_parent| {
                [
                    "CgroupParent".to_string(),
                    cgroup_parent.to_string(),
                ].join(",")
            }),


            self.cgroupns_mode.as_ref().map(|cgroupns_mode| {
                [
                    "CgroupnsMode".to_string(),
                    cgroupns_mode.to_string(),
                ].join(",")
            }),


            self.console_size.as_ref().map(|console_size| {
                [
                    "ConsoleSize".to_string(),
                    console_size.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.container_id_file.as_ref().map(|container_id_file| {
                [
                    "ContainerIDFile".to_string(),
                    container_id_file.to_string(),
                ].join(",")
            }),


            self.cpu_count.as_ref().map(|cpu_count| {
                [
                    "CpuCount".to_string(),
                    cpu_count.to_string(),
                ].join(",")
            }),


            self.cpu_percent.as_ref().map(|cpu_percent| {
                [
                    "CpuPercent".to_string(),
                    cpu_percent.to_string(),
                ].join(",")
            }),


            self.cpu_period.as_ref().map(|cpu_period| {
                [
                    "CpuPeriod".to_string(),
                    cpu_period.to_string(),
                ].join(",")
            }),


            self.cpu_quota.as_ref().map(|cpu_quota| {
                [
                    "CpuQuota".to_string(),
                    cpu_quota.to_string(),
                ].join(",")
            }),


            self.cpu_realtime_period.as_ref().map(|cpu_realtime_period| {
                [
                    "CpuRealtimePeriod".to_string(),
                    cpu_realtime_period.to_string(),
                ].join(",")
            }),


            self.cpu_realtime_runtime.as_ref().map(|cpu_realtime_runtime| {
                [
                    "CpuRealtimeRuntime".to_string(),
                    cpu_realtime_runtime.to_string(),
                ].join(",")
            }),


            self.cpu_shares.as_ref().map(|cpu_shares| {
                [
                    "CpuShares".to_string(),
                    cpu_shares.to_string(),
                ].join(",")
            }),


            self.cpuset_cpus.as_ref().map(|cpuset_cpus| {
                [
                    "CpusetCpus".to_string(),
                    cpuset_cpus.to_string(),
                ].join(",")
            }),


            self.cpuset_mems.as_ref().map(|cpuset_mems| {
                [
                    "CpusetMems".to_string(),
                    cpuset_mems.to_string(),
                ].join(",")
            }),


            self.device_cgroup_rules.as_ref().map(|device_cgroup_rules| {
                [
                    "DeviceCgroupRules".to_string(),
                    device_cgroup_rules.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping DeviceRequests in query parameter serialization

            // Skipping Devices in query parameter serialization


            self.dns.as_ref().map(|dns| {
                [
                    "Dns".to_string(),
                    dns.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_options.as_ref().map(|dns_options| {
                [
                    "DnsOptions".to_string(),
                    dns_options.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_search.as_ref().map(|dns_search| {
                [
                    "DnsSearch".to_string(),
                    dns_search.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.extra_hosts.as_ref().map(|extra_hosts| {
                [
                    "ExtraHosts".to_string(),
                    extra_hosts.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.group_add.as_ref().map(|group_add| {
                [
                    "GroupAdd".to_string(),
                    group_add.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.io_maximum_bandwidth.as_ref().map(|io_maximum_bandwidth| {
                [
                    "IOMaximumBandwidth".to_string(),
                    io_maximum_bandwidth.to_string(),
                ].join(",")
            }),


            self.io_maximum_i_ops.as_ref().map(|io_maximum_i_ops| {
                [
                    "IOMaximumIOps".to_string(),
                    io_maximum_i_ops.to_string(),
                ].join(",")
            }),


            self.init.as_ref().map(|init| {
                [
                    "Init".to_string(),
                    init.to_string(),
                ].join(",")
            }),


            self.ipc_mode.as_ref().map(|ipc_mode| {
                [
                    "IpcMode".to_string(),
                    ipc_mode.to_string(),
                ].join(",")
            }),


            self.isolation.as_ref().map(|isolation| {
                [
                    "Isolation".to_string(),
                    isolation.to_string(),
                ].join(",")
            }),


            self.kernel_memory.as_ref().map(|kernel_memory| {
                [
                    "KernelMemory".to_string(),
                    kernel_memory.to_string(),
                ].join(",")
            }),


            self.kernel_memory_tcp.as_ref().map(|kernel_memory_tcp| {
                [
                    "KernelMemoryTCP".to_string(),
                    kernel_memory_tcp.to_string(),
                ].join(",")
            }),


            self.links.as_ref().map(|links| {
                [
                    "Links".to_string(),
                    links.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping LogConfig in query parameter serialization


            self.masked_paths.as_ref().map(|masked_paths| {
                [
                    "MaskedPaths".to_string(),
                    masked_paths.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.memory.as_ref().map(|memory| {
                [
                    "Memory".to_string(),
                    memory.to_string(),
                ].join(",")
            }),


            self.memory_reservation.as_ref().map(|memory_reservation| {
                [
                    "MemoryReservation".to_string(),
                    memory_reservation.to_string(),
                ].join(",")
            }),


            self.memory_swap.as_ref().map(|memory_swap| {
                [
                    "MemorySwap".to_string(),
                    memory_swap.to_string(),
                ].join(",")
            }),


            self.memory_swappiness.as_ref().map(|memory_swappiness| {
                [
                    "MemorySwappiness".to_string(),
                    memory_swappiness.to_string(),
                ].join(",")
            }),

            // Skipping Mounts in query parameter serialization


            self.nano_cpus.as_ref().map(|nano_cpus| {
                [
                    "NanoCpus".to_string(),
                    nano_cpus.to_string(),
                ].join(",")
            }),


            self.network_mode.as_ref().map(|network_mode| {
                [
                    "NetworkMode".to_string(),
                    network_mode.to_string(),
                ].join(",")
            }),


            self.oom_kill_disable.as_ref().map(|oom_kill_disable| {
                [
                    "OomKillDisable".to_string(),
                    oom_kill_disable.to_string(),
                ].join(",")
            }),


            self.oom_score_adj.as_ref().map(|oom_score_adj| {
                [
                    "OomScoreAdj".to_string(),
                    oom_score_adj.to_string(),
                ].join(",")
            }),


            self.pid_mode.as_ref().map(|pid_mode| {
                [
                    "PidMode".to_string(),
                    pid_mode.to_string(),
                ].join(",")
            }),


            self.pids_limit.as_ref().map(|pids_limit| {
                [
                    "PidsLimit".to_string(),
                    pids_limit.to_string(),
                ].join(",")
            }),

            // Skipping PortBindings in query parameter serialization
            // Skipping PortBindings in query parameter serialization


            self.privileged.as_ref().map(|privileged| {
                [
                    "Privileged".to_string(),
                    privileged.to_string(),
                ].join(",")
            }),


            self.publish_all_ports.as_ref().map(|publish_all_ports| {
                [
                    "PublishAllPorts".to_string(),
                    publish_all_ports.to_string(),
                ].join(",")
            }),


            self.readonly_paths.as_ref().map(|readonly_paths| {
                [
                    "ReadonlyPaths".to_string(),
                    readonly_paths.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.readonly_rootfs.as_ref().map(|readonly_rootfs| {
                [
                    "ReadonlyRootfs".to_string(),
                    readonly_rootfs.to_string(),
                ].join(",")
            }),


            self.restart_policy.as_ref().map(|restart_policy| {
                [
                    "RestartPolicy".to_string(),
                    restart_policy.to_string(),
                ].join(",")
            }),


            self.runtime.as_ref().map(|runtime| {
                [
                    "Runtime".to_string(),
                    runtime.to_string(),
                ].join(",")
            }),


            self.security_opt.as_ref().map(|security_opt| {
                [
                    "SecurityOpt".to_string(),
                    security_opt.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.shm_size.as_ref().map(|shm_size| {
                [
                    "ShmSize".to_string(),
                    shm_size.to_string(),
                ].join(",")
            }),

            // Skipping StorageOpt in query parameter serialization

            // Skipping Sysctls in query parameter serialization

            // Skipping Tmpfs in query parameter serialization


            self.uts_mode.as_ref().map(|uts_mode| {
                [
                    "UTSMode".to_string(),
                    uts_mode.to_string(),
                ].join(",")
            }),

            // Skipping Ulimits in query parameter serialization


            self.userns_mode.as_ref().map(|userns_mode| {
                [
                    "UsernsMode".to_string(),
                    userns_mode.to_string(),
                ].join(",")
            }),


            self.volume_driver.as_ref().map(|volume_driver| {
                [
                    "VolumeDriver".to_string(),
                    volume_driver.to_string(),
                ].join(",")
            }),


            self.volumes_from.as_ref().map(|volumes_from| {
                [
                    "VolumesFrom".to_string(),
                    volumes_from.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HostConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HostConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub auto_remove: Vec<bool>,
            pub binds: Vec<Vec<String>>,
            pub blkio_device_read_bps: Vec<Vec<models::ThrottleDevice>>,
            pub blkio_device_read_i_ops: Vec<Vec<models::ThrottleDevice>>,
            pub blkio_device_write_bps: Vec<Vec<models::ThrottleDevice>>,
            pub blkio_device_write_i_ops: Vec<Vec<models::ThrottleDevice>>,
            pub blkio_weight: Vec<i32>,
            pub blkio_weight_device: Vec<Vec<models::WeightDevice>>,
            pub cap_add: Vec<Vec<String>>,
            pub cap_drop: Vec<Vec<String>>,
            pub cgroup: Vec<String>,
            pub cgroup_parent: Vec<String>,
            pub cgroupns_mode: Vec<String>,
            pub console_size: Vec<Vec<i32>>,
            pub container_id_file: Vec<String>,
            pub cpu_count: Vec<i64>,
            pub cpu_percent: Vec<i64>,
            pub cpu_period: Vec<i64>,
            pub cpu_quota: Vec<i64>,
            pub cpu_realtime_period: Vec<i64>,
            pub cpu_realtime_runtime: Vec<i64>,
            pub cpu_shares: Vec<i64>,
            pub cpuset_cpus: Vec<String>,
            pub cpuset_mems: Vec<String>,
            pub device_cgroup_rules: Vec<Vec<String>>,
            pub device_requests: Vec<Vec<models::DeviceRequest>>,
            pub devices: Vec<Vec<models::DeviceMapping>>,
            pub dns: Vec<Vec<String>>,
            pub dns_options: Vec<Vec<String>>,
            pub dns_search: Vec<Vec<String>>,
            pub extra_hosts: Vec<Vec<String>>,
            pub group_add: Vec<Vec<String>>,
            pub io_maximum_bandwidth: Vec<i32>,
            pub io_maximum_i_ops: Vec<i32>,
            pub init: Vec<bool>,
            pub ipc_mode: Vec<String>,
            pub isolation: Vec<String>,
            pub kernel_memory: Vec<i64>,
            pub kernel_memory_tcp: Vec<i64>,
            pub links: Vec<Vec<String>>,
            pub log_config: Vec<models::LogConfig>,
            pub masked_paths: Vec<Vec<String>>,
            pub memory: Vec<i64>,
            pub memory_reservation: Vec<i64>,
            pub memory_swap: Vec<i64>,
            pub memory_swappiness: Vec<i64>,
            pub mounts: Vec<Vec<models::Mount>>,
            pub nano_cpus: Vec<i64>,
            pub network_mode: Vec<String>,
            pub oom_kill_disable: Vec<bool>,
            pub oom_score_adj: Vec<i64>,
            pub pid_mode: Vec<String>,
            pub pids_limit: Vec<i64>,
            pub port_bindings: Vec<std::collections::HashMap<String, Vec<models::PortBinding>>>,
            pub privileged: Vec<bool>,
            pub publish_all_ports: Vec<bool>,
            pub readonly_paths: Vec<Vec<String>>,
            pub readonly_rootfs: Vec<bool>,
            pub restart_policy: Vec<String>,
            pub runtime: Vec<String>,
            pub security_opt: Vec<Vec<String>>,
            pub shm_size: Vec<i64>,
            pub storage_opt: Vec<std::collections::HashMap<String, String>>,
            pub sysctls: Vec<std::collections::HashMap<String, String>>,
            pub tmpfs: Vec<std::collections::HashMap<String, String>>,
            pub uts_mode: Vec<String>,
            pub ulimits: Vec<Vec<models::Ulimit>>,
            pub userns_mode: Vec<String>,
            pub volume_driver: Vec<String>,
            pub volumes_from: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing HostConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "AutoRemove" => intermediate_rep.auto_remove.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Binds" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "BlkioDeviceReadBps" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "BlkioDeviceReadIOps" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "BlkioDeviceWriteBps" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "BlkioDeviceWriteIOps" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "BlkioWeight" => intermediate_rep.blkio_weight.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "BlkioWeightDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "CapAdd" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "CapDrop" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Cgroup" => intermediate_rep.cgroup.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CgroupParent" => intermediate_rep.cgroup_parent.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CgroupnsMode" => intermediate_rep.cgroupns_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ConsoleSize" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ContainerIDFile" => intermediate_rep.container_id_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuCount" => intermediate_rep.cpu_count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuPercent" => intermediate_rep.cpu_percent.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuPeriod" => intermediate_rep.cpu_period.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuQuota" => intermediate_rep.cpu_quota.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuRealtimePeriod" => intermediate_rep.cpu_realtime_period.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuRealtimeRuntime" => intermediate_rep.cpu_realtime_runtime.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuShares" => intermediate_rep.cpu_shares.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpusetCpus" => intermediate_rep.cpuset_cpus.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpusetMems" => intermediate_rep.cpuset_mems.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "DeviceCgroupRules" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "DeviceRequests" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "Devices" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "Dns" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "DnsOptions" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "DnsSearch" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "ExtraHosts" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "GroupAdd" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "IOMaximumBandwidth" => intermediate_rep.io_maximum_bandwidth.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IOMaximumIOps" => intermediate_rep.io_maximum_i_ops.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Init" => intermediate_rep.init.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IpcMode" => intermediate_rep.ipc_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Isolation" => intermediate_rep.isolation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "KernelMemory" => intermediate_rep.kernel_memory.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "KernelMemoryTCP" => intermediate_rep.kernel_memory_tcp.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Links" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "LogConfig" => intermediate_rep.log_config.push(<models::LogConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "MaskedPaths" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Memory" => intermediate_rep.memory.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemoryReservation" => intermediate_rep.memory_reservation.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemorySwap" => intermediate_rep.memory_swap.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemorySwappiness" => intermediate_rep.memory_swappiness.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Mounts" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "NanoCpus" => intermediate_rep.nano_cpus.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NetworkMode" => intermediate_rep.network_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OomKillDisable" => intermediate_rep.oom_kill_disable.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OomScoreAdj" => intermediate_rep.oom_score_adj.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PidMode" => intermediate_rep.pid_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PidsLimit" => intermediate_rep.pids_limit.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "PortBindings" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Privileged" => intermediate_rep.privileged.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PublishAllPorts" => intermediate_rep.publish_all_ports.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ReadonlyPaths" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ReadonlyRootfs" => intermediate_rep.readonly_rootfs.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "RestartPolicy" => intermediate_rep.restart_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Runtime" => intermediate_rep.runtime.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "SecurityOpt" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ShmSize" => intermediate_rep.shm_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "StorageOpt" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "Sysctls" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "Tmpfs" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "UTSMode" => intermediate_rep.uts_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Ulimits" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "UsernsMode" => intermediate_rep.userns_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "VolumeDriver" => intermediate_rep.volume_driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "VolumesFrom" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing HostConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HostConfig {
            auto_remove: intermediate_rep.auto_remove.into_iter().next(),
            binds: intermediate_rep.binds.into_iter().next(),
            blkio_device_read_bps: intermediate_rep.blkio_device_read_bps.into_iter().next(),
            blkio_device_read_i_ops: intermediate_rep.blkio_device_read_i_ops.into_iter().next(),
            blkio_device_write_bps: intermediate_rep.blkio_device_write_bps.into_iter().next(),
            blkio_device_write_i_ops: intermediate_rep.blkio_device_write_i_ops.into_iter().next(),
            blkio_weight: intermediate_rep.blkio_weight.into_iter().next(),
            blkio_weight_device: intermediate_rep.blkio_weight_device.into_iter().next(),
            cap_add: intermediate_rep.cap_add.into_iter().next(),
            cap_drop: intermediate_rep.cap_drop.into_iter().next(),
            cgroup: intermediate_rep.cgroup.into_iter().next(),
            cgroup_parent: intermediate_rep.cgroup_parent.into_iter().next(),
            cgroupns_mode: intermediate_rep.cgroupns_mode.into_iter().next(),
            console_size: intermediate_rep.console_size.into_iter().next(),
            container_id_file: intermediate_rep.container_id_file.into_iter().next(),
            cpu_count: intermediate_rep.cpu_count.into_iter().next(),
            cpu_percent: intermediate_rep.cpu_percent.into_iter().next(),
            cpu_period: intermediate_rep.cpu_period.into_iter().next(),
            cpu_quota: intermediate_rep.cpu_quota.into_iter().next(),
            cpu_realtime_period: intermediate_rep.cpu_realtime_period.into_iter().next(),
            cpu_realtime_runtime: intermediate_rep.cpu_realtime_runtime.into_iter().next(),
            cpu_shares: intermediate_rep.cpu_shares.into_iter().next(),
            cpuset_cpus: intermediate_rep.cpuset_cpus.into_iter().next(),
            cpuset_mems: intermediate_rep.cpuset_mems.into_iter().next(),
            device_cgroup_rules: intermediate_rep.device_cgroup_rules.into_iter().next(),
            device_requests: intermediate_rep.device_requests.into_iter().next(),
            devices: intermediate_rep.devices.into_iter().next(),
            dns: intermediate_rep.dns.into_iter().next(),
            dns_options: intermediate_rep.dns_options.into_iter().next(),
            dns_search: intermediate_rep.dns_search.into_iter().next(),
            extra_hosts: intermediate_rep.extra_hosts.into_iter().next(),
            group_add: intermediate_rep.group_add.into_iter().next(),
            io_maximum_bandwidth: intermediate_rep.io_maximum_bandwidth.into_iter().next(),
            io_maximum_i_ops: intermediate_rep.io_maximum_i_ops.into_iter().next(),
            init: intermediate_rep.init.into_iter().next(),
            ipc_mode: intermediate_rep.ipc_mode.into_iter().next(),
            isolation: intermediate_rep.isolation.into_iter().next(),
            kernel_memory: intermediate_rep.kernel_memory.into_iter().next(),
            kernel_memory_tcp: intermediate_rep.kernel_memory_tcp.into_iter().next(),
            links: intermediate_rep.links.into_iter().next(),
            log_config: intermediate_rep.log_config.into_iter().next(),
            masked_paths: intermediate_rep.masked_paths.into_iter().next(),
            memory: intermediate_rep.memory.into_iter().next(),
            memory_reservation: intermediate_rep.memory_reservation.into_iter().next(),
            memory_swap: intermediate_rep.memory_swap.into_iter().next(),
            memory_swappiness: intermediate_rep.memory_swappiness.into_iter().next(),
            mounts: intermediate_rep.mounts.into_iter().next(),
            nano_cpus: intermediate_rep.nano_cpus.into_iter().next(),
            network_mode: intermediate_rep.network_mode.into_iter().next(),
            oom_kill_disable: intermediate_rep.oom_kill_disable.into_iter().next(),
            oom_score_adj: intermediate_rep.oom_score_adj.into_iter().next(),
            pid_mode: intermediate_rep.pid_mode.into_iter().next(),
            pids_limit: intermediate_rep.pids_limit.into_iter().next(),
            port_bindings: intermediate_rep.port_bindings.into_iter().next(),
            privileged: intermediate_rep.privileged.into_iter().next(),
            publish_all_ports: intermediate_rep.publish_all_ports.into_iter().next(),
            readonly_paths: intermediate_rep.readonly_paths.into_iter().next(),
            readonly_rootfs: intermediate_rep.readonly_rootfs.into_iter().next(),
            restart_policy: intermediate_rep.restart_policy.into_iter().next(),
            runtime: intermediate_rep.runtime.into_iter().next(),
            security_opt: intermediate_rep.security_opt.into_iter().next(),
            shm_size: intermediate_rep.shm_size.into_iter().next(),
            storage_opt: intermediate_rep.storage_opt.into_iter().next(),
            sysctls: intermediate_rep.sysctls.into_iter().next(),
            tmpfs: intermediate_rep.tmpfs.into_iter().next(),
            uts_mode: intermediate_rep.uts_mode.into_iter().next(),
            ulimits: intermediate_rep.ulimits.into_iter().next(),
            userns_mode: intermediate_rep.userns_mode.into_iter().next(),
            volume_driver: intermediate_rep.volume_driver.into_iter().next(),
            volumes_from: intermediate_rep.volumes_from.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HostConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<HostConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<HostConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for HostConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<HostConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <HostConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into HostConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// +enum
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HostPathType(String);

impl validator::Validate for HostPathType {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for HostPathType {
    fn from(x: String) -> Self {
        HostPathType(x)
    }
}

impl std::string::ToString for HostPathType {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for HostPathType {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(HostPathType(x.to_string()))
    }
}

impl std::convert::From<HostPathType> for String {
    fn from(x: HostPathType) -> Self {
        x.0
    }
}

impl std::ops::Deref for HostPathType {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for HostPathType {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// Host path volumes do not support ownership management or SELinux relabeling.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HostPathVolumeSource {
/// Path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
    #[serde(rename = "path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

/// +enum
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

}


impl HostPathVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> HostPathVolumeSource {
        HostPathVolumeSource {
            path: None,
            r#type: None,
        }
    }
}

/// Converts the HostPathVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for HostPathVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.path.as_ref().map(|path| {
                [
                    "path".to_string(),
                    path.to_string(),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HostPathVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HostPathVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub path: Vec<String>,
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing HostPathVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing HostPathVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HostPathVolumeSource {
            path: intermediate_rep.path.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HostPathVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<HostPathVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<HostPathVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for HostPathVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<HostPathVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <HostPathVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into HostPathVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// HTTPClientConfiguration is the configuration structure for HTTP clients



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HttpClientConfiguration {
/// AllowRedirects sets if the client should honor HTTP redirects. Defaults to false.
    #[serde(rename = "allowRedirects")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_redirects: Option<bool>,

/// CACert is either the CA certificate to expect on the server in PEM format or the name of a file containing the PEM.
    #[serde(rename = "cacert")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cacert: Option<String>,

/// ClientCert is a PEM containing an x509 certificate to present to the server or a file name containing the PEM.
    #[serde(rename = "cert")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cert: Option<String>,

    #[serde(rename = "cipher")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cipher: Option<Vec<models::CipherSuite>>,

/// ECDHCurveList is a list of supported ECDHCurve
    #[serde(rename = "curves")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub curves: Option<Vec<models::EcdhCurve>>,

/// ClientKey is a PEM containing a private key to use to connect the server or a file name containing the PEM.
    #[serde(rename = "key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "timeout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeout: Option<i64>,

    #[serde(rename = "tlsVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tls_version: Option<String>,

/// URL is the base URL for requests.
    #[serde(rename = "url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,

}


impl HttpClientConfiguration {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> HttpClientConfiguration {
        HttpClientConfiguration {
            allow_redirects: None,
            cacert: None,
            cert: None,
            cipher: None,
            curves: None,
            key: None,
            timeout: None,
            tls_version: None,
            url: None,
        }
    }
}

/// Converts the HttpClientConfiguration value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for HttpClientConfiguration {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.allow_redirects.as_ref().map(|allow_redirects| {
                [
                    "allowRedirects".to_string(),
                    allow_redirects.to_string(),
                ].join(",")
            }),


            self.cacert.as_ref().map(|cacert| {
                [
                    "cacert".to_string(),
                    cacert.to_string(),
                ].join(",")
            }),


            self.cert.as_ref().map(|cert| {
                [
                    "cert".to_string(),
                    cert.to_string(),
                ].join(",")
            }),


            self.cipher.as_ref().map(|cipher| {
                [
                    "cipher".to_string(),
                    cipher.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.curves.as_ref().map(|curves| {
                [
                    "curves".to_string(),
                    curves.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.key.as_ref().map(|key| {
                [
                    "key".to_string(),
                    key.to_string(),
                ].join(",")
            }),


            self.timeout.as_ref().map(|timeout| {
                [
                    "timeout".to_string(),
                    timeout.to_string(),
                ].join(",")
            }),


            self.tls_version.as_ref().map(|tls_version| {
                [
                    "tlsVersion".to_string(),
                    tls_version.to_string(),
                ].join(",")
            }),


            self.url.as_ref().map(|url| {
                [
                    "url".to_string(),
                    url.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HttpClientConfiguration value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HttpClientConfiguration {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub allow_redirects: Vec<bool>,
            pub cacert: Vec<String>,
            pub cert: Vec<String>,
            pub cipher: Vec<Vec<models::CipherSuite>>,
            pub curves: Vec<Vec<models::EcdhCurve>>,
            pub key: Vec<String>,
            pub timeout: Vec<i64>,
            pub tls_version: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing HttpClientConfiguration".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "allowRedirects" => intermediate_rep.allow_redirects.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cacert" => intermediate_rep.cacert.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cert" => intermediate_rep.cert.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "cipher" => return std::result::Result::Err("Parsing a container in this style is not supported in HttpClientConfiguration".to_string()),
                    "curves" => return std::result::Result::Err("Parsing a container in this style is not supported in HttpClientConfiguration".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "key" => intermediate_rep.key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "timeout" => intermediate_rep.timeout.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tlsVersion" => intermediate_rep.tls_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing HttpClientConfiguration".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HttpClientConfiguration {
            allow_redirects: intermediate_rep.allow_redirects.into_iter().next(),
            cacert: intermediate_rep.cacert.into_iter().next(),
            cert: intermediate_rep.cert.into_iter().next(),
            cipher: intermediate_rep.cipher.into_iter().next(),
            curves: intermediate_rep.curves.into_iter().next(),
            key: intermediate_rep.key.into_iter().next(),
            timeout: intermediate_rep.timeout.into_iter().next(),
            tls_version: intermediate_rep.tls_version.into_iter().next(),
            url: intermediate_rep.url.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HttpClientConfiguration> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<HttpClientConfiguration>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<HttpClientConfiguration>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for HttpClientConfiguration - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<HttpClientConfiguration> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <HttpClientConfiguration as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into HttpClientConfiguration - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HttpGetAction {
/// Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead. +optional
    #[serde(rename = "host")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host: Option<String>,

/// Custom headers to set in the request. HTTP allows repeated headers. +optional
    #[serde(rename = "httpHeaders")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub http_headers: Option<Vec<models::HttpHeader>>,

/// Path to access on the HTTP server. +optional
    #[serde(rename = "path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

    #[serde(rename = "port")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub port: Option<models::IntOrString>,

/// URIScheme identifies the scheme used for connection to a host for Get actions +enum
    #[serde(rename = "scheme")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scheme: Option<String>,

}


impl HttpGetAction {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> HttpGetAction {
        HttpGetAction {
            host: None,
            http_headers: None,
            path: None,
            port: None,
            scheme: None,
        }
    }
}

/// Converts the HttpGetAction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for HttpGetAction {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.host.as_ref().map(|host| {
                [
                    "host".to_string(),
                    host.to_string(),
                ].join(",")
            }),

            // Skipping httpHeaders in query parameter serialization


            self.path.as_ref().map(|path| {
                [
                    "path".to_string(),
                    path.to_string(),
                ].join(",")
            }),

            // Skipping port in query parameter serialization


            self.scheme.as_ref().map(|scheme| {
                [
                    "scheme".to_string(),
                    scheme.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HttpGetAction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HttpGetAction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub host: Vec<String>,
            pub http_headers: Vec<Vec<models::HttpHeader>>,
            pub path: Vec<String>,
            pub port: Vec<models::IntOrString>,
            pub scheme: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing HttpGetAction".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "host" => intermediate_rep.host.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "httpHeaders" => return std::result::Result::Err("Parsing a container in this style is not supported in HttpGetAction".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "port" => intermediate_rep.port.push(<models::IntOrString as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "scheme" => intermediate_rep.scheme.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing HttpGetAction".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HttpGetAction {
            host: intermediate_rep.host.into_iter().next(),
            http_headers: intermediate_rep.http_headers.into_iter().next(),
            path: intermediate_rep.path.into_iter().next(),
            port: intermediate_rep.port.into_iter().next(),
            scheme: intermediate_rep.scheme.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HttpGetAction> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<HttpGetAction>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<HttpGetAction>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for HttpGetAction - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<HttpGetAction> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <HttpGetAction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into HttpGetAction - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// HTTPHeader describes a custom header to be used in HTTP probes



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HttpHeader {
/// The header field name
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// The header field value
    #[serde(rename = "value")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,

}


impl HttpHeader {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> HttpHeader {
        HttpHeader {
            name: None,
            value: None,
        }
    }
}

/// Converts the HttpHeader value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for HttpHeader {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.value.as_ref().map(|value| {
                [
                    "value".to_string(),
                    value.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HttpHeader value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HttpHeader {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing HttpHeader".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing HttpHeader".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HttpHeader {
            name: intermediate_rep.name.into_iter().next(),
            value: intermediate_rep.value.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HttpHeader> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<HttpHeader>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<HttpHeader>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for HttpHeader - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<HttpHeader> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <HttpHeader as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into HttpHeader - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// goland:noinspection GoVetStructTag



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HttpServerConfiguration {
/// Cert contains either a file to a certificate, or the certificate itself in PEM format to use as a server certificate.
    #[serde(rename = "cert")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cert: Option<String>,

    #[serde(rename = "cipher")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cipher: Option<Vec<models::CipherSuite>>,

/// ClientCACert contains either a file or a certificate in PEM format to verify the connecting clients by.
    #[serde(rename = "clientcacert")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub clientcacert: Option<String>,

/// ECDHCurveList is a list of supported ECDHCurve
    #[serde(rename = "curves")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub curves: Option<Vec<models::EcdhCurve>>,

/// Key contains either a file name to a private key, or the private key itself in PEM format to use as a server key.
    #[serde(rename = "key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,

/// Listen contains the IP and port to listen on.
    #[serde(rename = "listen")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub listen: Option<String>,

    #[serde(rename = "tlsVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tls_version: Option<String>,

}


impl HttpServerConfiguration {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> HttpServerConfiguration {
        HttpServerConfiguration {
            cert: None,
            cipher: None,
            clientcacert: None,
            curves: None,
            key: None,
            listen: None,
            tls_version: None,
        }
    }
}

/// Converts the HttpServerConfiguration value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for HttpServerConfiguration {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.cert.as_ref().map(|cert| {
                [
                    "cert".to_string(),
                    cert.to_string(),
                ].join(",")
            }),


            self.cipher.as_ref().map(|cipher| {
                [
                    "cipher".to_string(),
                    cipher.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.clientcacert.as_ref().map(|clientcacert| {
                [
                    "clientcacert".to_string(),
                    clientcacert.to_string(),
                ].join(",")
            }),


            self.curves.as_ref().map(|curves| {
                [
                    "curves".to_string(),
                    curves.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.key.as_ref().map(|key| {
                [
                    "key".to_string(),
                    key.to_string(),
                ].join(",")
            }),


            self.listen.as_ref().map(|listen| {
                [
                    "listen".to_string(),
                    listen.to_string(),
                ].join(",")
            }),


            self.tls_version.as_ref().map(|tls_version| {
                [
                    "tlsVersion".to_string(),
                    tls_version.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HttpServerConfiguration value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HttpServerConfiguration {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cert: Vec<String>,
            pub cipher: Vec<Vec<models::CipherSuite>>,
            pub clientcacert: Vec<String>,
            pub curves: Vec<Vec<models::EcdhCurve>>,
            pub key: Vec<String>,
            pub listen: Vec<String>,
            pub tls_version: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing HttpServerConfiguration".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "cert" => intermediate_rep.cert.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "cipher" => return std::result::Result::Err("Parsing a container in this style is not supported in HttpServerConfiguration".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "clientcacert" => intermediate_rep.clientcacert.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "curves" => return std::result::Result::Err("Parsing a container in this style is not supported in HttpServerConfiguration".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "key" => intermediate_rep.key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "listen" => intermediate_rep.listen.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tlsVersion" => intermediate_rep.tls_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing HttpServerConfiguration".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HttpServerConfiguration {
            cert: intermediate_rep.cert.into_iter().next(),
            cipher: intermediate_rep.cipher.into_iter().next(),
            clientcacert: intermediate_rep.clientcacert.into_iter().next(),
            curves: intermediate_rep.curves.into_iter().next(),
            key: intermediate_rep.key.into_iter().next(),
            listen: intermediate_rep.listen.into_iter().next(),
            tls_version: intermediate_rep.tls_version.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HttpServerConfiguration> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<HttpServerConfiguration>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<HttpServerConfiguration>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for HttpServerConfiguration - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<HttpServerConfiguration> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <HttpServerConfiguration as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into HttpServerConfiguration - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// IDResponse Response to an API call that returns just an Id



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IdResponse {
/// The id of the newly created object.
    #[serde(rename = "Id")]
    pub id: String,

}


impl IdResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, ) -> IdResponse {
        IdResponse {
            id,
        }
    }
}

/// Converts the IdResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for IdResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("Id".to_string()),
            Some(self.id.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IdResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IdResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IdResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing IdResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IdResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "Id missing in IdResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IdResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<IdResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IdResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IdResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<IdResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IdResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IdResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ImageDeleteResponseItem image delete response item



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImageDeleteResponseItem {
/// The image ID of an image that was deleted
    #[serde(rename = "Deleted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<String>,

/// The image ID of an image that was untagged
    #[serde(rename = "Untagged")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub untagged: Option<String>,

}


impl ImageDeleteResponseItem {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ImageDeleteResponseItem {
        ImageDeleteResponseItem {
            deleted: None,
            untagged: None,
        }
    }
}

/// Converts the ImageDeleteResponseItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ImageDeleteResponseItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.deleted.as_ref().map(|deleted| {
                [
                    "Deleted".to_string(),
                    deleted.to_string(),
                ].join(",")
            }),


            self.untagged.as_ref().map(|untagged| {
                [
                    "Untagged".to_string(),
                    untagged.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImageDeleteResponseItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImageDeleteResponseItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub deleted: Vec<String>,
            pub untagged: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ImageDeleteResponseItem".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Deleted" => intermediate_rep.deleted.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Untagged" => intermediate_rep.untagged.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ImageDeleteResponseItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImageDeleteResponseItem {
            deleted: intermediate_rep.deleted.into_iter().next(),
            untagged: intermediate_rep.untagged.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImageDeleteResponseItem> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ImageDeleteResponseItem>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ImageDeleteResponseItem>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ImageDeleteResponseItem - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ImageDeleteResponseItem> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ImageDeleteResponseItem as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ImageDeleteResponseItem - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ImageSummary image summary



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImageSummary {
/// containers
    #[serde(rename = "Containers")]
    pub containers: i64,

/// created
    #[serde(rename = "Created")]
    pub created: i64,

/// Id
    #[serde(rename = "Id")]
    pub id: String,

/// labels
    #[serde(rename = "Labels")]
    pub labels: std::collections::HashMap<String, String>,

/// parent Id
    #[serde(rename = "ParentId")]
    pub parent_id: String,

/// repo digests
    #[serde(rename = "RepoDigests")]
    pub repo_digests: Vec<String>,

/// repo tags
    #[serde(rename = "RepoTags")]
    pub repo_tags: Vec<String>,

/// shared size
    #[serde(rename = "SharedSize")]
    pub shared_size: i64,

/// size
    #[serde(rename = "Size")]
    pub size: i64,

/// virtual size
    #[serde(rename = "VirtualSize")]
    pub virtual_size: i64,

}


impl ImageSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(containers: i64, created: i64, id: String, labels: std::collections::HashMap<String, String>, parent_id: String, repo_digests: Vec<String>, repo_tags: Vec<String>, shared_size: i64, size: i64, virtual_size: i64, ) -> ImageSummary {
        ImageSummary {
            containers,
            created,
            id,
            labels,
            parent_id,
            repo_digests,
            repo_tags,
            shared_size,
            size,
            virtual_size,
        }
    }
}

/// Converts the ImageSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ImageSummary {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("Containers".to_string()),
            Some(self.containers.to_string()),


            Some("Created".to_string()),
            Some(self.created.to_string()),


            Some("Id".to_string()),
            Some(self.id.to_string()),

            // Skipping Labels in query parameter serialization


            Some("ParentId".to_string()),
            Some(self.parent_id.to_string()),


            Some("RepoDigests".to_string()),
            Some(self.repo_digests.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("RepoTags".to_string()),
            Some(self.repo_tags.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("SharedSize".to_string()),
            Some(self.shared_size.to_string()),


            Some("Size".to_string()),
            Some(self.size.to_string()),


            Some("VirtualSize".to_string()),
            Some(self.virtual_size.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImageSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImageSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub containers: Vec<i64>,
            pub created: Vec<i64>,
            pub id: Vec<String>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub parent_id: Vec<String>,
            pub repo_digests: Vec<Vec<String>>,
            pub repo_tags: Vec<Vec<String>>,
            pub shared_size: Vec<i64>,
            pub size: Vec<i64>,
            pub virtual_size: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ImageSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Containers" => intermediate_rep.containers.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Created" => intermediate_rep.created.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in ImageSummary".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ParentId" => intermediate_rep.parent_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "RepoDigests" => return std::result::Result::Err("Parsing a container in this style is not supported in ImageSummary".to_string()),
                    "RepoTags" => return std::result::Result::Err("Parsing a container in this style is not supported in ImageSummary".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "SharedSize" => intermediate_rep.shared_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Size" => intermediate_rep.size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "VirtualSize" => intermediate_rep.virtual_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ImageSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImageSummary {
            containers: intermediate_rep.containers.into_iter().next().ok_or_else(|| "Containers missing in ImageSummary".to_string())?,
            created: intermediate_rep.created.into_iter().next().ok_or_else(|| "Created missing in ImageSummary".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "Id missing in ImageSummary".to_string())?,
            labels: intermediate_rep.labels.into_iter().next().ok_or_else(|| "Labels missing in ImageSummary".to_string())?,
            parent_id: intermediate_rep.parent_id.into_iter().next().ok_or_else(|| "ParentId missing in ImageSummary".to_string())?,
            repo_digests: intermediate_rep.repo_digests.into_iter().next().ok_or_else(|| "RepoDigests missing in ImageSummary".to_string())?,
            repo_tags: intermediate_rep.repo_tags.into_iter().next().ok_or_else(|| "RepoTags missing in ImageSummary".to_string())?,
            shared_size: intermediate_rep.shared_size.into_iter().next().ok_or_else(|| "SharedSize missing in ImageSummary".to_string())?,
            size: intermediate_rep.size.into_iter().next().ok_or_else(|| "Size missing in ImageSummary".to_string())?,
            virtual_size: intermediate_rep.virtual_size.into_iter().next().ok_or_else(|| "VirtualSize missing in ImageSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImageSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ImageSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ImageSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ImageSummary - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ImageSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ImageSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ImageSummary - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// +protobuf=true +protobuf.options.(gogoproto.goproto_stringer)=false +k8s:openapi-gen=true



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IntOrString {
    #[serde(rename = "IntVal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub int_val: Option<i32>,

    #[serde(rename = "StrVal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub str_val: Option<String>,

    #[serde(rename = "Type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<i64>,

}


impl IntOrString {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> IntOrString {
        IntOrString {
            int_val: None,
            str_val: None,
            r#type: None,
        }
    }
}

/// Converts the IntOrString value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for IntOrString {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.int_val.as_ref().map(|int_val| {
                [
                    "IntVal".to_string(),
                    int_val.to_string(),
                ].join(",")
            }),


            self.str_val.as_ref().map(|str_val| {
                [
                    "StrVal".to_string(),
                    str_val.to_string(),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "Type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IntOrString value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IntOrString {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub int_val: Vec<i32>,
            pub str_val: Vec<String>,
            pub r#type: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IntOrString".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "IntVal" => intermediate_rep.int_val.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StrVal" => intermediate_rep.str_val.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Type" => intermediate_rep.r#type.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing IntOrString".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IntOrString {
            int_val: intermediate_rep.int_val.into_iter().next(),
            str_val: intermediate_rep.str_val.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IntOrString> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<IntOrString>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IntOrString>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IntOrString - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<IntOrString> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IntOrString as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IntOrString - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IpcMode(String);

impl validator::Validate for IpcMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for IpcMode {
    fn from(x: String) -> Self {
        IpcMode(x)
    }
}

impl std::string::ToString for IpcMode {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for IpcMode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(IpcMode(x.to_string()))
    }
}

impl std::convert::From<IpcMode> for String {
    fn from(x: IpcMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for IpcMode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for IpcMode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IscsiVolumeSource {
/// whether support iSCSI Discovery CHAP authentication +optional
    #[serde(rename = "chapAuthDiscovery")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub chap_auth_discovery: Option<bool>,

/// whether support iSCSI Session CHAP authentication +optional
    #[serde(rename = "chapAuthSession")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub chap_auth_session: Option<bool>,

/// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine +optional
    #[serde(rename = "fsType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fs_type: Option<String>,

/// Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection. +optional
    #[serde(rename = "initiatorName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub initiator_name: Option<String>,

/// Target iSCSI Qualified Name.
    #[serde(rename = "iqn")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub iqn: Option<String>,

/// iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp). +optional
    #[serde(rename = "iscsiInterface")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub iscsi_interface: Option<String>,

/// iSCSI Target Lun number.
    #[serde(rename = "lun")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lun: Option<i32>,

/// iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260). +optional
    #[serde(rename = "portals")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub portals: Option<Vec<String>>,

/// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. +optional
    #[serde(rename = "readOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

    #[serde(rename = "secretRef")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_ref: Option<models::LocalObjectReference>,

/// iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
    #[serde(rename = "targetPortal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_portal: Option<String>,

}


impl IscsiVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> IscsiVolumeSource {
        IscsiVolumeSource {
            chap_auth_discovery: None,
            chap_auth_session: None,
            fs_type: None,
            initiator_name: None,
            iqn: None,
            iscsi_interface: None,
            lun: None,
            portals: None,
            read_only: None,
            secret_ref: None,
            target_portal: None,
        }
    }
}

/// Converts the IscsiVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for IscsiVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.chap_auth_discovery.as_ref().map(|chap_auth_discovery| {
                [
                    "chapAuthDiscovery".to_string(),
                    chap_auth_discovery.to_string(),
                ].join(",")
            }),


            self.chap_auth_session.as_ref().map(|chap_auth_session| {
                [
                    "chapAuthSession".to_string(),
                    chap_auth_session.to_string(),
                ].join(",")
            }),


            self.fs_type.as_ref().map(|fs_type| {
                [
                    "fsType".to_string(),
                    fs_type.to_string(),
                ].join(",")
            }),


            self.initiator_name.as_ref().map(|initiator_name| {
                [
                    "initiatorName".to_string(),
                    initiator_name.to_string(),
                ].join(",")
            }),


            self.iqn.as_ref().map(|iqn| {
                [
                    "iqn".to_string(),
                    iqn.to_string(),
                ].join(",")
            }),


            self.iscsi_interface.as_ref().map(|iscsi_interface| {
                [
                    "iscsiInterface".to_string(),
                    iscsi_interface.to_string(),
                ].join(",")
            }),


            self.lun.as_ref().map(|lun| {
                [
                    "lun".to_string(),
                    lun.to_string(),
                ].join(",")
            }),


            self.portals.as_ref().map(|portals| {
                [
                    "portals".to_string(),
                    portals.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.read_only.as_ref().map(|read_only| {
                [
                    "readOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),

            // Skipping secretRef in query parameter serialization


            self.target_portal.as_ref().map(|target_portal| {
                [
                    "targetPortal".to_string(),
                    target_portal.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IscsiVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IscsiVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub chap_auth_discovery: Vec<bool>,
            pub chap_auth_session: Vec<bool>,
            pub fs_type: Vec<String>,
            pub initiator_name: Vec<String>,
            pub iqn: Vec<String>,
            pub iscsi_interface: Vec<String>,
            pub lun: Vec<i32>,
            pub portals: Vec<Vec<String>>,
            pub read_only: Vec<bool>,
            pub secret_ref: Vec<models::LocalObjectReference>,
            pub target_portal: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IscsiVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "chapAuthDiscovery" => intermediate_rep.chap_auth_discovery.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "chapAuthSession" => intermediate_rep.chap_auth_session.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fsType" => intermediate_rep.fs_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "initiatorName" => intermediate_rep.initiator_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "iqn" => intermediate_rep.iqn.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "iscsiInterface" => intermediate_rep.iscsi_interface.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lun" => intermediate_rep.lun.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "portals" => return std::result::Result::Err("Parsing a container in this style is not supported in IscsiVolumeSource".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "readOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "secretRef" => intermediate_rep.secret_ref.push(<models::LocalObjectReference as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "targetPortal" => intermediate_rep.target_portal.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing IscsiVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IscsiVolumeSource {
            chap_auth_discovery: intermediate_rep.chap_auth_discovery.into_iter().next(),
            chap_auth_session: intermediate_rep.chap_auth_session.into_iter().next(),
            fs_type: intermediate_rep.fs_type.into_iter().next(),
            initiator_name: intermediate_rep.initiator_name.into_iter().next(),
            iqn: intermediate_rep.iqn.into_iter().next(),
            iscsi_interface: intermediate_rep.iscsi_interface.into_iter().next(),
            lun: intermediate_rep.lun.into_iter().next(),
            portals: intermediate_rep.portals.into_iter().next(),
            read_only: intermediate_rep.read_only.into_iter().next(),
            secret_ref: intermediate_rep.secret_ref.into_iter().next(),
            target_portal: intermediate_rep.target_portal.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IscsiVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<IscsiVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IscsiVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IscsiVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<IscsiVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IscsiVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IscsiVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Isolation represents the isolation technology of a container. The supported values are platform specific
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Isolation(String);

impl validator::Validate for Isolation {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for Isolation {
    fn from(x: String) -> Self {
        Isolation(x)
    }
}

impl std::string::ToString for Isolation {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for Isolation {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Isolation(x.to_string()))
    }
}

impl std::convert::From<Isolation> for String {
    fn from(x: Isolation) -> Self {
        x.0
    }
}

impl std::ops::Deref for Isolation {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Isolation {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct KeyToPath {
/// The key to project.
    #[serde(rename = "key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,

/// Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. +optional
    #[serde(rename = "mode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mode: Option<i32>,

/// The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
    #[serde(rename = "path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

}


impl KeyToPath {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> KeyToPath {
        KeyToPath {
            key: None,
            mode: None,
            path: None,
        }
    }
}

/// Converts the KeyToPath value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for KeyToPath {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.key.as_ref().map(|key| {
                [
                    "key".to_string(),
                    key.to_string(),
                ].join(",")
            }),


            self.mode.as_ref().map(|mode| {
                [
                    "mode".to_string(),
                    mode.to_string(),
                ].join(",")
            }),


            self.path.as_ref().map(|path| {
                [
                    "path".to_string(),
                    path.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a KeyToPath value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for KeyToPath {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub key: Vec<String>,
            pub mode: Vec<i32>,
            pub path: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing KeyToPath".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "key" => intermediate_rep.key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mode" => intermediate_rep.mode.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing KeyToPath".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(KeyToPath {
            key: intermediate_rep.key.into_iter().next(),
            mode: intermediate_rep.mode.into_iter().next(),
            path: intermediate_rep.path.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<KeyToPath> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<KeyToPath>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<KeyToPath>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for KeyToPath - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<KeyToPath> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <KeyToPath as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into KeyToPath - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// KubernetesConfig is the base configuration structure for Kubernetes



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct KubernetesConfig {
    #[serde(rename = "connection")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connection: Option<models::KubernetesConnectionConfig>,

    #[serde(rename = "pod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pod: Option<models::KubernetesPodConfig>,

    #[serde(rename = "timeouts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeouts: Option<models::KubernetesTimeoutConfig>,

}


impl KubernetesConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> KubernetesConfig {
        KubernetesConfig {
            connection: None,
            pod: None,
            timeouts: None,
        }
    }
}

/// Converts the KubernetesConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for KubernetesConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping connection in query parameter serialization

            // Skipping pod in query parameter serialization

            // Skipping timeouts in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a KubernetesConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for KubernetesConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub connection: Vec<models::KubernetesConnectionConfig>,
            pub pod: Vec<models::KubernetesPodConfig>,
            pub timeouts: Vec<models::KubernetesTimeoutConfig>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing KubernetesConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "connection" => intermediate_rep.connection.push(<models::KubernetesConnectionConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pod" => intermediate_rep.pod.push(<models::KubernetesPodConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "timeouts" => intermediate_rep.timeouts.push(<models::KubernetesTimeoutConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing KubernetesConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(KubernetesConfig {
            connection: intermediate_rep.connection.into_iter().next(),
            pod: intermediate_rep.pod.into_iter().next(),
            timeouts: intermediate_rep.timeouts.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<KubernetesConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<KubernetesConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<KubernetesConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for KubernetesConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<KubernetesConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <KubernetesConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into KubernetesConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// goland:noinspection GoVetStructTag



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct KubernetesConnectionConfig {
/// BearerToken contains a bearer (service) token for authentication.
    #[serde(rename = "bearerToken")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bearer_token: Option<String>,

/// BearerTokenFile points to a file containing a bearer (service) token for authentication. Set to /var/run/secrets/kubernetes.io/serviceaccount/token to use service token in a Kubernetes kubeConfigCluster.
    #[serde(rename = "bearerTokenFile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bearer_token_file: Option<String>,

/// Burst indicates the maximum burst for throttle.
    #[serde(rename = "burst")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub burst: Option<i64>,

/// CAData contains a PEM-encoded trusted root certificates for the server.
    #[serde(rename = "cacert")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cacert: Option<String>,

/// CAFile points to a file that contains the CA certificate for authentication.
    #[serde(rename = "cacertFile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cacert_file: Option<String>,

/// CertData contains a PEM-encoded certificate for TLS client certificate authentication.
    #[serde(rename = "cert")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cert: Option<String>,

/// CertFile points to a file that contains the client certificate used for authentication.
    #[serde(rename = "certFile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cert_file: Option<String>,

/// Host is a host string, a host:port pair, or a URL to the Kubernetes apiserver. Defaults to kubernetes.default.svc.
    #[serde(rename = "host")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host: Option<String>,

/// KeyData contains a PEM-encoded client key for TLS client certificate authentication.
    #[serde(rename = "key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,

/// KeyFile points to a file that contains the client key used for authentication.
    #[serde(rename = "keyFile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_file: Option<String>,

/// Password is the password for basic authentication.
    #[serde(rename = "password")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub password: Option<String>,

/// APIPath is a sub-path that points to the API root. Defaults to /api
    #[serde(rename = "path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

/// QPS indicates the maximum QPS to the master from this client. Defaults to 5.
    #[serde(rename = "qps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub qps: Option<f32>,

/// ServerName sets the server name to be set in the SNI and used by the client for TLS verification.
    #[serde(rename = "serverName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub server_name: Option<String>,

/// Username is the username for basic authentication.
    #[serde(rename = "username")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub username: Option<String>,

}


impl KubernetesConnectionConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> KubernetesConnectionConfig {
        KubernetesConnectionConfig {
            bearer_token: None,
            bearer_token_file: None,
            burst: None,
            cacert: None,
            cacert_file: None,
            cert: None,
            cert_file: None,
            host: None,
            key: None,
            key_file: None,
            password: None,
            path: None,
            qps: None,
            server_name: None,
            username: None,
        }
    }
}

/// Converts the KubernetesConnectionConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for KubernetesConnectionConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.bearer_token.as_ref().map(|bearer_token| {
                [
                    "bearerToken".to_string(),
                    bearer_token.to_string(),
                ].join(",")
            }),


            self.bearer_token_file.as_ref().map(|bearer_token_file| {
                [
                    "bearerTokenFile".to_string(),
                    bearer_token_file.to_string(),
                ].join(",")
            }),


            self.burst.as_ref().map(|burst| {
                [
                    "burst".to_string(),
                    burst.to_string(),
                ].join(",")
            }),


            self.cacert.as_ref().map(|cacert| {
                [
                    "cacert".to_string(),
                    cacert.to_string(),
                ].join(",")
            }),


            self.cacert_file.as_ref().map(|cacert_file| {
                [
                    "cacertFile".to_string(),
                    cacert_file.to_string(),
                ].join(",")
            }),


            self.cert.as_ref().map(|cert| {
                [
                    "cert".to_string(),
                    cert.to_string(),
                ].join(",")
            }),


            self.cert_file.as_ref().map(|cert_file| {
                [
                    "certFile".to_string(),
                    cert_file.to_string(),
                ].join(",")
            }),


            self.host.as_ref().map(|host| {
                [
                    "host".to_string(),
                    host.to_string(),
                ].join(",")
            }),


            self.key.as_ref().map(|key| {
                [
                    "key".to_string(),
                    key.to_string(),
                ].join(",")
            }),


            self.key_file.as_ref().map(|key_file| {
                [
                    "keyFile".to_string(),
                    key_file.to_string(),
                ].join(",")
            }),


            self.password.as_ref().map(|password| {
                [
                    "password".to_string(),
                    password.to_string(),
                ].join(",")
            }),


            self.path.as_ref().map(|path| {
                [
                    "path".to_string(),
                    path.to_string(),
                ].join(",")
            }),


            self.qps.as_ref().map(|qps| {
                [
                    "qps".to_string(),
                    qps.to_string(),
                ].join(",")
            }),


            self.server_name.as_ref().map(|server_name| {
                [
                    "serverName".to_string(),
                    server_name.to_string(),
                ].join(",")
            }),


            self.username.as_ref().map(|username| {
                [
                    "username".to_string(),
                    username.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a KubernetesConnectionConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for KubernetesConnectionConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub bearer_token: Vec<String>,
            pub bearer_token_file: Vec<String>,
            pub burst: Vec<i64>,
            pub cacert: Vec<String>,
            pub cacert_file: Vec<String>,
            pub cert: Vec<String>,
            pub cert_file: Vec<String>,
            pub host: Vec<String>,
            pub key: Vec<String>,
            pub key_file: Vec<String>,
            pub password: Vec<String>,
            pub path: Vec<String>,
            pub qps: Vec<f32>,
            pub server_name: Vec<String>,
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing KubernetesConnectionConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "bearerToken" => intermediate_rep.bearer_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "bearerTokenFile" => intermediate_rep.bearer_token_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "burst" => intermediate_rep.burst.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cacert" => intermediate_rep.cacert.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cacertFile" => intermediate_rep.cacert_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cert" => intermediate_rep.cert.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "certFile" => intermediate_rep.cert_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "host" => intermediate_rep.host.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "key" => intermediate_rep.key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "keyFile" => intermediate_rep.key_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "password" => intermediate_rep.password.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "qps" => intermediate_rep.qps.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "serverName" => intermediate_rep.server_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing KubernetesConnectionConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(KubernetesConnectionConfig {
            bearer_token: intermediate_rep.bearer_token.into_iter().next(),
            bearer_token_file: intermediate_rep.bearer_token_file.into_iter().next(),
            burst: intermediate_rep.burst.into_iter().next(),
            cacert: intermediate_rep.cacert.into_iter().next(),
            cacert_file: intermediate_rep.cacert_file.into_iter().next(),
            cert: intermediate_rep.cert.into_iter().next(),
            cert_file: intermediate_rep.cert_file.into_iter().next(),
            host: intermediate_rep.host.into_iter().next(),
            key: intermediate_rep.key.into_iter().next(),
            key_file: intermediate_rep.key_file.into_iter().next(),
            password: intermediate_rep.password.into_iter().next(),
            path: intermediate_rep.path.into_iter().next(),
            qps: intermediate_rep.qps.into_iter().next(),
            server_name: intermediate_rep.server_name.into_iter().next(),
            username: intermediate_rep.username.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<KubernetesConnectionConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<KubernetesConnectionConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<KubernetesConnectionConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for KubernetesConnectionConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<KubernetesConnectionConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <KubernetesConnectionConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into KubernetesConnectionConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// KubernetesExecutionModeConnection launches one container per SSH connection (default), while KubernetesExecutionModeSession launches one container per SSH session.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct KubernetesExecutionMode(String);

impl validator::Validate for KubernetesExecutionMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for KubernetesExecutionMode {
    fn from(x: String) -> Self {
        KubernetesExecutionMode(x)
    }
}

impl std::string::ToString for KubernetesExecutionMode {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for KubernetesExecutionMode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(KubernetesExecutionMode(x.to_string()))
    }
}

impl std::convert::From<KubernetesExecutionMode> for String {
    fn from(x: KubernetesExecutionMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for KubernetesExecutionMode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for KubernetesExecutionMode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// goland:noinspection GoVetStructTag



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct KubernetesPodConfig {
/// AgentPath contains the path to the ContainerSSH Guest Agent.
    #[serde(rename = "agentPath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub agent_path: Option<String>,

/// ConsoleContainerNumber specifies the container to attach the running process to. Defaults to 0.
    #[serde(rename = "consoleContainerNumber")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub console_container_number: Option<i64>,

/// DisableAgent disables using the ContainerSSH Guest Agent.
    #[serde(rename = "disableAgent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub disable_agent: Option<bool>,

/// ExposeAuthMetadataAsAnnotations causes the specified metadata entries received from the authentication process to be exposed in the pod annotations. They are provided as a map, where the key is the authentication metadata entry name and the value is the annotation name. The annotation name must conform to Kubernetes annotation name requirements or the pod will not start. The default is to expose no annotations.
    #[serde(rename = "exposeAuthMetadataAsAnnotations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expose_auth_metadata_as_annotations: Option<std::collections::HashMap<String, String>>,

/// ExposeAuthMetadataAsEnv causes the specified metadata entries received from the authentication process to be exposed as environment variables. They are provided as a map, where the key is the authentication metadata entry name and the value is the environment variable. The default is to expose no authentication metadata.
    #[serde(rename = "exposeAuthMetadataAsEnv")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expose_auth_metadata_as_env: Option<std::collections::HashMap<String, String>>,

/// ExposeAuthMetadataAsLabels causes the specified metadata entries received from the authentication process to be exposed in the pod labels. They are provided as a map, where the key is the authentication metadata entry name and the value is the label name. The label name must conform to Kubernetes label name requirements or the pod will not start. The default is to expose no labels.
    #[serde(rename = "exposeAuthMetadataAsLabels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expose_auth_metadata_as_labels: Option<std::collections::HashMap<String, String>>,

/// IdleCommand contains the command to run as the first process in the container. Other commands are executed using the \"exec\" method.
    #[serde(rename = "idleCommand")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub idle_command: Option<Vec<String>>,

    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<models::ObjectMeta>,

/// KubernetesExecutionModeConnection launches one container per SSH connection (default), while KubernetesExecutionModeSession launches one container per SSH session.
    #[serde(rename = "mode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mode: Option<String>,

/// ShellCommand is the command used for launching shells when the container. Required in KubernetesExecutionModeConnection and when the agent is used.
    #[serde(rename = "shellCommand")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shell_command: Option<Vec<String>>,

    #[serde(rename = "spec")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub spec: Option<models::PodSpec>,

/// Subsystems contains a map of subsystem names and the executable to launch.
    #[serde(rename = "subsystems")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subsystems: Option<std::collections::HashMap<String, String>>,

}


impl KubernetesPodConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> KubernetesPodConfig {
        KubernetesPodConfig {
            agent_path: None,
            console_container_number: None,
            disable_agent: None,
            expose_auth_metadata_as_annotations: None,
            expose_auth_metadata_as_env: None,
            expose_auth_metadata_as_labels: None,
            idle_command: None,
            metadata: None,
            mode: None,
            shell_command: None,
            spec: None,
            subsystems: None,
        }
    }
}

/// Converts the KubernetesPodConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for KubernetesPodConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.agent_path.as_ref().map(|agent_path| {
                [
                    "agentPath".to_string(),
                    agent_path.to_string(),
                ].join(",")
            }),


            self.console_container_number.as_ref().map(|console_container_number| {
                [
                    "consoleContainerNumber".to_string(),
                    console_container_number.to_string(),
                ].join(",")
            }),


            self.disable_agent.as_ref().map(|disable_agent| {
                [
                    "disableAgent".to_string(),
                    disable_agent.to_string(),
                ].join(",")
            }),

            // Skipping exposeAuthMetadataAsAnnotations in query parameter serialization

            // Skipping exposeAuthMetadataAsEnv in query parameter serialization

            // Skipping exposeAuthMetadataAsLabels in query parameter serialization


            self.idle_command.as_ref().map(|idle_command| {
                [
                    "idleCommand".to_string(),
                    idle_command.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping metadata in query parameter serialization


            self.mode.as_ref().map(|mode| {
                [
                    "mode".to_string(),
                    mode.to_string(),
                ].join(",")
            }),


            self.shell_command.as_ref().map(|shell_command| {
                [
                    "shellCommand".to_string(),
                    shell_command.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping spec in query parameter serialization

            // Skipping subsystems in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a KubernetesPodConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for KubernetesPodConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub agent_path: Vec<String>,
            pub console_container_number: Vec<i64>,
            pub disable_agent: Vec<bool>,
            pub expose_auth_metadata_as_annotations: Vec<std::collections::HashMap<String, String>>,
            pub expose_auth_metadata_as_env: Vec<std::collections::HashMap<String, String>>,
            pub expose_auth_metadata_as_labels: Vec<std::collections::HashMap<String, String>>,
            pub idle_command: Vec<Vec<String>>,
            pub metadata: Vec<models::ObjectMeta>,
            pub mode: Vec<String>,
            pub shell_command: Vec<Vec<String>>,
            pub spec: Vec<models::PodSpec>,
            pub subsystems: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing KubernetesPodConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "agentPath" => intermediate_rep.agent_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "consoleContainerNumber" => intermediate_rep.console_container_number.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "disableAgent" => intermediate_rep.disable_agent.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "exposeAuthMetadataAsAnnotations" => return std::result::Result::Err("Parsing a container in this style is not supported in KubernetesPodConfig".to_string()),
                    "exposeAuthMetadataAsEnv" => return std::result::Result::Err("Parsing a container in this style is not supported in KubernetesPodConfig".to_string()),
                    "exposeAuthMetadataAsLabels" => return std::result::Result::Err("Parsing a container in this style is not supported in KubernetesPodConfig".to_string()),
                    "idleCommand" => return std::result::Result::Err("Parsing a container in this style is not supported in KubernetesPodConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<models::ObjectMeta as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mode" => intermediate_rep.mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "shellCommand" => return std::result::Result::Err("Parsing a container in this style is not supported in KubernetesPodConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "spec" => intermediate_rep.spec.push(<models::PodSpec as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "subsystems" => return std::result::Result::Err("Parsing a container in this style is not supported in KubernetesPodConfig".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing KubernetesPodConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(KubernetesPodConfig {
            agent_path: intermediate_rep.agent_path.into_iter().next(),
            console_container_number: intermediate_rep.console_container_number.into_iter().next(),
            disable_agent: intermediate_rep.disable_agent.into_iter().next(),
            expose_auth_metadata_as_annotations: intermediate_rep.expose_auth_metadata_as_annotations.into_iter().next(),
            expose_auth_metadata_as_env: intermediate_rep.expose_auth_metadata_as_env.into_iter().next(),
            expose_auth_metadata_as_labels: intermediate_rep.expose_auth_metadata_as_labels.into_iter().next(),
            idle_command: intermediate_rep.idle_command.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
            mode: intermediate_rep.mode.into_iter().next(),
            shell_command: intermediate_rep.shell_command.into_iter().next(),
            spec: intermediate_rep.spec.into_iter().next(),
            subsystems: intermediate_rep.subsystems.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<KubernetesPodConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<KubernetesPodConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<KubernetesPodConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for KubernetesPodConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<KubernetesPodConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <KubernetesPodConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into KubernetesPodConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct KubernetesTimeoutConfig {
/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "commandStart")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub command_start: Option<i64>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "http")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub http: Option<i64>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "podStart")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pod_start: Option<i64>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "podStop")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pod_stop: Option<i64>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "signal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub signal: Option<i64>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "window")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub window: Option<i64>,

}


impl KubernetesTimeoutConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> KubernetesTimeoutConfig {
        KubernetesTimeoutConfig {
            command_start: None,
            http: None,
            pod_start: None,
            pod_stop: None,
            signal: None,
            window: None,
        }
    }
}

/// Converts the KubernetesTimeoutConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for KubernetesTimeoutConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.command_start.as_ref().map(|command_start| {
                [
                    "commandStart".to_string(),
                    command_start.to_string(),
                ].join(",")
            }),


            self.http.as_ref().map(|http| {
                [
                    "http".to_string(),
                    http.to_string(),
                ].join(",")
            }),


            self.pod_start.as_ref().map(|pod_start| {
                [
                    "podStart".to_string(),
                    pod_start.to_string(),
                ].join(",")
            }),


            self.pod_stop.as_ref().map(|pod_stop| {
                [
                    "podStop".to_string(),
                    pod_stop.to_string(),
                ].join(",")
            }),


            self.signal.as_ref().map(|signal| {
                [
                    "signal".to_string(),
                    signal.to_string(),
                ].join(",")
            }),


            self.window.as_ref().map(|window| {
                [
                    "window".to_string(),
                    window.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a KubernetesTimeoutConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for KubernetesTimeoutConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub command_start: Vec<i64>,
            pub http: Vec<i64>,
            pub pod_start: Vec<i64>,
            pub pod_stop: Vec<i64>,
            pub signal: Vec<i64>,
            pub window: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing KubernetesTimeoutConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "commandStart" => intermediate_rep.command_start.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "http" => intermediate_rep.http.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "podStart" => intermediate_rep.pod_start.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "podStop" => intermediate_rep.pod_stop.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "signal" => intermediate_rep.signal.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "window" => intermediate_rep.window.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing KubernetesTimeoutConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(KubernetesTimeoutConfig {
            command_start: intermediate_rep.command_start.into_iter().next(),
            http: intermediate_rep.http.into_iter().next(),
            pod_start: intermediate_rep.pod_start.into_iter().next(),
            pod_stop: intermediate_rep.pod_stop.into_iter().next(),
            signal: intermediate_rep.signal.into_iter().next(),
            window: intermediate_rep.window.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<KubernetesTimeoutConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<KubernetesTimeoutConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<KubernetesTimeoutConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for KubernetesTimeoutConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<KubernetesTimeoutConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <KubernetesTimeoutConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into KubernetesTimeoutConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects. +structType=atomic



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LabelSelector {
/// matchExpressions is a list of label selector requirements. The requirements are ANDed. +optional
    #[serde(rename = "matchExpressions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub match_expressions: Option<Vec<models::LabelSelectorRequirement>>,

/// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed. +optional
    #[serde(rename = "matchLabels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub match_labels: Option<std::collections::HashMap<String, String>>,

}


impl LabelSelector {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LabelSelector {
        LabelSelector {
            match_expressions: None,
            match_labels: None,
        }
    }
}

/// Converts the LabelSelector value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LabelSelector {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping matchExpressions in query parameter serialization

            // Skipping matchLabels in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LabelSelector value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LabelSelector {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub match_expressions: Vec<Vec<models::LabelSelectorRequirement>>,
            pub match_labels: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LabelSelector".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "matchExpressions" => return std::result::Result::Err("Parsing a container in this style is not supported in LabelSelector".to_string()),
                    "matchLabels" => return std::result::Result::Err("Parsing a container in this style is not supported in LabelSelector".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing LabelSelector".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LabelSelector {
            match_expressions: intermediate_rep.match_expressions.into_iter().next(),
            match_labels: intermediate_rep.match_labels.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LabelSelector> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LabelSelector>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LabelSelector>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LabelSelector - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LabelSelector> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LabelSelector as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LabelSelector - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LabelSelectorOperator(String);

impl validator::Validate for LabelSelectorOperator {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for LabelSelectorOperator {
    fn from(x: String) -> Self {
        LabelSelectorOperator(x)
    }
}

impl std::string::ToString for LabelSelectorOperator {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for LabelSelectorOperator {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(LabelSelectorOperator(x.to_string()))
    }
}

impl std::convert::From<LabelSelectorOperator> for String {
    fn from(x: LabelSelectorOperator) -> Self {
        x.0
    }
}

impl std::ops::Deref for LabelSelectorOperator {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for LabelSelectorOperator {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LabelSelectorRequirement {
/// key is the label key that the selector applies to. +patchMergeKey=key +patchStrategy=merge
    #[serde(rename = "key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,

    #[serde(rename = "operator")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub operator: Option<String>,

/// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. +optional
    #[serde(rename = "values")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub values: Option<Vec<String>>,

}


impl LabelSelectorRequirement {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LabelSelectorRequirement {
        LabelSelectorRequirement {
            key: None,
            operator: None,
            values: None,
        }
    }
}

/// Converts the LabelSelectorRequirement value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LabelSelectorRequirement {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.key.as_ref().map(|key| {
                [
                    "key".to_string(),
                    key.to_string(),
                ].join(",")
            }),


            self.operator.as_ref().map(|operator| {
                [
                    "operator".to_string(),
                    operator.to_string(),
                ].join(",")
            }),


            self.values.as_ref().map(|values| {
                [
                    "values".to_string(),
                    values.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LabelSelectorRequirement value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LabelSelectorRequirement {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub key: Vec<String>,
            pub operator: Vec<String>,
            pub values: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LabelSelectorRequirement".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "key" => intermediate_rep.key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "operator" => intermediate_rep.operator.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "values" => return std::result::Result::Err("Parsing a container in this style is not supported in LabelSelectorRequirement".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing LabelSelectorRequirement".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LabelSelectorRequirement {
            key: intermediate_rep.key.into_iter().next(),
            operator: intermediate_rep.operator.into_iter().next(),
            values: intermediate_rep.values.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LabelSelectorRequirement> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LabelSelectorRequirement>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LabelSelectorRequirement>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LabelSelectorRequirement - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LabelSelectorRequirement> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LabelSelectorRequirement as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LabelSelectorRequirement - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Lifecycle {
    #[serde(rename = "postStart")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub post_start: Option<models::LifecycleHandler>,

    #[serde(rename = "preStop")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pre_stop: Option<models::LifecycleHandler>,

}


impl Lifecycle {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Lifecycle {
        Lifecycle {
            post_start: None,
            pre_stop: None,
        }
    }
}

/// Converts the Lifecycle value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Lifecycle {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping postStart in query parameter serialization

            // Skipping preStop in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Lifecycle value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Lifecycle {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub post_start: Vec<models::LifecycleHandler>,
            pub pre_stop: Vec<models::LifecycleHandler>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Lifecycle".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "postStart" => intermediate_rep.post_start.push(<models::LifecycleHandler as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "preStop" => intermediate_rep.pre_stop.push(<models::LifecycleHandler as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Lifecycle".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Lifecycle {
            post_start: intermediate_rep.post_start.into_iter().next(),
            pre_stop: intermediate_rep.pre_stop.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Lifecycle> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Lifecycle>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Lifecycle>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Lifecycle - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Lifecycle> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Lifecycle as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Lifecycle - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// LifecycleHandler defines a specific action that should be taken in a lifecycle hook. One and only one of the fields, except TCPSocket must be specified.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LifecycleHandler {
    #[serde(rename = "exec")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exec: Option<models::ExecAction>,

    #[serde(rename = "httpGet")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub http_get: Option<models::HttpGetAction>,

    #[serde(rename = "tcpSocket")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tcp_socket: Option<models::TcpSocketAction>,

}


impl LifecycleHandler {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LifecycleHandler {
        LifecycleHandler {
            exec: None,
            http_get: None,
            tcp_socket: None,
        }
    }
}

/// Converts the LifecycleHandler value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LifecycleHandler {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping exec in query parameter serialization

            // Skipping httpGet in query parameter serialization

            // Skipping tcpSocket in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LifecycleHandler value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LifecycleHandler {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub exec: Vec<models::ExecAction>,
            pub http_get: Vec<models::HttpGetAction>,
            pub tcp_socket: Vec<models::TcpSocketAction>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LifecycleHandler".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "exec" => intermediate_rep.exec.push(<models::ExecAction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "httpGet" => intermediate_rep.http_get.push(<models::HttpGetAction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tcpSocket" => intermediate_rep.tcp_socket.push(<models::TcpSocketAction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LifecycleHandler".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LifecycleHandler {
            exec: intermediate_rep.exec.into_iter().next(),
            http_get: intermediate_rep.http_get.into_iter().next(),
            tcp_socket: intermediate_rep.tcp_socket.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LifecycleHandler> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LifecycleHandler>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LifecycleHandler>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LifecycleHandler - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LifecycleHandler> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LifecycleHandler as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LifecycleHandler - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace. +structType=atomic



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LocalObjectReference {
/// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid? +optional
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl LocalObjectReference {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LocalObjectReference {
        LocalObjectReference {
            name: None,
        }
    }
}

/// Converts the LocalObjectReference value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LocalObjectReference {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LocalObjectReference value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LocalObjectReference {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LocalObjectReference".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LocalObjectReference".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LocalObjectReference {
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LocalObjectReference> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LocalObjectReference>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LocalObjectReference>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LocalObjectReference - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LocalObjectReference> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LocalObjectReference as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LocalObjectReference - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LogConfig {
    #[serde(rename = "Config")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub config: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "Type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

}


impl LogConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LogConfig {
        LogConfig {
            config: None,
            r#type: None,
        }
    }
}

/// Converts the LogConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LogConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping Config in query parameter serialization


            self.r#type.as_ref().map(|r#type| {
                [
                    "Type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LogConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LogConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub config: Vec<std::collections::HashMap<String, String>>,
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LogConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Config" => return std::result::Result::Err("Parsing a container in this style is not supported in LogConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LogConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LogConfig {
            config: intermediate_rep.config.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LogConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LogConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LogConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LogConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LogConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LogConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LogConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ManagedFieldsEntry {
/// APIVersion defines the version of this resource that this field set applies to. The format is \"group/version\" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
    #[serde(rename = "apiVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_version: Option<String>,

/// FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: \"FieldsV1\"
    #[serde(rename = "fieldsType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fields_type: Option<String>,

/// Each key is either a '.' representing the field itself, and will always map to an empty set, or a string representing a sub-field or item. The string will follow one of these four formats: 'f:<name>', where <name> is the name of a field in a struct, or key in a map 'v:<value>', where <value> is the exact json formatted value of a list item 'i:<index>', where <index> is position of a item in a list 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values If a key maps to an empty Fields value, the field that key represents is part of the set.  The exact format is defined in sigs.k8s.io/structured-merge-diff +protobuf.options.(gogoproto.goproto_stringer)=false
    #[serde(rename = "fieldsV1")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fields_v1: Option<crate::types::Object>,

/// Manager is an identifier of the workflow managing these fields.
    #[serde(rename = "manager")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub manager: Option<String>,

    #[serde(rename = "operation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub operation: Option<String>,

/// Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.
    #[serde(rename = "subresource")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subresource: Option<String>,

/// Time is timestamp of when these fields were set. It should always be empty if Operation is 'Apply' +optional
    #[serde(rename = "time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub time: Option<String>,

}


impl ManagedFieldsEntry {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ManagedFieldsEntry {
        ManagedFieldsEntry {
            api_version: None,
            fields_type: None,
            fields_v1: None,
            manager: None,
            operation: None,
            subresource: None,
            time: None,
        }
    }
}

/// Converts the ManagedFieldsEntry value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ManagedFieldsEntry {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.api_version.as_ref().map(|api_version| {
                [
                    "apiVersion".to_string(),
                    api_version.to_string(),
                ].join(",")
            }),


            self.fields_type.as_ref().map(|fields_type| {
                [
                    "fieldsType".to_string(),
                    fields_type.to_string(),
                ].join(",")
            }),

            // Skipping fieldsV1 in query parameter serialization


            self.manager.as_ref().map(|manager| {
                [
                    "manager".to_string(),
                    manager.to_string(),
                ].join(",")
            }),


            self.operation.as_ref().map(|operation| {
                [
                    "operation".to_string(),
                    operation.to_string(),
                ].join(",")
            }),


            self.subresource.as_ref().map(|subresource| {
                [
                    "subresource".to_string(),
                    subresource.to_string(),
                ].join(",")
            }),


            self.time.as_ref().map(|time| {
                [
                    "time".to_string(),
                    time.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ManagedFieldsEntry value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ManagedFieldsEntry {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub api_version: Vec<String>,
            pub fields_type: Vec<String>,
            pub fields_v1: Vec<crate::types::Object>,
            pub manager: Vec<String>,
            pub operation: Vec<String>,
            pub subresource: Vec<String>,
            pub time: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ManagedFieldsEntry".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "apiVersion" => intermediate_rep.api_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fieldsType" => intermediate_rep.fields_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fieldsV1" => intermediate_rep.fields_v1.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "manager" => intermediate_rep.manager.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "operation" => intermediate_rep.operation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "subresource" => intermediate_rep.subresource.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "time" => intermediate_rep.time.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ManagedFieldsEntry".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ManagedFieldsEntry {
            api_version: intermediate_rep.api_version.into_iter().next(),
            fields_type: intermediate_rep.fields_type.into_iter().next(),
            fields_v1: intermediate_rep.fields_v1.into_iter().next(),
            manager: intermediate_rep.manager.into_iter().next(),
            operation: intermediate_rep.operation.into_iter().next(),
            subresource: intermediate_rep.subresource.into_iter().next(),
            time: intermediate_rep.time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ManagedFieldsEntry> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ManagedFieldsEntry>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ManagedFieldsEntry>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ManagedFieldsEntry - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ManagedFieldsEntry> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ManagedFieldsEntry as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ManagedFieldsEntry - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ManagedFieldsOperationType(String);

impl validator::Validate for ManagedFieldsOperationType {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for ManagedFieldsOperationType {
    fn from(x: String) -> Self {
        ManagedFieldsOperationType(x)
    }
}

impl std::string::ToString for ManagedFieldsOperationType {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for ManagedFieldsOperationType {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(ManagedFieldsOperationType(x.to_string()))
    }
}

impl std::convert::From<ManagedFieldsOperationType> for String {
    fn from(x: ManagedFieldsOperationType) -> Self {
        x.0
    }
}

impl std::ops::Deref for ManagedFieldsOperationType {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for ManagedFieldsOperationType {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MetadataValue {
/// Sensitive indicates that the metadata value contains sensitive data and should not be transmitted to servers unnecessarily.
    #[serde(rename = "sensitive")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sensitive: Option<bool>,

/// Value contains the string for the current value.
    #[serde(rename = "value")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,

}


impl MetadataValue {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> MetadataValue {
        MetadataValue {
            sensitive: None,
            value: None,
        }
    }
}

/// Converts the MetadataValue value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MetadataValue {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.sensitive.as_ref().map(|sensitive| {
                [
                    "sensitive".to_string(),
                    sensitive.to_string(),
                ].join(",")
            }),


            self.value.as_ref().map(|value| {
                [
                    "value".to_string(),
                    value.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MetadataValue value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MetadataValue {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub sensitive: Vec<bool>,
            pub value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MetadataValue".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sensitive" => intermediate_rep.sensitive.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MetadataValue".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MetadataValue {
            sensitive: intermediate_rep.sensitive.into_iter().next(),
            value: intermediate_rep.value.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MetadataValue> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MetadataValue>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MetadataValue>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MetadataValue - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MetadataValue> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MetadataValue as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MetadataValue - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Mount {
    #[serde(rename = "BindOptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bind_options: Option<models::BindOptions>,

    #[serde(rename = "Consistency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub consistency: Option<String>,

    #[serde(rename = "ReadOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

/// Source specifies the name of the mount. Depending on mount type, this may be a volume name or a host path, or even ignored. Source is not supported for tmpfs (must be an empty value)
    #[serde(rename = "Source")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub source: Option<String>,

    #[serde(rename = "Target")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub target: Option<String>,

    #[serde(rename = "TmpfsOptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tmpfs_options: Option<models::TmpfsOptions>,

    #[serde(rename = "Type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<i64>,

    #[serde(rename = "VolumeOptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_options: Option<models::VolumeOptions>,

}


impl Mount {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Mount {
        Mount {
            bind_options: None,
            consistency: None,
            read_only: None,
            source: None,
            target: None,
            tmpfs_options: None,
            r#type: None,
            volume_options: None,
        }
    }
}

/// Converts the Mount value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Mount {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping BindOptions in query parameter serialization


            self.consistency.as_ref().map(|consistency| {
                [
                    "Consistency".to_string(),
                    consistency.to_string(),
                ].join(",")
            }),


            self.read_only.as_ref().map(|read_only| {
                [
                    "ReadOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),


            self.source.as_ref().map(|source| {
                [
                    "Source".to_string(),
                    source.to_string(),
                ].join(",")
            }),


            self.target.as_ref().map(|target| {
                [
                    "Target".to_string(),
                    target.to_string(),
                ].join(",")
            }),

            // Skipping TmpfsOptions in query parameter serialization


            self.r#type.as_ref().map(|r#type| {
                [
                    "Type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),

            // Skipping VolumeOptions in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Mount value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Mount {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub bind_options: Vec<models::BindOptions>,
            pub consistency: Vec<String>,
            pub read_only: Vec<bool>,
            pub source: Vec<String>,
            pub target: Vec<String>,
            pub tmpfs_options: Vec<models::TmpfsOptions>,
            pub r#type: Vec<i64>,
            pub volume_options: Vec<models::VolumeOptions>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Mount".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "BindOptions" => intermediate_rep.bind_options.push(<models::BindOptions as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Consistency" => intermediate_rep.consistency.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ReadOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Source" => intermediate_rep.source.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Target" => intermediate_rep.target.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "TmpfsOptions" => intermediate_rep.tmpfs_options.push(<models::TmpfsOptions as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Type" => intermediate_rep.r#type.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "VolumeOptions" => intermediate_rep.volume_options.push(<models::VolumeOptions as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Mount".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Mount {
            bind_options: intermediate_rep.bind_options.into_iter().next(),
            consistency: intermediate_rep.consistency.into_iter().next(),
            read_only: intermediate_rep.read_only.into_iter().next(),
            source: intermediate_rep.source.into_iter().next(),
            target: intermediate_rep.target.into_iter().next(),
            tmpfs_options: intermediate_rep.tmpfs_options.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            volume_options: intermediate_rep.volume_options.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Mount> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Mount>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Mount>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Mount - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Mount> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Mount as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Mount - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// +enum
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MountPropagationMode(String);

impl validator::Validate for MountPropagationMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for MountPropagationMode {
    fn from(x: String) -> Self {
        MountPropagationMode(x)
    }
}

impl std::string::ToString for MountPropagationMode {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for MountPropagationMode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(MountPropagationMode(x.to_string()))
    }
}

impl std::convert::From<MountPropagationMode> for String {
    fn from(x: MountPropagationMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for MountPropagationMode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for MountPropagationMode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkMode(String);

impl validator::Validate for NetworkMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for NetworkMode {
    fn from(x: String) -> Self {
        NetworkMode(x)
    }
}

impl std::string::ToString for NetworkMode {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for NetworkMode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NetworkMode(x.to_string()))
    }
}

impl std::convert::From<NetworkMode> for String {
    fn from(x: NetworkMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for NetworkMode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NetworkMode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// NetworkingConfig represents the container's networking configuration for each of its interfaces Carries the networking configs specified in the `docker run` and `docker network connect` commands



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkingConfig {
    #[serde(rename = "EndpointsConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub endpoints_config: Option<std::collections::HashMap<String, models::EndpointSettings>>,

}


impl NetworkingConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkingConfig {
        NetworkingConfig {
            endpoints_config: None,
        }
    }
}

/// Converts the NetworkingConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NetworkingConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping EndpointsConfig in query parameter serialization
            // Skipping EndpointsConfig in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkingConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkingConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub endpoints_config: Vec<std::collections::HashMap<String, models::EndpointSettings>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkingConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "EndpointsConfig" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkingConfig".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkingConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkingConfig {
            endpoints_config: intermediate_rep.endpoints_config.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkingConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkingConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkingConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkingConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkingConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkingConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkingConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// NFS volumes do not support ownership management or SELinux relabeling.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfsVolumeSource {
/// Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
    #[serde(rename = "path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

/// ReadOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs +optional
    #[serde(rename = "readOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

/// Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
    #[serde(rename = "server")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub server: Option<String>,

}


impl NfsVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NfsVolumeSource {
        NfsVolumeSource {
            path: None,
            read_only: None,
            server: None,
        }
    }
}

/// Converts the NfsVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NfsVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.path.as_ref().map(|path| {
                [
                    "path".to_string(),
                    path.to_string(),
                ].join(",")
            }),


            self.read_only.as_ref().map(|read_only| {
                [
                    "readOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),


            self.server.as_ref().map(|server| {
                [
                    "server".to_string(),
                    server.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NfsVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NfsVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub path: Vec<String>,
            pub read_only: Vec<bool>,
            pub server: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NfsVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "readOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "server" => intermediate_rep.server.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing NfsVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NfsVolumeSource {
            path: intermediate_rep.path.into_iter().next(),
            read_only: intermediate_rep.read_only.into_iter().next(),
            server: intermediate_rep.server.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NfsVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NfsVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NfsVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NfsVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NfsVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NfsVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NfsVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NodeAffinity {
/// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred. +optional
    #[serde(rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<models::PreferredSchedulingTerm>>,

    #[serde(rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_during_scheduling_ignored_during_execution: Option<models::NodeSelector>,

}


impl NodeAffinity {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NodeAffinity {
        NodeAffinity {
            preferred_during_scheduling_ignored_during_execution: None,
            required_during_scheduling_ignored_during_execution: None,
        }
    }
}

/// Converts the NodeAffinity value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NodeAffinity {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping preferredDuringSchedulingIgnoredDuringExecution in query parameter serialization

            // Skipping requiredDuringSchedulingIgnoredDuringExecution in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NodeAffinity value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NodeAffinity {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub preferred_during_scheduling_ignored_during_execution: Vec<Vec<models::PreferredSchedulingTerm>>,
            pub required_during_scheduling_ignored_during_execution: Vec<models::NodeSelector>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NodeAffinity".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "preferredDuringSchedulingIgnoredDuringExecution" => return std::result::Result::Err("Parsing a container in this style is not supported in NodeAffinity".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "requiredDuringSchedulingIgnoredDuringExecution" => intermediate_rep.required_during_scheduling_ignored_during_execution.push(<models::NodeSelector as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing NodeAffinity".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NodeAffinity {
            preferred_during_scheduling_ignored_during_execution: intermediate_rep.preferred_during_scheduling_ignored_during_execution.into_iter().next(),
            required_during_scheduling_ignored_during_execution: intermediate_rep.required_during_scheduling_ignored_during_execution.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NodeAffinity> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NodeAffinity>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NodeAffinity>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NodeAffinity - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NodeAffinity> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NodeAffinity as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NodeAffinity - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms. +structType=atomic



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NodeSelector {
/// Required. A list of node selector terms. The terms are ORed.
    #[serde(rename = "nodeSelectorTerms")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_selector_terms: Option<Vec<models::NodeSelectorTerm>>,

}


impl NodeSelector {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NodeSelector {
        NodeSelector {
            node_selector_terms: None,
        }
    }
}

/// Converts the NodeSelector value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NodeSelector {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping nodeSelectorTerms in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NodeSelector value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NodeSelector {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub node_selector_terms: Vec<Vec<models::NodeSelectorTerm>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NodeSelector".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "nodeSelectorTerms" => return std::result::Result::Err("Parsing a container in this style is not supported in NodeSelector".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing NodeSelector".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NodeSelector {
            node_selector_terms: intermediate_rep.node_selector_terms.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NodeSelector> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NodeSelector>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NodeSelector>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NodeSelector - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NodeSelector> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NodeSelector as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NodeSelector - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A node selector operator is the set of operators that can be used in a node selector requirement. +enum
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NodeSelectorOperator(String);

impl validator::Validate for NodeSelectorOperator {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for NodeSelectorOperator {
    fn from(x: String) -> Self {
        NodeSelectorOperator(x)
    }
}

impl std::string::ToString for NodeSelectorOperator {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for NodeSelectorOperator {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NodeSelectorOperator(x.to_string()))
    }
}

impl std::convert::From<NodeSelectorOperator> for String {
    fn from(x: NodeSelectorOperator) -> Self {
        x.0
    }
}

impl std::ops::Deref for NodeSelectorOperator {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NodeSelectorOperator {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NodeSelectorRequirement {
/// The label key that the selector applies to.
    #[serde(rename = "key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,

/// A node selector operator is the set of operators that can be used in a node selector requirement. +enum
    #[serde(rename = "operator")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub operator: Option<String>,

/// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch. +optional
    #[serde(rename = "values")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub values: Option<Vec<String>>,

}


impl NodeSelectorRequirement {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NodeSelectorRequirement {
        NodeSelectorRequirement {
            key: None,
            operator: None,
            values: None,
        }
    }
}

/// Converts the NodeSelectorRequirement value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NodeSelectorRequirement {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.key.as_ref().map(|key| {
                [
                    "key".to_string(),
                    key.to_string(),
                ].join(",")
            }),


            self.operator.as_ref().map(|operator| {
                [
                    "operator".to_string(),
                    operator.to_string(),
                ].join(",")
            }),


            self.values.as_ref().map(|values| {
                [
                    "values".to_string(),
                    values.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NodeSelectorRequirement value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NodeSelectorRequirement {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub key: Vec<String>,
            pub operator: Vec<String>,
            pub values: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NodeSelectorRequirement".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "key" => intermediate_rep.key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "operator" => intermediate_rep.operator.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "values" => return std::result::Result::Err("Parsing a container in this style is not supported in NodeSelectorRequirement".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing NodeSelectorRequirement".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NodeSelectorRequirement {
            key: intermediate_rep.key.into_iter().next(),
            operator: intermediate_rep.operator.into_iter().next(),
            values: intermediate_rep.values.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NodeSelectorRequirement> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NodeSelectorRequirement>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NodeSelectorRequirement>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NodeSelectorRequirement - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NodeSelectorRequirement> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NodeSelectorRequirement as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NodeSelectorRequirement - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm. +structType=atomic



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NodeSelectorTerm {
/// A list of node selector requirements by node's labels. +optional
    #[serde(rename = "matchExpressions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub match_expressions: Option<Vec<models::NodeSelectorRequirement>>,

/// A list of node selector requirements by node's fields. +optional
    #[serde(rename = "matchFields")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub match_fields: Option<Vec<models::NodeSelectorRequirement>>,

}


impl NodeSelectorTerm {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NodeSelectorTerm {
        NodeSelectorTerm {
            match_expressions: None,
            match_fields: None,
        }
    }
}

/// Converts the NodeSelectorTerm value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NodeSelectorTerm {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping matchExpressions in query parameter serialization

            // Skipping matchFields in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NodeSelectorTerm value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NodeSelectorTerm {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub match_expressions: Vec<Vec<models::NodeSelectorRequirement>>,
            pub match_fields: Vec<Vec<models::NodeSelectorRequirement>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NodeSelectorTerm".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "matchExpressions" => return std::result::Result::Err("Parsing a container in this style is not supported in NodeSelectorTerm".to_string()),
                    "matchFields" => return std::result::Result::Err("Parsing a container in this style is not supported in NodeSelectorTerm".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing NodeSelectorTerm".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NodeSelectorTerm {
            match_expressions: intermediate_rep.match_expressions.into_iter().next(),
            match_fields: intermediate_rep.match_fields.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NodeSelectorTerm> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NodeSelectorTerm>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NodeSelectorTerm>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NodeSelectorTerm - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NodeSelectorTerm> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NodeSelectorTerm as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NodeSelectorTerm - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// +structType=atomic



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ObjectFieldSelector {
/// Version of the schema the FieldPath is written in terms of, defaults to \"v1\". +optional
    #[serde(rename = "apiVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_version: Option<String>,

/// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub field_path: Option<String>,

}


impl ObjectFieldSelector {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ObjectFieldSelector {
        ObjectFieldSelector {
            api_version: None,
            field_path: None,
        }
    }
}

/// Converts the ObjectFieldSelector value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ObjectFieldSelector {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.api_version.as_ref().map(|api_version| {
                [
                    "apiVersion".to_string(),
                    api_version.to_string(),
                ].join(",")
            }),


            self.field_path.as_ref().map(|field_path| {
                [
                    "fieldPath".to_string(),
                    field_path.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ObjectFieldSelector value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ObjectFieldSelector {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub api_version: Vec<String>,
            pub field_path: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ObjectFieldSelector".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "apiVersion" => intermediate_rep.api_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fieldPath" => intermediate_rep.field_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ObjectFieldSelector".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ObjectFieldSelector {
            api_version: intermediate_rep.api_version.into_iter().next(),
            field_path: intermediate_rep.field_path.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ObjectFieldSelector> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ObjectFieldSelector>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ObjectFieldSelector>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ObjectFieldSelector - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ObjectFieldSelector> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ObjectFieldSelector as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ObjectFieldSelector - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ObjectMeta {
/// Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations +optional
    #[serde(rename = "annotations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotations: Option<std::collections::HashMap<String, String>>,

/// The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request. +optional
    #[serde(rename = "clusterName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cluster_name: Option<String>,

/// CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.  Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata +optional
    #[serde(rename = "creationTimestamp")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub creation_timestamp: Option<String>,

/// Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only. +optional
    #[serde(rename = "deletionGracePeriodSeconds")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletion_grace_period_seconds: Option<i64>,

/// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.  Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata +optional
    #[serde(rename = "deletionTimestamp")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletion_timestamp: Option<String>,

/// Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. +optional +patchStrategy=merge
    #[serde(rename = "finalizers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub finalizers: Option<Vec<String>>,

/// GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.  If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).  Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency +optional
    #[serde(rename = "generateName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub generate_name: Option<String>,

/// A sequence number representing a specific generation of the desired state. Populated by the system. Read-only. +optional
    #[serde(rename = "generation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub generation: Option<i64>,

/// Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels +optional
    #[serde(rename = "labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

/// ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like \"ci-cd\". The set of fields is always in the version that the workflow used when modifying the object.  +optional
    #[serde(rename = "managedFields")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub managed_fields: Option<Vec<models::ManagedFieldsEntry>>,

/// Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names +optional
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.  Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces +optional
    #[serde(rename = "namespace")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub namespace: Option<String>,

/// List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. +optional +patchMergeKey=uid +patchStrategy=merge
    #[serde(rename = "ownerReferences")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner_references: Option<Vec<models::OwnerReference>>,

/// An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.  Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency +optional
    #[serde(rename = "resourceVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resource_version: Option<String>,

/// SelfLink is a URL representing this object. Populated by the system. Read-only.  DEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release. +optional
    #[serde(rename = "selfLink")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub self_link: Option<String>,

/// UID is a type that holds unique ID values, including UUIDs.  Because we don't ONLY use UUIDs, this is an alias to string.  Being a type captures intent and helps make sure that UIDs and names do not get conflated.
    #[serde(rename = "uid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub uid: Option<String>,

}


impl ObjectMeta {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ObjectMeta {
        ObjectMeta {
            annotations: None,
            cluster_name: None,
            creation_timestamp: None,
            deletion_grace_period_seconds: None,
            deletion_timestamp: None,
            finalizers: None,
            generate_name: None,
            generation: None,
            labels: None,
            managed_fields: None,
            name: None,
            namespace: None,
            owner_references: None,
            resource_version: None,
            self_link: None,
            uid: None,
        }
    }
}

/// Converts the ObjectMeta value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ObjectMeta {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping annotations in query parameter serialization


            self.cluster_name.as_ref().map(|cluster_name| {
                [
                    "clusterName".to_string(),
                    cluster_name.to_string(),
                ].join(",")
            }),


            self.creation_timestamp.as_ref().map(|creation_timestamp| {
                [
                    "creationTimestamp".to_string(),
                    creation_timestamp.to_string(),
                ].join(",")
            }),


            self.deletion_grace_period_seconds.as_ref().map(|deletion_grace_period_seconds| {
                [
                    "deletionGracePeriodSeconds".to_string(),
                    deletion_grace_period_seconds.to_string(),
                ].join(",")
            }),


            self.deletion_timestamp.as_ref().map(|deletion_timestamp| {
                [
                    "deletionTimestamp".to_string(),
                    deletion_timestamp.to_string(),
                ].join(",")
            }),


            self.finalizers.as_ref().map(|finalizers| {
                [
                    "finalizers".to_string(),
                    finalizers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.generate_name.as_ref().map(|generate_name| {
                [
                    "generateName".to_string(),
                    generate_name.to_string(),
                ].join(",")
            }),


            self.generation.as_ref().map(|generation| {
                [
                    "generation".to_string(),
                    generation.to_string(),
                ].join(",")
            }),

            // Skipping labels in query parameter serialization

            // Skipping managedFields in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.namespace.as_ref().map(|namespace| {
                [
                    "namespace".to_string(),
                    namespace.to_string(),
                ].join(",")
            }),

            // Skipping ownerReferences in query parameter serialization


            self.resource_version.as_ref().map(|resource_version| {
                [
                    "resourceVersion".to_string(),
                    resource_version.to_string(),
                ].join(",")
            }),


            self.self_link.as_ref().map(|self_link| {
                [
                    "selfLink".to_string(),
                    self_link.to_string(),
                ].join(",")
            }),


            self.uid.as_ref().map(|uid| {
                [
                    "uid".to_string(),
                    uid.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ObjectMeta value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ObjectMeta {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub annotations: Vec<std::collections::HashMap<String, String>>,
            pub cluster_name: Vec<String>,
            pub creation_timestamp: Vec<String>,
            pub deletion_grace_period_seconds: Vec<i64>,
            pub deletion_timestamp: Vec<String>,
            pub finalizers: Vec<Vec<String>>,
            pub generate_name: Vec<String>,
            pub generation: Vec<i64>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub managed_fields: Vec<Vec<models::ManagedFieldsEntry>>,
            pub name: Vec<String>,
            pub namespace: Vec<String>,
            pub owner_references: Vec<Vec<models::OwnerReference>>,
            pub resource_version: Vec<String>,
            pub self_link: Vec<String>,
            pub uid: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ObjectMeta".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in ObjectMeta".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "clusterName" => intermediate_rep.cluster_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "creationTimestamp" => intermediate_rep.creation_timestamp.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deletionGracePeriodSeconds" => intermediate_rep.deletion_grace_period_seconds.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deletionTimestamp" => intermediate_rep.deletion_timestamp.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "finalizers" => return std::result::Result::Err("Parsing a container in this style is not supported in ObjectMeta".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "generateName" => intermediate_rep.generate_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "generation" => intermediate_rep.generation.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "labels" => return std::result::Result::Err("Parsing a container in this style is not supported in ObjectMeta".to_string()),
                    "managedFields" => return std::result::Result::Err("Parsing a container in this style is not supported in ObjectMeta".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "namespace" => intermediate_rep.namespace.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ownerReferences" => return std::result::Result::Err("Parsing a container in this style is not supported in ObjectMeta".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "resourceVersion" => intermediate_rep.resource_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "selfLink" => intermediate_rep.self_link.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "uid" => intermediate_rep.uid.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ObjectMeta".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ObjectMeta {
            annotations: intermediate_rep.annotations.into_iter().next(),
            cluster_name: intermediate_rep.cluster_name.into_iter().next(),
            creation_timestamp: intermediate_rep.creation_timestamp.into_iter().next(),
            deletion_grace_period_seconds: intermediate_rep.deletion_grace_period_seconds.into_iter().next(),
            deletion_timestamp: intermediate_rep.deletion_timestamp.into_iter().next(),
            finalizers: intermediate_rep.finalizers.into_iter().next(),
            generate_name: intermediate_rep.generate_name.into_iter().next(),
            generation: intermediate_rep.generation.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            managed_fields: intermediate_rep.managed_fields.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            namespace: intermediate_rep.namespace.into_iter().next(),
            owner_references: intermediate_rep.owner_references.into_iter().next(),
            resource_version: intermediate_rep.resource_version.into_iter().next(),
            self_link: intermediate_rep.self_link.into_iter().next(),
            uid: intermediate_rep.uid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ObjectMeta> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ObjectMeta>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ObjectMeta>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ObjectMeta - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ObjectMeta> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ObjectMeta as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ObjectMeta - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OsName(String);

impl validator::Validate for OsName {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for OsName {
    fn from(x: String) -> Self {
        OsName(x)
    }
}

impl std::string::ToString for OsName {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for OsName {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(OsName(x.to_string()))
    }
}

impl std::convert::From<OsName> for String {
    fn from(x: OsName) -> Self {
        x.0
    }
}

impl std::ops::Deref for OsName {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for OsName {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field. +structType=atomic



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OwnerReference {
/// API version of the referent.
    #[serde(rename = "apiVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_version: Option<String>,

/// If true, AND if the owner has the \"foregroundDeletion\" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs \"delete\" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. +optional
    #[serde(rename = "blockOwnerDeletion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub block_owner_deletion: Option<bool>,

/// If true, this reference points to the managing controller. +optional
    #[serde(rename = "controller")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub controller: Option<bool>,

/// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kind: Option<String>,

/// Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// UID is a type that holds unique ID values, including UUIDs.  Because we don't ONLY use UUIDs, this is an alias to string.  Being a type captures intent and helps make sure that UIDs and names do not get conflated.
    #[serde(rename = "uid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub uid: Option<String>,

}


impl OwnerReference {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> OwnerReference {
        OwnerReference {
            api_version: None,
            block_owner_deletion: None,
            controller: None,
            kind: None,
            name: None,
            uid: None,
        }
    }
}

/// Converts the OwnerReference value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OwnerReference {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.api_version.as_ref().map(|api_version| {
                [
                    "apiVersion".to_string(),
                    api_version.to_string(),
                ].join(",")
            }),


            self.block_owner_deletion.as_ref().map(|block_owner_deletion| {
                [
                    "blockOwnerDeletion".to_string(),
                    block_owner_deletion.to_string(),
                ].join(",")
            }),


            self.controller.as_ref().map(|controller| {
                [
                    "controller".to_string(),
                    controller.to_string(),
                ].join(",")
            }),


            self.kind.as_ref().map(|kind| {
                [
                    "kind".to_string(),
                    kind.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.uid.as_ref().map(|uid| {
                [
                    "uid".to_string(),
                    uid.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OwnerReference value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OwnerReference {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub api_version: Vec<String>,
            pub block_owner_deletion: Vec<bool>,
            pub controller: Vec<bool>,
            pub kind: Vec<String>,
            pub name: Vec<String>,
            pub uid: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OwnerReference".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "apiVersion" => intermediate_rep.api_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "blockOwnerDeletion" => intermediate_rep.block_owner_deletion.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "controller" => intermediate_rep.controller.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "kind" => intermediate_rep.kind.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "uid" => intermediate_rep.uid.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OwnerReference".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OwnerReference {
            api_version: intermediate_rep.api_version.into_iter().next(),
            block_owner_deletion: intermediate_rep.block_owner_deletion.into_iter().next(),
            controller: intermediate_rep.controller.into_iter().next(),
            kind: intermediate_rep.kind.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            uid: intermediate_rep.uid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OwnerReference> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OwnerReference>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OwnerReference>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OwnerReference - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OwnerReference> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OwnerReference as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OwnerReference - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PasswordAuthRequest {
/// ClientVersion contains the version string the connecting client sent if any. May be empty if the client did not provide a client version.
    #[serde(rename = "clientVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_version: Option<String>,

/// ConnectionID is an opaque ID to identify the SSH connection in question.
    #[serde(rename = "connectionId")]
    pub connection_id: String,

/// Environment is a set of key-value pairs provided by the authentication or configuration system and may be exposed by the backend.
    #[serde(rename = "environment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<std::collections::HashMap<String, models::MetadataValue>>,

/// Files is a key-value pair of file names and their content set by the authentication or configuration system and consumed by the backend.
    #[serde(rename = "files")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub files: Option<std::collections::HashMap<String, models::BinaryMetadataValue>>,

/// Metadata is a set of key-value pairs that carry additional information from the authentication and configuration system to the backends. Backends can expose this information as container labels, environment variables, or other places.
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, models::MetadataValue>>,

/// Password the user provided for authentication.
    #[serde(rename = "passwordBase64")]
    pub password_base64: String,

/// RemoteAddress is the IP address and port of the user trying to authenticate.
    #[serde(rename = "remoteAddress")]
    pub remote_address: String,

/// Username is the username provided on login by the client. This may, but must not necessarily match the authenticated username.
    #[serde(rename = "username")]
    pub username: String,

}


impl PasswordAuthRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(connection_id: String, password_base64: String, remote_address: String, username: String, ) -> PasswordAuthRequest {
        PasswordAuthRequest {
            client_version: None,
            connection_id,
            environment: None,
            files: None,
            metadata: None,
            password_base64,
            remote_address,
            username,
        }
    }
}

/// Converts the PasswordAuthRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PasswordAuthRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.client_version.as_ref().map(|client_version| {
                [
                    "clientVersion".to_string(),
                    client_version.to_string(),
                ].join(",")
            }),


            Some("connectionId".to_string()),
            Some(self.connection_id.to_string()),

            // Skipping environment in query parameter serialization
            // Skipping environment in query parameter serialization

            // Skipping files in query parameter serialization
            // Skipping files in query parameter serialization

            // Skipping metadata in query parameter serialization
            // Skipping metadata in query parameter serialization


            Some("passwordBase64".to_string()),
            Some(self.password_base64.to_string()),


            Some("remoteAddress".to_string()),
            Some(self.remote_address.to_string()),


            Some("username".to_string()),
            Some(self.username.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PasswordAuthRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PasswordAuthRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub client_version: Vec<String>,
            pub connection_id: Vec<String>,
            pub environment: Vec<std::collections::HashMap<String, models::MetadataValue>>,
            pub files: Vec<std::collections::HashMap<String, models::BinaryMetadataValue>>,
            pub metadata: Vec<std::collections::HashMap<String, models::MetadataValue>>,
            pub password_base64: Vec<String>,
            pub remote_address: Vec<String>,
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PasswordAuthRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "clientVersion" => intermediate_rep.client_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "connectionId" => intermediate_rep.connection_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "environment" => return std::result::Result::Err("Parsing a container in this style is not supported in PasswordAuthRequest".to_string()),
                    "files" => return std::result::Result::Err("Parsing a container in this style is not supported in PasswordAuthRequest".to_string()),
                    "metadata" => return std::result::Result::Err("Parsing a container in this style is not supported in PasswordAuthRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "passwordBase64" => intermediate_rep.password_base64.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "remoteAddress" => intermediate_rep.remote_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PasswordAuthRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PasswordAuthRequest {
            client_version: intermediate_rep.client_version.into_iter().next(),
            connection_id: intermediate_rep.connection_id.into_iter().next().ok_or_else(|| "connectionId missing in PasswordAuthRequest".to_string())?,
            environment: intermediate_rep.environment.into_iter().next(),
            files: intermediate_rep.files.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
            password_base64: intermediate_rep.password_base64.into_iter().next().ok_or_else(|| "passwordBase64 missing in PasswordAuthRequest".to_string())?,
            remote_address: intermediate_rep.remote_address.into_iter().next().ok_or_else(|| "remoteAddress missing in PasswordAuthRequest".to_string())?,
            username: intermediate_rep.username.into_iter().next().ok_or_else(|| "username missing in PasswordAuthRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PasswordAuthRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PasswordAuthRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PasswordAuthRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PasswordAuthRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PasswordAuthRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PasswordAuthRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PasswordAuthRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// +enum
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PersistentVolumeAccessMode(String);

impl validator::Validate for PersistentVolumeAccessMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for PersistentVolumeAccessMode {
    fn from(x: String) -> Self {
        PersistentVolumeAccessMode(x)
    }
}

impl std::string::ToString for PersistentVolumeAccessMode {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for PersistentVolumeAccessMode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(PersistentVolumeAccessMode(x.to_string()))
    }
}

impl std::convert::From<PersistentVolumeAccessMode> for String {
    fn from(x: PersistentVolumeAccessMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for PersistentVolumeAccessMode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for PersistentVolumeAccessMode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a Source for provider-specific attributes



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PersistentVolumeClaimSpec {
/// AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 +optional
    #[serde(rename = "accessModes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub access_modes: Option<Vec<models::PersistentVolumeAccessMode>>,

    #[serde(rename = "dataSource")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data_source: Option<models::TypedLocalObjectReference>,

    #[serde(rename = "dataSourceRef")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data_source_ref: Option<models::TypedLocalObjectReference>,

    #[serde(rename = "resources")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resources: Option<models::ResourceRequirements>,

    #[serde(rename = "selector")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub selector: Option<models::LabelSelector>,

/// Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 +optional
    #[serde(rename = "storageClassName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_class_name: Option<String>,

/// +enum
    #[serde(rename = "volumeMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_mode: Option<String>,

/// VolumeName is the binding reference to the PersistentVolume backing this claim. +optional
    #[serde(rename = "volumeName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_name: Option<String>,

}


impl PersistentVolumeClaimSpec {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PersistentVolumeClaimSpec {
        PersistentVolumeClaimSpec {
            access_modes: None,
            data_source: None,
            data_source_ref: None,
            resources: None,
            selector: None,
            storage_class_name: None,
            volume_mode: None,
            volume_name: None,
        }
    }
}

/// Converts the PersistentVolumeClaimSpec value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PersistentVolumeClaimSpec {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.access_modes.as_ref().map(|access_modes| {
                [
                    "accessModes".to_string(),
                    access_modes.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping dataSource in query parameter serialization

            // Skipping dataSourceRef in query parameter serialization

            // Skipping resources in query parameter serialization

            // Skipping selector in query parameter serialization


            self.storage_class_name.as_ref().map(|storage_class_name| {
                [
                    "storageClassName".to_string(),
                    storage_class_name.to_string(),
                ].join(",")
            }),


            self.volume_mode.as_ref().map(|volume_mode| {
                [
                    "volumeMode".to_string(),
                    volume_mode.to_string(),
                ].join(",")
            }),


            self.volume_name.as_ref().map(|volume_name| {
                [
                    "volumeName".to_string(),
                    volume_name.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PersistentVolumeClaimSpec value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PersistentVolumeClaimSpec {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub access_modes: Vec<Vec<models::PersistentVolumeAccessMode>>,
            pub data_source: Vec<models::TypedLocalObjectReference>,
            pub data_source_ref: Vec<models::TypedLocalObjectReference>,
            pub resources: Vec<models::ResourceRequirements>,
            pub selector: Vec<models::LabelSelector>,
            pub storage_class_name: Vec<String>,
            pub volume_mode: Vec<String>,
            pub volume_name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PersistentVolumeClaimSpec".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "accessModes" => return std::result::Result::Err("Parsing a container in this style is not supported in PersistentVolumeClaimSpec".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "dataSource" => intermediate_rep.data_source.push(<models::TypedLocalObjectReference as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dataSourceRef" => intermediate_rep.data_source_ref.push(<models::TypedLocalObjectReference as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "resources" => intermediate_rep.resources.push(<models::ResourceRequirements as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "selector" => intermediate_rep.selector.push(<models::LabelSelector as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "storageClassName" => intermediate_rep.storage_class_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "volumeMode" => intermediate_rep.volume_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "volumeName" => intermediate_rep.volume_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PersistentVolumeClaimSpec".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PersistentVolumeClaimSpec {
            access_modes: intermediate_rep.access_modes.into_iter().next(),
            data_source: intermediate_rep.data_source.into_iter().next(),
            data_source_ref: intermediate_rep.data_source_ref.into_iter().next(),
            resources: intermediate_rep.resources.into_iter().next(),
            selector: intermediate_rep.selector.into_iter().next(),
            storage_class_name: intermediate_rep.storage_class_name.into_iter().next(),
            volume_mode: intermediate_rep.volume_mode.into_iter().next(),
            volume_name: intermediate_rep.volume_name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PersistentVolumeClaimSpec> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PersistentVolumeClaimSpec>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PersistentVolumeClaimSpec>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PersistentVolumeClaimSpec - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PersistentVolumeClaimSpec> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PersistentVolumeClaimSpec as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PersistentVolumeClaimSpec - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PersistentVolumeClaimTemplate is used to produce PersistentVolumeClaim objects as part of an EphemeralVolumeSource.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PersistentVolumeClaimTemplate {
/// Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations +optional
    #[serde(rename = "annotations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotations: Option<std::collections::HashMap<String, String>>,

/// The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request. +optional
    #[serde(rename = "clusterName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cluster_name: Option<String>,

/// CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.  Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata +optional
    #[serde(rename = "creationTimestamp")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub creation_timestamp: Option<String>,

/// Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only. +optional
    #[serde(rename = "deletionGracePeriodSeconds")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletion_grace_period_seconds: Option<i64>,

/// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.  Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata +optional
    #[serde(rename = "deletionTimestamp")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletion_timestamp: Option<String>,

/// Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. +optional +patchStrategy=merge
    #[serde(rename = "finalizers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub finalizers: Option<Vec<String>>,

/// GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.  If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).  Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency +optional
    #[serde(rename = "generateName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub generate_name: Option<String>,

/// A sequence number representing a specific generation of the desired state. Populated by the system. Read-only. +optional
    #[serde(rename = "generation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub generation: Option<i64>,

/// Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels +optional
    #[serde(rename = "labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

/// ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like \"ci-cd\". The set of fields is always in the version that the workflow used when modifying the object.  +optional
    #[serde(rename = "managedFields")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub managed_fields: Option<Vec<models::ManagedFieldsEntry>>,

/// Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names +optional
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.  Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces +optional
    #[serde(rename = "namespace")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub namespace: Option<String>,

/// List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. +optional +patchMergeKey=uid +patchStrategy=merge
    #[serde(rename = "ownerReferences")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner_references: Option<Vec<models::OwnerReference>>,

/// An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.  Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency +optional
    #[serde(rename = "resourceVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resource_version: Option<String>,

/// SelfLink is a URL representing this object. Populated by the system. Read-only.  DEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release. +optional
    #[serde(rename = "selfLink")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub self_link: Option<String>,

    #[serde(rename = "spec")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub spec: Option<models::PersistentVolumeClaimSpec>,

/// UID is a type that holds unique ID values, including UUIDs.  Because we don't ONLY use UUIDs, this is an alias to string.  Being a type captures intent and helps make sure that UIDs and names do not get conflated.
    #[serde(rename = "uid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub uid: Option<String>,

}


impl PersistentVolumeClaimTemplate {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PersistentVolumeClaimTemplate {
        PersistentVolumeClaimTemplate {
            annotations: None,
            cluster_name: None,
            creation_timestamp: None,
            deletion_grace_period_seconds: None,
            deletion_timestamp: None,
            finalizers: None,
            generate_name: None,
            generation: None,
            labels: None,
            managed_fields: None,
            name: None,
            namespace: None,
            owner_references: None,
            resource_version: None,
            self_link: None,
            spec: None,
            uid: None,
        }
    }
}

/// Converts the PersistentVolumeClaimTemplate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PersistentVolumeClaimTemplate {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping annotations in query parameter serialization


            self.cluster_name.as_ref().map(|cluster_name| {
                [
                    "clusterName".to_string(),
                    cluster_name.to_string(),
                ].join(",")
            }),


            self.creation_timestamp.as_ref().map(|creation_timestamp| {
                [
                    "creationTimestamp".to_string(),
                    creation_timestamp.to_string(),
                ].join(",")
            }),


            self.deletion_grace_period_seconds.as_ref().map(|deletion_grace_period_seconds| {
                [
                    "deletionGracePeriodSeconds".to_string(),
                    deletion_grace_period_seconds.to_string(),
                ].join(",")
            }),


            self.deletion_timestamp.as_ref().map(|deletion_timestamp| {
                [
                    "deletionTimestamp".to_string(),
                    deletion_timestamp.to_string(),
                ].join(",")
            }),


            self.finalizers.as_ref().map(|finalizers| {
                [
                    "finalizers".to_string(),
                    finalizers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.generate_name.as_ref().map(|generate_name| {
                [
                    "generateName".to_string(),
                    generate_name.to_string(),
                ].join(",")
            }),


            self.generation.as_ref().map(|generation| {
                [
                    "generation".to_string(),
                    generation.to_string(),
                ].join(",")
            }),

            // Skipping labels in query parameter serialization

            // Skipping managedFields in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.namespace.as_ref().map(|namespace| {
                [
                    "namespace".to_string(),
                    namespace.to_string(),
                ].join(",")
            }),

            // Skipping ownerReferences in query parameter serialization


            self.resource_version.as_ref().map(|resource_version| {
                [
                    "resourceVersion".to_string(),
                    resource_version.to_string(),
                ].join(",")
            }),


            self.self_link.as_ref().map(|self_link| {
                [
                    "selfLink".to_string(),
                    self_link.to_string(),
                ].join(",")
            }),

            // Skipping spec in query parameter serialization


            self.uid.as_ref().map(|uid| {
                [
                    "uid".to_string(),
                    uid.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PersistentVolumeClaimTemplate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PersistentVolumeClaimTemplate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub annotations: Vec<std::collections::HashMap<String, String>>,
            pub cluster_name: Vec<String>,
            pub creation_timestamp: Vec<String>,
            pub deletion_grace_period_seconds: Vec<i64>,
            pub deletion_timestamp: Vec<String>,
            pub finalizers: Vec<Vec<String>>,
            pub generate_name: Vec<String>,
            pub generation: Vec<i64>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub managed_fields: Vec<Vec<models::ManagedFieldsEntry>>,
            pub name: Vec<String>,
            pub namespace: Vec<String>,
            pub owner_references: Vec<Vec<models::OwnerReference>>,
            pub resource_version: Vec<String>,
            pub self_link: Vec<String>,
            pub spec: Vec<models::PersistentVolumeClaimSpec>,
            pub uid: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PersistentVolumeClaimTemplate".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in PersistentVolumeClaimTemplate".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "clusterName" => intermediate_rep.cluster_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "creationTimestamp" => intermediate_rep.creation_timestamp.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deletionGracePeriodSeconds" => intermediate_rep.deletion_grace_period_seconds.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deletionTimestamp" => intermediate_rep.deletion_timestamp.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "finalizers" => return std::result::Result::Err("Parsing a container in this style is not supported in PersistentVolumeClaimTemplate".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "generateName" => intermediate_rep.generate_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "generation" => intermediate_rep.generation.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "labels" => return std::result::Result::Err("Parsing a container in this style is not supported in PersistentVolumeClaimTemplate".to_string()),
                    "managedFields" => return std::result::Result::Err("Parsing a container in this style is not supported in PersistentVolumeClaimTemplate".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "namespace" => intermediate_rep.namespace.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ownerReferences" => return std::result::Result::Err("Parsing a container in this style is not supported in PersistentVolumeClaimTemplate".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "resourceVersion" => intermediate_rep.resource_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "selfLink" => intermediate_rep.self_link.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "spec" => intermediate_rep.spec.push(<models::PersistentVolumeClaimSpec as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "uid" => intermediate_rep.uid.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PersistentVolumeClaimTemplate".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PersistentVolumeClaimTemplate {
            annotations: intermediate_rep.annotations.into_iter().next(),
            cluster_name: intermediate_rep.cluster_name.into_iter().next(),
            creation_timestamp: intermediate_rep.creation_timestamp.into_iter().next(),
            deletion_grace_period_seconds: intermediate_rep.deletion_grace_period_seconds.into_iter().next(),
            deletion_timestamp: intermediate_rep.deletion_timestamp.into_iter().next(),
            finalizers: intermediate_rep.finalizers.into_iter().next(),
            generate_name: intermediate_rep.generate_name.into_iter().next(),
            generation: intermediate_rep.generation.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            managed_fields: intermediate_rep.managed_fields.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            namespace: intermediate_rep.namespace.into_iter().next(),
            owner_references: intermediate_rep.owner_references.into_iter().next(),
            resource_version: intermediate_rep.resource_version.into_iter().next(),
            self_link: intermediate_rep.self_link.into_iter().next(),
            spec: intermediate_rep.spec.into_iter().next(),
            uid: intermediate_rep.uid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PersistentVolumeClaimTemplate> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PersistentVolumeClaimTemplate>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PersistentVolumeClaimTemplate>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PersistentVolumeClaimTemplate - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PersistentVolumeClaimTemplate> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PersistentVolumeClaimTemplate as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PersistentVolumeClaimTemplate - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system).



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PersistentVolumeClaimVolumeSource {
/// ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
    #[serde(rename = "claimName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub claim_name: Option<String>,

/// Will force the ReadOnly setting in VolumeMounts. Default false. +optional
    #[serde(rename = "readOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

}


impl PersistentVolumeClaimVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PersistentVolumeClaimVolumeSource {
        PersistentVolumeClaimVolumeSource {
            claim_name: None,
            read_only: None,
        }
    }
}

/// Converts the PersistentVolumeClaimVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PersistentVolumeClaimVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.claim_name.as_ref().map(|claim_name| {
                [
                    "claimName".to_string(),
                    claim_name.to_string(),
                ].join(",")
            }),


            self.read_only.as_ref().map(|read_only| {
                [
                    "readOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PersistentVolumeClaimVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PersistentVolumeClaimVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub claim_name: Vec<String>,
            pub read_only: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PersistentVolumeClaimVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "claimName" => intermediate_rep.claim_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "readOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PersistentVolumeClaimVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PersistentVolumeClaimVolumeSource {
            claim_name: intermediate_rep.claim_name.into_iter().next(),
            read_only: intermediate_rep.read_only.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PersistentVolumeClaimVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PersistentVolumeClaimVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PersistentVolumeClaimVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PersistentVolumeClaimVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PersistentVolumeClaimVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PersistentVolumeClaimVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PersistentVolumeClaimVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// +enum
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PersistentVolumeMode(String);

impl validator::Validate for PersistentVolumeMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for PersistentVolumeMode {
    fn from(x: String) -> Self {
        PersistentVolumeMode(x)
    }
}

impl std::string::ToString for PersistentVolumeMode {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for PersistentVolumeMode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(PersistentVolumeMode(x.to_string()))
    }
}

impl std::convert::From<PersistentVolumeMode> for String {
    fn from(x: PersistentVolumeMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for PersistentVolumeMode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for PersistentVolumeMode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PhotonPersistentDiskVolumeSource {
/// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.
    #[serde(rename = "fsType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fs_type: Option<String>,

/// ID that identifies Photon Controller persistent disk
    #[serde(rename = "pdID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pd_id: Option<String>,

}


impl PhotonPersistentDiskVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PhotonPersistentDiskVolumeSource {
        PhotonPersistentDiskVolumeSource {
            fs_type: None,
            pd_id: None,
        }
    }
}

/// Converts the PhotonPersistentDiskVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PhotonPersistentDiskVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.fs_type.as_ref().map(|fs_type| {
                [
                    "fsType".to_string(),
                    fs_type.to_string(),
                ].join(",")
            }),


            self.pd_id.as_ref().map(|pd_id| {
                [
                    "pdID".to_string(),
                    pd_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PhotonPersistentDiskVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PhotonPersistentDiskVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub fs_type: Vec<String>,
            pub pd_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PhotonPersistentDiskVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "fsType" => intermediate_rep.fs_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pdID" => intermediate_rep.pd_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PhotonPersistentDiskVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PhotonPersistentDiskVolumeSource {
            fs_type: intermediate_rep.fs_type.into_iter().next(),
            pd_id: intermediate_rep.pd_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PhotonPersistentDiskVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PhotonPersistentDiskVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PhotonPersistentDiskVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PhotonPersistentDiskVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PhotonPersistentDiskVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PhotonPersistentDiskVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PhotonPersistentDiskVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PidMode(String);

impl validator::Validate for PidMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for PidMode {
    fn from(x: String) -> Self {
        PidMode(x)
    }
}

impl std::string::ToString for PidMode {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for PidMode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(PidMode(x.to_string()))
    }
}

impl std::convert::From<PidMode> for String {
    fn from(x: PidMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for PidMode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for PidMode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Platform {
/// Architecture field specifies the CPU architecture, for example `amd64` or `ppc64`.
    #[serde(rename = "architecture")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub architecture: Option<String>,

/// OS specifies the operating system, for example `linux` or `windows`.
    #[serde(rename = "os")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os: Option<String>,

/// OSFeatures is an optional field specifying an array of strings, each listing a required OS feature (for example on Windows `win32k`).
    #[serde(rename = "os.features")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os_period_features: Option<Vec<String>>,

/// OSVersion is an optional field specifying the operating system version, for example on Windows `10.0.14393.1066`.
    #[serde(rename = "os.version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os_period_version: Option<String>,

/// Variant is an optional field specifying a variant of the CPU, for example `v7` to specify ARMv7 when architecture is `arm`.
    #[serde(rename = "variant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub variant: Option<String>,

}


impl Platform {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Platform {
        Platform {
            architecture: None,
            os: None,
            os_period_features: None,
            os_period_version: None,
            variant: None,
        }
    }
}

/// Converts the Platform value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Platform {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.architecture.as_ref().map(|architecture| {
                [
                    "architecture".to_string(),
                    architecture.to_string(),
                ].join(",")
            }),


            self.os.as_ref().map(|os| {
                [
                    "os".to_string(),
                    os.to_string(),
                ].join(",")
            }),


            self.os_period_features.as_ref().map(|os_period_features| {
                [
                    "os.features".to_string(),
                    os_period_features.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.os_period_version.as_ref().map(|os_period_version| {
                [
                    "os.version".to_string(),
                    os_period_version.to_string(),
                ].join(",")
            }),


            self.variant.as_ref().map(|variant| {
                [
                    "variant".to_string(),
                    variant.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Platform value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Platform {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub architecture: Vec<String>,
            pub os: Vec<String>,
            pub os_period_features: Vec<Vec<String>>,
            pub os_period_version: Vec<String>,
            pub variant: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Platform".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "architecture" => intermediate_rep.architecture.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "os" => intermediate_rep.os.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "os.features" => return std::result::Result::Err("Parsing a container in this style is not supported in Platform".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "os.version" => intermediate_rep.os_period_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "variant" => intermediate_rep.variant.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Platform".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Platform {
            architecture: intermediate_rep.architecture.into_iter().next(),
            os: intermediate_rep.os.into_iter().next(),
            os_period_features: intermediate_rep.os_period_features.into_iter().next(),
            os_period_version: intermediate_rep.os_period_version.into_iter().next(),
            variant: intermediate_rep.variant.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Platform> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Platform>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Platform>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Platform - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Platform> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Platform as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Platform - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Plugin A plugin for the Engine API



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Plugin {
    #[serde(rename = "Config")]
    pub config: models::PluginConfig,

/// True if the plugin is running. False if the plugin is not running, only installed.
    #[serde(rename = "Enabled")]
    pub enabled: bool,

/// Id
    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// name
    #[serde(rename = "Name")]
    pub name: String,

/// plugin remote reference used to push/pull the plugin
    #[serde(rename = "PluginReference")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub plugin_reference: Option<String>,

    #[serde(rename = "Settings")]
    pub settings: models::PluginSettings,

}


impl Plugin {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(config: models::PluginConfig, enabled: bool, name: String, settings: models::PluginSettings, ) -> Plugin {
        Plugin {
            config,
            enabled,
            id: None,
            name,
            plugin_reference: None,
            settings,
        }
    }
}

/// Converts the Plugin value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Plugin {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping Config in query parameter serialization


            Some("Enabled".to_string()),
            Some(self.enabled.to_string()),


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            Some("Name".to_string()),
            Some(self.name.to_string()),


            self.plugin_reference.as_ref().map(|plugin_reference| {
                [
                    "PluginReference".to_string(),
                    plugin_reference.to_string(),
                ].join(",")
            }),

            // Skipping Settings in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Plugin value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Plugin {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub config: Vec<models::PluginConfig>,
            pub enabled: Vec<bool>,
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub plugin_reference: Vec<String>,
            pub settings: Vec<models::PluginSettings>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Plugin".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Config" => intermediate_rep.config.push(<models::PluginConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Enabled" => intermediate_rep.enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PluginReference" => intermediate_rep.plugin_reference.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Settings" => intermediate_rep.settings.push(<models::PluginSettings as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Plugin".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Plugin {
            config: intermediate_rep.config.into_iter().next().ok_or_else(|| "Config missing in Plugin".to_string())?,
            enabled: intermediate_rep.enabled.into_iter().next().ok_or_else(|| "Enabled missing in Plugin".to_string())?,
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "Name missing in Plugin".to_string())?,
            plugin_reference: intermediate_rep.plugin_reference.into_iter().next(),
            settings: intermediate_rep.settings.into_iter().next().ok_or_else(|| "Settings missing in Plugin".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Plugin> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Plugin>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Plugin>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Plugin - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Plugin> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Plugin as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Plugin - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginConfig {
    #[serde(rename = "Args")]
    pub args: models::PluginConfigArgs,

/// description
    #[serde(rename = "Description")]
    pub description: String,

/// Docker Version used to create the plugin
    #[serde(rename = "DockerVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub docker_version: Option<String>,

/// documentation
    #[serde(rename = "Documentation")]
    pub documentation: String,

/// entrypoint
    #[serde(rename = "Entrypoint")]
    pub entrypoint: Vec<String>,

/// env
    #[serde(rename = "Env")]
    pub env: Vec<models::PluginEnv>,

    #[serde(rename = "Interface")]
    pub interface: models::PluginConfigInterface,

/// ipc host
    #[serde(rename = "IpcHost")]
    pub ipc_host: bool,

    #[serde(rename = "Linux")]
    pub linux: models::PluginConfigLinux,

/// mounts
    #[serde(rename = "Mounts")]
    pub mounts: Vec<models::PluginMount>,

    #[serde(rename = "Network")]
    pub network: models::PluginConfigNetwork,

/// pid host
    #[serde(rename = "PidHost")]
    pub pid_host: bool,

/// propagated mount
    #[serde(rename = "PropagatedMount")]
    pub propagated_mount: String,

    #[serde(rename = "User")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<models::PluginConfigUser>,

/// work dir
    #[serde(rename = "WorkDir")]
    pub work_dir: String,

    #[serde(rename = "rootfs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rootfs: Option<models::PluginConfigRootfs>,

}


impl PluginConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(args: models::PluginConfigArgs, description: String, documentation: String, entrypoint: Vec<String>, env: Vec<models::PluginEnv>, interface: models::PluginConfigInterface, ipc_host: bool, linux: models::PluginConfigLinux, mounts: Vec<models::PluginMount>, network: models::PluginConfigNetwork, pid_host: bool, propagated_mount: String, work_dir: String, ) -> PluginConfig {
        PluginConfig {
            args,
            description,
            docker_version: None,
            documentation,
            entrypoint,
            env,
            interface,
            ipc_host,
            linux,
            mounts,
            network,
            pid_host,
            propagated_mount,
            user: None,
            work_dir,
            rootfs: None,
        }
    }
}

/// Converts the PluginConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PluginConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping Args in query parameter serialization


            Some("Description".to_string()),
            Some(self.description.to_string()),


            self.docker_version.as_ref().map(|docker_version| {
                [
                    "DockerVersion".to_string(),
                    docker_version.to_string(),
                ].join(",")
            }),


            Some("Documentation".to_string()),
            Some(self.documentation.to_string()),


            Some("Entrypoint".to_string()),
            Some(self.entrypoint.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

            // Skipping Env in query parameter serialization

            // Skipping Interface in query parameter serialization


            Some("IpcHost".to_string()),
            Some(self.ipc_host.to_string()),

            // Skipping Linux in query parameter serialization

            // Skipping Mounts in query parameter serialization

            // Skipping Network in query parameter serialization


            Some("PidHost".to_string()),
            Some(self.pid_host.to_string()),


            Some("PropagatedMount".to_string()),
            Some(self.propagated_mount.to_string()),

            // Skipping User in query parameter serialization


            Some("WorkDir".to_string()),
            Some(self.work_dir.to_string()),

            // Skipping rootfs in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub args: Vec<models::PluginConfigArgs>,
            pub description: Vec<String>,
            pub docker_version: Vec<String>,
            pub documentation: Vec<String>,
            pub entrypoint: Vec<Vec<String>>,
            pub env: Vec<Vec<models::PluginEnv>>,
            pub interface: Vec<models::PluginConfigInterface>,
            pub ipc_host: Vec<bool>,
            pub linux: Vec<models::PluginConfigLinux>,
            pub mounts: Vec<Vec<models::PluginMount>>,
            pub network: Vec<models::PluginConfigNetwork>,
            pub pid_host: Vec<bool>,
            pub propagated_mount: Vec<String>,
            pub user: Vec<models::PluginConfigUser>,
            pub work_dir: Vec<String>,
            pub rootfs: Vec<models::PluginConfigRootfs>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Args" => intermediate_rep.args.push(<models::PluginConfigArgs as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "DockerVersion" => intermediate_rep.docker_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Documentation" => intermediate_rep.documentation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Entrypoint" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginConfig".to_string()),
                    "Env" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Interface" => intermediate_rep.interface.push(<models::PluginConfigInterface as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IpcHost" => intermediate_rep.ipc_host.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Linux" => intermediate_rep.linux.push(<models::PluginConfigLinux as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Mounts" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Network" => intermediate_rep.network.push(<models::PluginConfigNetwork as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PidHost" => intermediate_rep.pid_host.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PropagatedMount" => intermediate_rep.propagated_mount.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "User" => intermediate_rep.user.push(<models::PluginConfigUser as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "WorkDir" => intermediate_rep.work_dir.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rootfs" => intermediate_rep.rootfs.push(<models::PluginConfigRootfs as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginConfig {
            args: intermediate_rep.args.into_iter().next().ok_or_else(|| "Args missing in PluginConfig".to_string())?,
            description: intermediate_rep.description.into_iter().next().ok_or_else(|| "Description missing in PluginConfig".to_string())?,
            docker_version: intermediate_rep.docker_version.into_iter().next(),
            documentation: intermediate_rep.documentation.into_iter().next().ok_or_else(|| "Documentation missing in PluginConfig".to_string())?,
            entrypoint: intermediate_rep.entrypoint.into_iter().next().ok_or_else(|| "Entrypoint missing in PluginConfig".to_string())?,
            env: intermediate_rep.env.into_iter().next().ok_or_else(|| "Env missing in PluginConfig".to_string())?,
            interface: intermediate_rep.interface.into_iter().next().ok_or_else(|| "Interface missing in PluginConfig".to_string())?,
            ipc_host: intermediate_rep.ipc_host.into_iter().next().ok_or_else(|| "IpcHost missing in PluginConfig".to_string())?,
            linux: intermediate_rep.linux.into_iter().next().ok_or_else(|| "Linux missing in PluginConfig".to_string())?,
            mounts: intermediate_rep.mounts.into_iter().next().ok_or_else(|| "Mounts missing in PluginConfig".to_string())?,
            network: intermediate_rep.network.into_iter().next().ok_or_else(|| "Network missing in PluginConfig".to_string())?,
            pid_host: intermediate_rep.pid_host.into_iter().next().ok_or_else(|| "PidHost missing in PluginConfig".to_string())?,
            propagated_mount: intermediate_rep.propagated_mount.into_iter().next().ok_or_else(|| "PropagatedMount missing in PluginConfig".to_string())?,
            user: intermediate_rep.user.into_iter().next(),
            work_dir: intermediate_rep.work_dir.into_iter().next().ok_or_else(|| "WorkDir missing in PluginConfig".to_string())?,
            rootfs: intermediate_rep.rootfs.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PluginConfigArgs plugin config args



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginConfigArgs {
/// description
    #[serde(rename = "Description")]
    pub description: String,

/// name
    #[serde(rename = "Name")]
    pub name: String,

/// settable
    #[serde(rename = "Settable")]
    pub settable: Vec<String>,

/// value
    #[serde(rename = "Value")]
    pub value: Vec<String>,

}


impl PluginConfigArgs {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(description: String, name: String, settable: Vec<String>, value: Vec<String>, ) -> PluginConfigArgs {
        PluginConfigArgs {
            description,
            name,
            settable,
            value,
        }
    }
}

/// Converts the PluginConfigArgs value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PluginConfigArgs {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("Description".to_string()),
            Some(self.description.to_string()),


            Some("Name".to_string()),
            Some(self.name.to_string()),


            Some("Settable".to_string()),
            Some(self.settable.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("Value".to_string()),
            Some(self.value.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginConfigArgs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginConfigArgs {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub name: Vec<String>,
            pub settable: Vec<Vec<String>>,
            pub value: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginConfigArgs".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Settable" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginConfigArgs".to_string()),
                    "Value" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginConfigArgs".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginConfigArgs".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginConfigArgs {
            description: intermediate_rep.description.into_iter().next().ok_or_else(|| "Description missing in PluginConfigArgs".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "Name missing in PluginConfigArgs".to_string())?,
            settable: intermediate_rep.settable.into_iter().next().ok_or_else(|| "Settable missing in PluginConfigArgs".to_string())?,
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "Value missing in PluginConfigArgs".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginConfigArgs> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginConfigArgs>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginConfigArgs>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginConfigArgs - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginConfigArgs> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginConfigArgs as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginConfigArgs - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PluginConfigInterface The interface between Docker and the plugin



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginConfigInterface {
/// Protocol to use for clients connecting to the plugin.
    #[serde(rename = "ProtocolScheme")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub protocol_scheme: Option<String>,

/// socket
    #[serde(rename = "Socket")]
    pub socket: String,

/// types
    #[serde(rename = "Types")]
    pub types: Vec<models::PluginInterfaceType>,

}


impl PluginConfigInterface {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(socket: String, types: Vec<models::PluginInterfaceType>, ) -> PluginConfigInterface {
        PluginConfigInterface {
            protocol_scheme: None,
            socket,
            types,
        }
    }
}

/// Converts the PluginConfigInterface value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PluginConfigInterface {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.protocol_scheme.as_ref().map(|protocol_scheme| {
                [
                    "ProtocolScheme".to_string(),
                    protocol_scheme.to_string(),
                ].join(",")
            }),


            Some("Socket".to_string()),
            Some(self.socket.to_string()),

            // Skipping Types in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginConfigInterface value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginConfigInterface {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub protocol_scheme: Vec<String>,
            pub socket: Vec<String>,
            pub types: Vec<Vec<models::PluginInterfaceType>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginConfigInterface".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ProtocolScheme" => intermediate_rep.protocol_scheme.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Socket" => intermediate_rep.socket.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Types" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginConfigInterface".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginConfigInterface".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginConfigInterface {
            protocol_scheme: intermediate_rep.protocol_scheme.into_iter().next(),
            socket: intermediate_rep.socket.into_iter().next().ok_or_else(|| "Socket missing in PluginConfigInterface".to_string())?,
            types: intermediate_rep.types.into_iter().next().ok_or_else(|| "Types missing in PluginConfigInterface".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginConfigInterface> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginConfigInterface>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginConfigInterface>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginConfigInterface - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginConfigInterface> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginConfigInterface as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginConfigInterface - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PluginConfigLinux plugin config linux



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginConfigLinux {
/// allow all devices
    #[serde(rename = "AllowAllDevices")]
    pub allow_all_devices: bool,

/// capabilities
    #[serde(rename = "Capabilities")]
    pub capabilities: Vec<String>,

/// devices
    #[serde(rename = "Devices")]
    pub devices: Vec<models::PluginDevice>,

}


impl PluginConfigLinux {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(allow_all_devices: bool, capabilities: Vec<String>, devices: Vec<models::PluginDevice>, ) -> PluginConfigLinux {
        PluginConfigLinux {
            allow_all_devices,
            capabilities,
            devices,
        }
    }
}

/// Converts the PluginConfigLinux value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PluginConfigLinux {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("AllowAllDevices".to_string()),
            Some(self.allow_all_devices.to_string()),


            Some("Capabilities".to_string()),
            Some(self.capabilities.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

            // Skipping Devices in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginConfigLinux value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginConfigLinux {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub allow_all_devices: Vec<bool>,
            pub capabilities: Vec<Vec<String>>,
            pub devices: Vec<Vec<models::PluginDevice>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginConfigLinux".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "AllowAllDevices" => intermediate_rep.allow_all_devices.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Capabilities" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginConfigLinux".to_string()),
                    "Devices" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginConfigLinux".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginConfigLinux".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginConfigLinux {
            allow_all_devices: intermediate_rep.allow_all_devices.into_iter().next().ok_or_else(|| "AllowAllDevices missing in PluginConfigLinux".to_string())?,
            capabilities: intermediate_rep.capabilities.into_iter().next().ok_or_else(|| "Capabilities missing in PluginConfigLinux".to_string())?,
            devices: intermediate_rep.devices.into_iter().next().ok_or_else(|| "Devices missing in PluginConfigLinux".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginConfigLinux> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginConfigLinux>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginConfigLinux>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginConfigLinux - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginConfigLinux> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginConfigLinux as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginConfigLinux - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PluginConfigNetwork plugin config network



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginConfigNetwork {
/// type
    #[serde(rename = "Type")]
    pub r#type: String,

}


impl PluginConfigNetwork {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, ) -> PluginConfigNetwork {
        PluginConfigNetwork {
            r#type,
        }
    }
}

/// Converts the PluginConfigNetwork value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PluginConfigNetwork {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("Type".to_string()),
            Some(self.r#type.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginConfigNetwork value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginConfigNetwork {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginConfigNetwork".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginConfigNetwork".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginConfigNetwork {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "Type missing in PluginConfigNetwork".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginConfigNetwork> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginConfigNetwork>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginConfigNetwork>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginConfigNetwork - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginConfigNetwork> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginConfigNetwork as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginConfigNetwork - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PluginConfigRootfs plugin config rootfs



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginConfigRootfs {
/// diff ids
    #[serde(rename = "diff_ids")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_ids: Option<Vec<String>>,

/// type
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

}


impl PluginConfigRootfs {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PluginConfigRootfs {
        PluginConfigRootfs {
            diff_ids: None,
            r#type: None,
        }
    }
}

/// Converts the PluginConfigRootfs value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PluginConfigRootfs {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.diff_ids.as_ref().map(|diff_ids| {
                [
                    "diff_ids".to_string(),
                    diff_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginConfigRootfs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginConfigRootfs {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub diff_ids: Vec<Vec<String>>,
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginConfigRootfs".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "diff_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginConfigRootfs".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginConfigRootfs".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginConfigRootfs {
            diff_ids: intermediate_rep.diff_ids.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginConfigRootfs> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginConfigRootfs>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginConfigRootfs>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginConfigRootfs - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginConfigRootfs> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginConfigRootfs as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginConfigRootfs - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PluginConfigUser plugin config user



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginConfigUser {
/// g ID
    #[serde(rename = "GID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gid: Option<i32>,

/// UID
    #[serde(rename = "UID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub uid: Option<i32>,

}


impl PluginConfigUser {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PluginConfigUser {
        PluginConfigUser {
            gid: None,
            uid: None,
        }
    }
}

/// Converts the PluginConfigUser value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PluginConfigUser {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.gid.as_ref().map(|gid| {
                [
                    "GID".to_string(),
                    gid.to_string(),
                ].join(",")
            }),


            self.uid.as_ref().map(|uid| {
                [
                    "UID".to_string(),
                    uid.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginConfigUser value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginConfigUser {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub gid: Vec<i32>,
            pub uid: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginConfigUser".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "GID" => intermediate_rep.gid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "UID" => intermediate_rep.uid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginConfigUser".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginConfigUser {
            gid: intermediate_rep.gid.into_iter().next(),
            uid: intermediate_rep.uid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginConfigUser> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginConfigUser>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginConfigUser>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginConfigUser - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginConfigUser> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginConfigUser as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginConfigUser - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PluginDevice plugin device



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginDevice {
/// description
    #[serde(rename = "Description")]
    pub description: String,

/// name
    #[serde(rename = "Name")]
    pub name: String,

/// path
    #[serde(rename = "Path")]
    pub path: String,

/// settable
    #[serde(rename = "Settable")]
    pub settable: Vec<String>,

}


impl PluginDevice {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(description: String, name: String, path: String, settable: Vec<String>, ) -> PluginDevice {
        PluginDevice {
            description,
            name,
            path,
            settable,
        }
    }
}

/// Converts the PluginDevice value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PluginDevice {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("Description".to_string()),
            Some(self.description.to_string()),


            Some("Name".to_string()),
            Some(self.name.to_string()),


            Some("Path".to_string()),
            Some(self.path.to_string()),


            Some("Settable".to_string()),
            Some(self.settable.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginDevice value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginDevice {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub name: Vec<String>,
            pub path: Vec<String>,
            pub settable: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginDevice".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Settable" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginDevice".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginDevice".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginDevice {
            description: intermediate_rep.description.into_iter().next().ok_or_else(|| "Description missing in PluginDevice".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "Name missing in PluginDevice".to_string())?,
            path: intermediate_rep.path.into_iter().next().ok_or_else(|| "Path missing in PluginDevice".to_string())?,
            settable: intermediate_rep.settable.into_iter().next().ok_or_else(|| "Settable missing in PluginDevice".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginDevice> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginDevice>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginDevice>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginDevice - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginDevice> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginDevice as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginDevice - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PluginEnv plugin env



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginEnv {
/// description
    #[serde(rename = "Description")]
    pub description: String,

/// name
    #[serde(rename = "Name")]
    pub name: String,

/// settable
    #[serde(rename = "Settable")]
    pub settable: Vec<String>,

/// value
    #[serde(rename = "Value")]
    pub value: String,

}


impl PluginEnv {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(description: String, name: String, settable: Vec<String>, value: String, ) -> PluginEnv {
        PluginEnv {
            description,
            name,
            settable,
            value,
        }
    }
}

/// Converts the PluginEnv value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PluginEnv {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("Description".to_string()),
            Some(self.description.to_string()),


            Some("Name".to_string()),
            Some(self.name.to_string()),


            Some("Settable".to_string()),
            Some(self.settable.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("Value".to_string()),
            Some(self.value.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginEnv value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginEnv {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub name: Vec<String>,
            pub settable: Vec<Vec<String>>,
            pub value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginEnv".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Settable" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginEnv".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginEnv".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginEnv {
            description: intermediate_rep.description.into_iter().next().ok_or_else(|| "Description missing in PluginEnv".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "Name missing in PluginEnv".to_string())?,
            settable: intermediate_rep.settable.into_iter().next().ok_or_else(|| "Settable missing in PluginEnv".to_string())?,
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "Value missing in PluginEnv".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginEnv> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginEnv>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginEnv>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginEnv - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginEnv> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginEnv as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginEnv - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PluginInterfaceType plugin interface type



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginInterfaceType {
/// capability
    #[serde(rename = "Capability")]
    pub capability: String,

/// prefix
    #[serde(rename = "Prefix")]
    pub prefix: String,

/// version
    #[serde(rename = "Version")]
    pub version: String,

}


impl PluginInterfaceType {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(capability: String, prefix: String, version: String, ) -> PluginInterfaceType {
        PluginInterfaceType {
            capability,
            prefix,
            version,
        }
    }
}

/// Converts the PluginInterfaceType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PluginInterfaceType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("Capability".to_string()),
            Some(self.capability.to_string()),


            Some("Prefix".to_string()),
            Some(self.prefix.to_string()),


            Some("Version".to_string()),
            Some(self.version.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginInterfaceType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginInterfaceType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub capability: Vec<String>,
            pub prefix: Vec<String>,
            pub version: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginInterfaceType".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Capability" => intermediate_rep.capability.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Prefix" => intermediate_rep.prefix.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Version" => intermediate_rep.version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginInterfaceType".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginInterfaceType {
            capability: intermediate_rep.capability.into_iter().next().ok_or_else(|| "Capability missing in PluginInterfaceType".to_string())?,
            prefix: intermediate_rep.prefix.into_iter().next().ok_or_else(|| "Prefix missing in PluginInterfaceType".to_string())?,
            version: intermediate_rep.version.into_iter().next().ok_or_else(|| "Version missing in PluginInterfaceType".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginInterfaceType> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginInterfaceType>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginInterfaceType>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginInterfaceType - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginInterfaceType> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginInterfaceType as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginInterfaceType - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PluginMount plugin mount



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginMount {
/// description
    #[serde(rename = "Description")]
    pub description: String,

/// destination
    #[serde(rename = "Destination")]
    pub destination: String,

/// name
    #[serde(rename = "Name")]
    pub name: String,

/// options
    #[serde(rename = "Options")]
    pub options: Vec<String>,

/// settable
    #[serde(rename = "Settable")]
    pub settable: Vec<String>,

/// source
    #[serde(rename = "Source")]
    pub source: String,

/// type
    #[serde(rename = "Type")]
    pub r#type: String,

}


impl PluginMount {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(description: String, destination: String, name: String, options: Vec<String>, settable: Vec<String>, source: String, r#type: String, ) -> PluginMount {
        PluginMount {
            description,
            destination,
            name,
            options,
            settable,
            source,
            r#type,
        }
    }
}

/// Converts the PluginMount value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PluginMount {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("Description".to_string()),
            Some(self.description.to_string()),


            Some("Destination".to_string()),
            Some(self.destination.to_string()),


            Some("Name".to_string()),
            Some(self.name.to_string()),


            Some("Options".to_string()),
            Some(self.options.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("Settable".to_string()),
            Some(self.settable.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("Source".to_string()),
            Some(self.source.to_string()),


            Some("Type".to_string()),
            Some(self.r#type.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginMount value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginMount {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub destination: Vec<String>,
            pub name: Vec<String>,
            pub options: Vec<Vec<String>>,
            pub settable: Vec<Vec<String>>,
            pub source: Vec<String>,
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginMount".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Destination" => intermediate_rep.destination.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Options" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginMount".to_string()),
                    "Settable" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginMount".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Source" => intermediate_rep.source.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginMount".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginMount {
            description: intermediate_rep.description.into_iter().next().ok_or_else(|| "Description missing in PluginMount".to_string())?,
            destination: intermediate_rep.destination.into_iter().next().ok_or_else(|| "Destination missing in PluginMount".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "Name missing in PluginMount".to_string())?,
            options: intermediate_rep.options.into_iter().next().ok_or_else(|| "Options missing in PluginMount".to_string())?,
            settable: intermediate_rep.settable.into_iter().next().ok_or_else(|| "Settable missing in PluginMount".to_string())?,
            source: intermediate_rep.source.into_iter().next().ok_or_else(|| "Source missing in PluginMount".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "Type missing in PluginMount".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginMount> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginMount>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginMount>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginMount - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginMount> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginMount as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginMount - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginSettings {
/// args
    #[serde(rename = "Args")]
    pub args: Vec<String>,

/// devices
    #[serde(rename = "Devices")]
    pub devices: Vec<models::PluginDevice>,

/// env
    #[serde(rename = "Env")]
    pub env: Vec<String>,

/// mounts
    #[serde(rename = "Mounts")]
    pub mounts: Vec<models::PluginMount>,

}


impl PluginSettings {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(args: Vec<String>, devices: Vec<models::PluginDevice>, env: Vec<String>, mounts: Vec<models::PluginMount>, ) -> PluginSettings {
        PluginSettings {
            args,
            devices,
            env,
            mounts,
        }
    }
}

/// Converts the PluginSettings value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PluginSettings {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("Args".to_string()),
            Some(self.args.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

            // Skipping Devices in query parameter serialization


            Some("Env".to_string()),
            Some(self.env.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

            // Skipping Mounts in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginSettings value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginSettings {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub args: Vec<Vec<String>>,
            pub devices: Vec<Vec<models::PluginDevice>>,
            pub env: Vec<Vec<String>>,
            pub mounts: Vec<Vec<models::PluginMount>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginSettings".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Args" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginSettings".to_string()),
                    "Devices" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginSettings".to_string()),
                    "Env" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginSettings".to_string()),
                    "Mounts" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginSettings".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginSettings".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginSettings {
            args: intermediate_rep.args.into_iter().next().ok_or_else(|| "Args missing in PluginSettings".to_string())?,
            devices: intermediate_rep.devices.into_iter().next().ok_or_else(|| "Devices missing in PluginSettings".to_string())?,
            env: intermediate_rep.env.into_iter().next().ok_or_else(|| "Env missing in PluginSettings".to_string())?,
            mounts: intermediate_rep.mounts.into_iter().next().ok_or_else(|| "Mounts missing in PluginSettings".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginSettings> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginSettings>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginSettings>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginSettings - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginSettings> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginSettings as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginSettings - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodAffinity {
/// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred. +optional
    #[serde(rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<models::WeightedPodAffinityTerm>>,

/// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. +optional
    #[serde(rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<models::PodAffinityTerm>>,

}


impl PodAffinity {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodAffinity {
        PodAffinity {
            preferred_during_scheduling_ignored_during_execution: None,
            required_during_scheduling_ignored_during_execution: None,
        }
    }
}

/// Converts the PodAffinity value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PodAffinity {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping preferredDuringSchedulingIgnoredDuringExecution in query parameter serialization

            // Skipping requiredDuringSchedulingIgnoredDuringExecution in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodAffinity value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodAffinity {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub preferred_during_scheduling_ignored_during_execution: Vec<Vec<models::WeightedPodAffinityTerm>>,
            pub required_during_scheduling_ignored_during_execution: Vec<Vec<models::PodAffinityTerm>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodAffinity".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "preferredDuringSchedulingIgnoredDuringExecution" => return std::result::Result::Err("Parsing a container in this style is not supported in PodAffinity".to_string()),
                    "requiredDuringSchedulingIgnoredDuringExecution" => return std::result::Result::Err("Parsing a container in this style is not supported in PodAffinity".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodAffinity".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodAffinity {
            preferred_during_scheduling_ignored_during_execution: intermediate_rep.preferred_during_scheduling_ignored_during_execution.into_iter().next(),
            required_during_scheduling_ignored_during_execution: intermediate_rep.required_during_scheduling_ignored_during_execution.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodAffinity> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodAffinity>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodAffinity>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodAffinity - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodAffinity> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodAffinity as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodAffinity - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodAffinityTerm {
    #[serde(rename = "labelSelector")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub label_selector: Option<models::LabelSelector>,

    #[serde(rename = "namespaceSelector")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub namespace_selector: Option<models::LabelSelector>,

/// namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \"this pod's namespace\" +optional
    #[serde(rename = "namespaces")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub namespaces: Option<Vec<String>>,

/// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
    #[serde(rename = "topologyKey")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub topology_key: Option<String>,

}


impl PodAffinityTerm {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodAffinityTerm {
        PodAffinityTerm {
            label_selector: None,
            namespace_selector: None,
            namespaces: None,
            topology_key: None,
        }
    }
}

/// Converts the PodAffinityTerm value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PodAffinityTerm {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping labelSelector in query parameter serialization

            // Skipping namespaceSelector in query parameter serialization


            self.namespaces.as_ref().map(|namespaces| {
                [
                    "namespaces".to_string(),
                    namespaces.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.topology_key.as_ref().map(|topology_key| {
                [
                    "topologyKey".to_string(),
                    topology_key.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodAffinityTerm value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodAffinityTerm {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub label_selector: Vec<models::LabelSelector>,
            pub namespace_selector: Vec<models::LabelSelector>,
            pub namespaces: Vec<Vec<String>>,
            pub topology_key: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodAffinityTerm".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "labelSelector" => intermediate_rep.label_selector.push(<models::LabelSelector as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "namespaceSelector" => intermediate_rep.namespace_selector.push(<models::LabelSelector as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "namespaces" => return std::result::Result::Err("Parsing a container in this style is not supported in PodAffinityTerm".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "topologyKey" => intermediate_rep.topology_key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodAffinityTerm".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodAffinityTerm {
            label_selector: intermediate_rep.label_selector.into_iter().next(),
            namespace_selector: intermediate_rep.namespace_selector.into_iter().next(),
            namespaces: intermediate_rep.namespaces.into_iter().next(),
            topology_key: intermediate_rep.topology_key.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodAffinityTerm> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodAffinityTerm>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodAffinityTerm>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodAffinityTerm - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodAffinityTerm> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodAffinityTerm as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodAffinityTerm - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodAntiAffinity {
/// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred. +optional
    #[serde(rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<models::WeightedPodAffinityTerm>>,

/// If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. +optional
    #[serde(rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<models::PodAffinityTerm>>,

}


impl PodAntiAffinity {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodAntiAffinity {
        PodAntiAffinity {
            preferred_during_scheduling_ignored_during_execution: None,
            required_during_scheduling_ignored_during_execution: None,
        }
    }
}

/// Converts the PodAntiAffinity value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PodAntiAffinity {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping preferredDuringSchedulingIgnoredDuringExecution in query parameter serialization

            // Skipping requiredDuringSchedulingIgnoredDuringExecution in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodAntiAffinity value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodAntiAffinity {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub preferred_during_scheduling_ignored_during_execution: Vec<Vec<models::WeightedPodAffinityTerm>>,
            pub required_during_scheduling_ignored_during_execution: Vec<Vec<models::PodAffinityTerm>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodAntiAffinity".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "preferredDuringSchedulingIgnoredDuringExecution" => return std::result::Result::Err("Parsing a container in this style is not supported in PodAntiAffinity".to_string()),
                    "requiredDuringSchedulingIgnoredDuringExecution" => return std::result::Result::Err("Parsing a container in this style is not supported in PodAntiAffinity".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodAntiAffinity".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodAntiAffinity {
            preferred_during_scheduling_ignored_during_execution: intermediate_rep.preferred_during_scheduling_ignored_during_execution.into_iter().next(),
            required_during_scheduling_ignored_during_execution: intermediate_rep.required_during_scheduling_ignored_during_execution.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodAntiAffinity> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodAntiAffinity>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodAntiAffinity>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodAntiAffinity - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodAntiAffinity> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodAntiAffinity as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodAntiAffinity - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PodConditionType is a valid value for PodCondition.Type +enum
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodConditionType(String);

impl validator::Validate for PodConditionType {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for PodConditionType {
    fn from(x: String) -> Self {
        PodConditionType(x)
    }
}

impl std::string::ToString for PodConditionType {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for PodConditionType {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(PodConditionType(x.to_string()))
    }
}

impl std::convert::From<PodConditionType> for String {
    fn from(x: PodConditionType) -> Self {
        x.0
    }
}

impl std::ops::Deref for PodConditionType {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for PodConditionType {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodDnsConfig {
/// A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed. +optional
    #[serde(rename = "nameservers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub nameservers: Option<Vec<String>>,

/// A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy. +optional
    #[serde(rename = "options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<Vec<models::PodDnsConfigOption>>,

/// A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed. +optional
    #[serde(rename = "searches")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub searches: Option<Vec<String>>,

}


impl PodDnsConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodDnsConfig {
        PodDnsConfig {
            nameservers: None,
            options: None,
            searches: None,
        }
    }
}

/// Converts the PodDnsConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PodDnsConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.nameservers.as_ref().map(|nameservers| {
                [
                    "nameservers".to_string(),
                    nameservers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping options in query parameter serialization


            self.searches.as_ref().map(|searches| {
                [
                    "searches".to_string(),
                    searches.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodDnsConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodDnsConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub nameservers: Vec<Vec<String>>,
            pub options: Vec<Vec<models::PodDnsConfigOption>>,
            pub searches: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodDnsConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "nameservers" => return std::result::Result::Err("Parsing a container in this style is not supported in PodDnsConfig".to_string()),
                    "options" => return std::result::Result::Err("Parsing a container in this style is not supported in PodDnsConfig".to_string()),
                    "searches" => return std::result::Result::Err("Parsing a container in this style is not supported in PodDnsConfig".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodDnsConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodDnsConfig {
            nameservers: intermediate_rep.nameservers.into_iter().next(),
            options: intermediate_rep.options.into_iter().next(),
            searches: intermediate_rep.searches.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodDnsConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodDnsConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodDnsConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodDnsConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodDnsConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodDnsConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodDnsConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodDnsConfigOption {
/// Required.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// +optional
    #[serde(rename = "value")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,

}


impl PodDnsConfigOption {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodDnsConfigOption {
        PodDnsConfigOption {
            name: None,
            value: None,
        }
    }
}

/// Converts the PodDnsConfigOption value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PodDnsConfigOption {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.value.as_ref().map(|value| {
                [
                    "value".to_string(),
                    value.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodDnsConfigOption value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodDnsConfigOption {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodDnsConfigOption".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodDnsConfigOption".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodDnsConfigOption {
            name: intermediate_rep.name.into_iter().next(),
            value: intermediate_rep.value.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodDnsConfigOption> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodDnsConfigOption>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodDnsConfigOption>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodDnsConfigOption - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodDnsConfigOption> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodDnsConfigOption as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodDnsConfigOption - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PodFSGroupChangePolicy holds policies that will be used for applying fsGroup to a volume when volume is mounted. +enum
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodFsGroupChangePolicy(String);

impl validator::Validate for PodFsGroupChangePolicy {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for PodFsGroupChangePolicy {
    fn from(x: String) -> Self {
        PodFsGroupChangePolicy(x)
    }
}

impl std::string::ToString for PodFsGroupChangePolicy {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for PodFsGroupChangePolicy {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(PodFsGroupChangePolicy(x.to_string()))
    }
}

impl std::convert::From<PodFsGroupChangePolicy> for String {
    fn from(x: PodFsGroupChangePolicy) -> Self {
        x.0
    }
}

impl std::ops::Deref for PodFsGroupChangePolicy {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for PodFsGroupChangePolicy {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodOs {
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl PodOs {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodOs {
        PodOs {
            name: None,
        }
    }
}

/// Converts the PodOs value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PodOs {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodOs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodOs {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodOs".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodOs".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodOs {
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodOs> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodOs>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodOs>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodOs - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodOs> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodOs as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodOs - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PodReadinessGate contains the reference to a pod condition



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodReadinessGate {
/// PodConditionType is a valid value for PodCondition.Type +enum
    #[serde(rename = "conditionType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub condition_type: Option<String>,

}


impl PodReadinessGate {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodReadinessGate {
        PodReadinessGate {
            condition_type: None,
        }
    }
}

/// Converts the PodReadinessGate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PodReadinessGate {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.condition_type.as_ref().map(|condition_type| {
                [
                    "conditionType".to_string(),
                    condition_type.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodReadinessGate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodReadinessGate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub condition_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodReadinessGate".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "conditionType" => intermediate_rep.condition_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodReadinessGate".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodReadinessGate {
            condition_type: intermediate_rep.condition_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodReadinessGate> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodReadinessGate>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodReadinessGate>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodReadinessGate - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodReadinessGate> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodReadinessGate as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodReadinessGate - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodSecurityContext {
/// A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:  1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----  If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows. +optional
    #[serde(rename = "fsGroup")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fs_group: Option<i64>,

/// PodFSGroupChangePolicy holds policies that will be used for applying fsGroup to a volume when volume is mounted. +enum
    #[serde(rename = "fsGroupChangePolicy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fs_group_change_policy: Option<String>,

/// The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows. +optional
    #[serde(rename = "runAsGroup")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_as_group: Option<i64>,

/// Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. +optional
    #[serde(rename = "runAsNonRoot")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_as_non_root: Option<bool>,

/// The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows. +optional
    #[serde(rename = "runAsUser")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_as_user: Option<i64>,

    #[serde(rename = "seLinuxOptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub se_linux_options: Option<models::SeLinuxOptions>,

    #[serde(rename = "seccompProfile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub seccomp_profile: Option<models::SeccompProfile>,

/// A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows. +optional
    #[serde(rename = "supplementalGroups")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub supplemental_groups: Option<Vec<i64>>,

/// Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows. +optional
    #[serde(rename = "sysctls")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sysctls: Option<Vec<models::Sysctl>>,

    #[serde(rename = "windowsOptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub windows_options: Option<models::WindowsSecurityContextOptions>,

}


impl PodSecurityContext {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodSecurityContext {
        PodSecurityContext {
            fs_group: None,
            fs_group_change_policy: None,
            run_as_group: None,
            run_as_non_root: None,
            run_as_user: None,
            se_linux_options: None,
            seccomp_profile: None,
            supplemental_groups: None,
            sysctls: None,
            windows_options: None,
        }
    }
}

/// Converts the PodSecurityContext value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PodSecurityContext {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.fs_group.as_ref().map(|fs_group| {
                [
                    "fsGroup".to_string(),
                    fs_group.to_string(),
                ].join(",")
            }),


            self.fs_group_change_policy.as_ref().map(|fs_group_change_policy| {
                [
                    "fsGroupChangePolicy".to_string(),
                    fs_group_change_policy.to_string(),
                ].join(",")
            }),


            self.run_as_group.as_ref().map(|run_as_group| {
                [
                    "runAsGroup".to_string(),
                    run_as_group.to_string(),
                ].join(",")
            }),


            self.run_as_non_root.as_ref().map(|run_as_non_root| {
                [
                    "runAsNonRoot".to_string(),
                    run_as_non_root.to_string(),
                ].join(",")
            }),


            self.run_as_user.as_ref().map(|run_as_user| {
                [
                    "runAsUser".to_string(),
                    run_as_user.to_string(),
                ].join(",")
            }),

            // Skipping seLinuxOptions in query parameter serialization

            // Skipping seccompProfile in query parameter serialization


            self.supplemental_groups.as_ref().map(|supplemental_groups| {
                [
                    "supplementalGroups".to_string(),
                    supplemental_groups.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping sysctls in query parameter serialization

            // Skipping windowsOptions in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodSecurityContext value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodSecurityContext {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub fs_group: Vec<i64>,
            pub fs_group_change_policy: Vec<String>,
            pub run_as_group: Vec<i64>,
            pub run_as_non_root: Vec<bool>,
            pub run_as_user: Vec<i64>,
            pub se_linux_options: Vec<models::SeLinuxOptions>,
            pub seccomp_profile: Vec<models::SeccompProfile>,
            pub supplemental_groups: Vec<Vec<i64>>,
            pub sysctls: Vec<Vec<models::Sysctl>>,
            pub windows_options: Vec<models::WindowsSecurityContextOptions>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodSecurityContext".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "fsGroup" => intermediate_rep.fs_group.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fsGroupChangePolicy" => intermediate_rep.fs_group_change_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "runAsGroup" => intermediate_rep.run_as_group.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "runAsNonRoot" => intermediate_rep.run_as_non_root.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "runAsUser" => intermediate_rep.run_as_user.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "seLinuxOptions" => intermediate_rep.se_linux_options.push(<models::SeLinuxOptions as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "seccompProfile" => intermediate_rep.seccomp_profile.push(<models::SeccompProfile as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "supplementalGroups" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSecurityContext".to_string()),
                    "sysctls" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSecurityContext".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "windowsOptions" => intermediate_rep.windows_options.push(<models::WindowsSecurityContextOptions as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodSecurityContext".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodSecurityContext {
            fs_group: intermediate_rep.fs_group.into_iter().next(),
            fs_group_change_policy: intermediate_rep.fs_group_change_policy.into_iter().next(),
            run_as_group: intermediate_rep.run_as_group.into_iter().next(),
            run_as_non_root: intermediate_rep.run_as_non_root.into_iter().next(),
            run_as_user: intermediate_rep.run_as_user.into_iter().next(),
            se_linux_options: intermediate_rep.se_linux_options.into_iter().next(),
            seccomp_profile: intermediate_rep.seccomp_profile.into_iter().next(),
            supplemental_groups: intermediate_rep.supplemental_groups.into_iter().next(),
            sysctls: intermediate_rep.sysctls.into_iter().next(),
            windows_options: intermediate_rep.windows_options.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodSecurityContext> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodSecurityContext>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodSecurityContext>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodSecurityContext - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodSecurityContext> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodSecurityContext as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodSecurityContext - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodSpec {
/// Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer. +optional
    #[serde(rename = "activeDeadlineSeconds")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_deadline_seconds: Option<i64>,

    #[serde(rename = "affinity")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub affinity: Option<models::Affinity>,

/// AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. +optional
    #[serde(rename = "automountServiceAccountToken")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub automount_service_account_token: Option<bool>,

/// List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated. +patchMergeKey=name +patchStrategy=merge
    #[serde(rename = "containers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub containers: Option<Vec<models::Container>>,

    #[serde(rename = "dnsConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_config: Option<models::PodDnsConfig>,

/// +enum
    #[serde(rename = "dnsPolicy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_policy: Option<String>,

/// EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true. +optional
    #[serde(rename = "enableServiceLinks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub enable_service_links: Option<bool>,

/// List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource. This field is beta-level and available on clusters that haven't disabled the EphemeralContainers feature gate. +optional +patchMergeKey=name +patchStrategy=merge
    #[serde(rename = "ephemeralContainers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ephemeral_containers: Option<Vec<models::EphemeralContainer>>,

/// HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods. +optional +patchMergeKey=ip +patchStrategy=merge
    #[serde(rename = "hostAliases")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_aliases: Option<Vec<models::HostAlias>>,

/// Use the host's ipc namespace. Optional: Default to false. +k8s:conversion-gen=false +optional
    #[serde(rename = "hostIPC")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_ipc: Option<bool>,

/// Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false. +k8s:conversion-gen=false +optional
    #[serde(rename = "hostNetwork")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_network: Option<bool>,

/// Use the host's pid namespace. Optional: Default to false. +k8s:conversion-gen=false +optional
    #[serde(rename = "hostPID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_pid: Option<bool>,

/// Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value. +optional
    #[serde(rename = "hostname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostname: Option<String>,

/// ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod +optional +patchMergeKey=name +patchStrategy=merge
    #[serde(rename = "imagePullSecrets")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_pull_secrets: Option<Vec<models::LocalObjectReference>>,

/// List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ +patchMergeKey=name +patchStrategy=merge
    #[serde(rename = "initContainers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub init_containers: Option<Vec<models::Container>>,

/// NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements. +optional
    #[serde(rename = "nodeName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_name: Option<String>,

/// NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/ +optional +mapType=atomic
    #[serde(rename = "nodeSelector")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_selector: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "os")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os: Option<models::PodOs>,

    #[serde(rename = "overhead")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub overhead: Option<std::collections::HashMap<String, models::Quantity>>,

/// +enum
    #[serde(rename = "preemptionPolicy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub preemption_policy: Option<String>,

/// The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority. +optional
    #[serde(rename = "priority")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority: Option<i32>,

/// If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default. +optional
    #[serde(rename = "priorityClassName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority_class_name: Option<String>,

/// If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates +optional
    #[serde(rename = "readinessGates")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub readiness_gates: Option<Vec<models::PodReadinessGate>>,

/// Only one of the following restart policies may be specified. If none of the following policies is specified, the default one is RestartPolicyAlways. +enum
    #[serde(rename = "restartPolicy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restart_policy: Option<String>,

/// RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class This is a beta feature as of Kubernetes v1.14. +optional
    #[serde(rename = "runtimeClassName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub runtime_class_name: Option<String>,

/// If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler. +optional
    #[serde(rename = "schedulerName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scheduler_name: Option<String>,

    #[serde(rename = "securityContext")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_context: Option<models::PodSecurityContext>,

/// DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead. +k8s:conversion-gen=false +optional
    #[serde(rename = "serviceAccount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_account: Option<String>,

/// ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ +optional
    #[serde(rename = "serviceAccountName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_account_name: Option<String>,

/// If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false. +optional
    #[serde(rename = "setHostnameAsFQDN")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub set_hostname_as_fqdn: Option<bool>,

/// Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false. +k8s:conversion-gen=false +optional
    #[serde(rename = "shareProcessNamespace")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub share_process_namespace: Option<bool>,

/// If specified, the fully qualified Pod hostname will be \"<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>\". If not specified, the pod will not have a domainname at all. +optional
    #[serde(rename = "subdomain")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subdomain: Option<String>,

/// Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds. +optional
    #[serde(rename = "terminationGracePeriodSeconds")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub termination_grace_period_seconds: Option<i64>,

/// If specified, the pod's tolerations. +optional
    #[serde(rename = "tolerations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tolerations: Option<Vec<models::Toleration>>,

/// TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed. +optional +patchMergeKey=topologyKey +patchStrategy=merge +listType=map +listMapKey=topologyKey +listMapKey=whenUnsatisfiable
    #[serde(rename = "topologySpreadConstraints")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub topology_spread_constraints: Option<Vec<models::TopologySpreadConstraint>>,

/// List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes +optional +patchMergeKey=name +patchStrategy=merge,retainKeys
    #[serde(rename = "volumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes: Option<Vec<models::Volume>>,

}


impl PodSpec {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodSpec {
        PodSpec {
            active_deadline_seconds: None,
            affinity: None,
            automount_service_account_token: None,
            containers: None,
            dns_config: None,
            dns_policy: None,
            enable_service_links: None,
            ephemeral_containers: None,
            host_aliases: None,
            host_ipc: None,
            host_network: None,
            host_pid: None,
            hostname: None,
            image_pull_secrets: None,
            init_containers: None,
            node_name: None,
            node_selector: None,
            os: None,
            overhead: None,
            preemption_policy: None,
            priority: None,
            priority_class_name: None,
            readiness_gates: None,
            restart_policy: None,
            runtime_class_name: None,
            scheduler_name: None,
            security_context: None,
            service_account: None,
            service_account_name: None,
            set_hostname_as_fqdn: None,
            share_process_namespace: None,
            subdomain: None,
            termination_grace_period_seconds: None,
            tolerations: None,
            topology_spread_constraints: None,
            volumes: None,
        }
    }
}

/// Converts the PodSpec value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PodSpec {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.active_deadline_seconds.as_ref().map(|active_deadline_seconds| {
                [
                    "activeDeadlineSeconds".to_string(),
                    active_deadline_seconds.to_string(),
                ].join(",")
            }),

            // Skipping affinity in query parameter serialization


            self.automount_service_account_token.as_ref().map(|automount_service_account_token| {
                [
                    "automountServiceAccountToken".to_string(),
                    automount_service_account_token.to_string(),
                ].join(",")
            }),

            // Skipping containers in query parameter serialization

            // Skipping dnsConfig in query parameter serialization


            self.dns_policy.as_ref().map(|dns_policy| {
                [
                    "dnsPolicy".to_string(),
                    dns_policy.to_string(),
                ].join(",")
            }),


            self.enable_service_links.as_ref().map(|enable_service_links| {
                [
                    "enableServiceLinks".to_string(),
                    enable_service_links.to_string(),
                ].join(",")
            }),

            // Skipping ephemeralContainers in query parameter serialization

            // Skipping hostAliases in query parameter serialization


            self.host_ipc.as_ref().map(|host_ipc| {
                [
                    "hostIPC".to_string(),
                    host_ipc.to_string(),
                ].join(",")
            }),


            self.host_network.as_ref().map(|host_network| {
                [
                    "hostNetwork".to_string(),
                    host_network.to_string(),
                ].join(",")
            }),


            self.host_pid.as_ref().map(|host_pid| {
                [
                    "hostPID".to_string(),
                    host_pid.to_string(),
                ].join(",")
            }),


            self.hostname.as_ref().map(|hostname| {
                [
                    "hostname".to_string(),
                    hostname.to_string(),
                ].join(",")
            }),

            // Skipping imagePullSecrets in query parameter serialization

            // Skipping initContainers in query parameter serialization


            self.node_name.as_ref().map(|node_name| {
                [
                    "nodeName".to_string(),
                    node_name.to_string(),
                ].join(",")
            }),

            // Skipping nodeSelector in query parameter serialization

            // Skipping os in query parameter serialization

            // Skipping overhead in query parameter serialization
            // Skipping overhead in query parameter serialization


            self.preemption_policy.as_ref().map(|preemption_policy| {
                [
                    "preemptionPolicy".to_string(),
                    preemption_policy.to_string(),
                ].join(",")
            }),


            self.priority.as_ref().map(|priority| {
                [
                    "priority".to_string(),
                    priority.to_string(),
                ].join(",")
            }),


            self.priority_class_name.as_ref().map(|priority_class_name| {
                [
                    "priorityClassName".to_string(),
                    priority_class_name.to_string(),
                ].join(",")
            }),

            // Skipping readinessGates in query parameter serialization


            self.restart_policy.as_ref().map(|restart_policy| {
                [
                    "restartPolicy".to_string(),
                    restart_policy.to_string(),
                ].join(",")
            }),


            self.runtime_class_name.as_ref().map(|runtime_class_name| {
                [
                    "runtimeClassName".to_string(),
                    runtime_class_name.to_string(),
                ].join(",")
            }),


            self.scheduler_name.as_ref().map(|scheduler_name| {
                [
                    "schedulerName".to_string(),
                    scheduler_name.to_string(),
                ].join(",")
            }),

            // Skipping securityContext in query parameter serialization


            self.service_account.as_ref().map(|service_account| {
                [
                    "serviceAccount".to_string(),
                    service_account.to_string(),
                ].join(",")
            }),


            self.service_account_name.as_ref().map(|service_account_name| {
                [
                    "serviceAccountName".to_string(),
                    service_account_name.to_string(),
                ].join(",")
            }),


            self.set_hostname_as_fqdn.as_ref().map(|set_hostname_as_fqdn| {
                [
                    "setHostnameAsFQDN".to_string(),
                    set_hostname_as_fqdn.to_string(),
                ].join(",")
            }),


            self.share_process_namespace.as_ref().map(|share_process_namespace| {
                [
                    "shareProcessNamespace".to_string(),
                    share_process_namespace.to_string(),
                ].join(",")
            }),


            self.subdomain.as_ref().map(|subdomain| {
                [
                    "subdomain".to_string(),
                    subdomain.to_string(),
                ].join(",")
            }),


            self.termination_grace_period_seconds.as_ref().map(|termination_grace_period_seconds| {
                [
                    "terminationGracePeriodSeconds".to_string(),
                    termination_grace_period_seconds.to_string(),
                ].join(",")
            }),

            // Skipping tolerations in query parameter serialization

            // Skipping topologySpreadConstraints in query parameter serialization

            // Skipping volumes in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodSpec value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodSpec {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub active_deadline_seconds: Vec<i64>,
            pub affinity: Vec<models::Affinity>,
            pub automount_service_account_token: Vec<bool>,
            pub containers: Vec<Vec<models::Container>>,
            pub dns_config: Vec<models::PodDnsConfig>,
            pub dns_policy: Vec<String>,
            pub enable_service_links: Vec<bool>,
            pub ephemeral_containers: Vec<Vec<models::EphemeralContainer>>,
            pub host_aliases: Vec<Vec<models::HostAlias>>,
            pub host_ipc: Vec<bool>,
            pub host_network: Vec<bool>,
            pub host_pid: Vec<bool>,
            pub hostname: Vec<String>,
            pub image_pull_secrets: Vec<Vec<models::LocalObjectReference>>,
            pub init_containers: Vec<Vec<models::Container>>,
            pub node_name: Vec<String>,
            pub node_selector: Vec<std::collections::HashMap<String, String>>,
            pub os: Vec<models::PodOs>,
            pub overhead: Vec<std::collections::HashMap<String, models::Quantity>>,
            pub preemption_policy: Vec<String>,
            pub priority: Vec<i32>,
            pub priority_class_name: Vec<String>,
            pub readiness_gates: Vec<Vec<models::PodReadinessGate>>,
            pub restart_policy: Vec<String>,
            pub runtime_class_name: Vec<String>,
            pub scheduler_name: Vec<String>,
            pub security_context: Vec<models::PodSecurityContext>,
            pub service_account: Vec<String>,
            pub service_account_name: Vec<String>,
            pub set_hostname_as_fqdn: Vec<bool>,
            pub share_process_namespace: Vec<bool>,
            pub subdomain: Vec<String>,
            pub termination_grace_period_seconds: Vec<i64>,
            pub tolerations: Vec<Vec<models::Toleration>>,
            pub topology_spread_constraints: Vec<Vec<models::TopologySpreadConstraint>>,
            pub volumes: Vec<Vec<models::Volume>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodSpec".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "activeDeadlineSeconds" => intermediate_rep.active_deadline_seconds.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "affinity" => intermediate_rep.affinity.push(<models::Affinity as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "automountServiceAccountToken" => intermediate_rep.automount_service_account_token.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "containers" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpec".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "dnsConfig" => intermediate_rep.dns_config.push(<models::PodDnsConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dnsPolicy" => intermediate_rep.dns_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "enableServiceLinks" => intermediate_rep.enable_service_links.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ephemeralContainers" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpec".to_string()),
                    "hostAliases" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpec".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "hostIPC" => intermediate_rep.host_ipc.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hostNetwork" => intermediate_rep.host_network.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hostPID" => intermediate_rep.host_pid.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hostname" => intermediate_rep.hostname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "imagePullSecrets" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpec".to_string()),
                    "initContainers" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpec".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "nodeName" => intermediate_rep.node_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "nodeSelector" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpec".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "os" => intermediate_rep.os.push(<models::PodOs as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "overhead" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpec".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "preemptionPolicy" => intermediate_rep.preemption_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "priority" => intermediate_rep.priority.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "priorityClassName" => intermediate_rep.priority_class_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "readinessGates" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpec".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "restartPolicy" => intermediate_rep.restart_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "runtimeClassName" => intermediate_rep.runtime_class_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "schedulerName" => intermediate_rep.scheduler_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "securityContext" => intermediate_rep.security_context.push(<models::PodSecurityContext as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "serviceAccount" => intermediate_rep.service_account.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "serviceAccountName" => intermediate_rep.service_account_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "setHostnameAsFQDN" => intermediate_rep.set_hostname_as_fqdn.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shareProcessNamespace" => intermediate_rep.share_process_namespace.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "subdomain" => intermediate_rep.subdomain.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "terminationGracePeriodSeconds" => intermediate_rep.termination_grace_period_seconds.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tolerations" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpec".to_string()),
                    "topologySpreadConstraints" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpec".to_string()),
                    "volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpec".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodSpec".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodSpec {
            active_deadline_seconds: intermediate_rep.active_deadline_seconds.into_iter().next(),
            affinity: intermediate_rep.affinity.into_iter().next(),
            automount_service_account_token: intermediate_rep.automount_service_account_token.into_iter().next(),
            containers: intermediate_rep.containers.into_iter().next(),
            dns_config: intermediate_rep.dns_config.into_iter().next(),
            dns_policy: intermediate_rep.dns_policy.into_iter().next(),
            enable_service_links: intermediate_rep.enable_service_links.into_iter().next(),
            ephemeral_containers: intermediate_rep.ephemeral_containers.into_iter().next(),
            host_aliases: intermediate_rep.host_aliases.into_iter().next(),
            host_ipc: intermediate_rep.host_ipc.into_iter().next(),
            host_network: intermediate_rep.host_network.into_iter().next(),
            host_pid: intermediate_rep.host_pid.into_iter().next(),
            hostname: intermediate_rep.hostname.into_iter().next(),
            image_pull_secrets: intermediate_rep.image_pull_secrets.into_iter().next(),
            init_containers: intermediate_rep.init_containers.into_iter().next(),
            node_name: intermediate_rep.node_name.into_iter().next(),
            node_selector: intermediate_rep.node_selector.into_iter().next(),
            os: intermediate_rep.os.into_iter().next(),
            overhead: intermediate_rep.overhead.into_iter().next(),
            preemption_policy: intermediate_rep.preemption_policy.into_iter().next(),
            priority: intermediate_rep.priority.into_iter().next(),
            priority_class_name: intermediate_rep.priority_class_name.into_iter().next(),
            readiness_gates: intermediate_rep.readiness_gates.into_iter().next(),
            restart_policy: intermediate_rep.restart_policy.into_iter().next(),
            runtime_class_name: intermediate_rep.runtime_class_name.into_iter().next(),
            scheduler_name: intermediate_rep.scheduler_name.into_iter().next(),
            security_context: intermediate_rep.security_context.into_iter().next(),
            service_account: intermediate_rep.service_account.into_iter().next(),
            service_account_name: intermediate_rep.service_account_name.into_iter().next(),
            set_hostname_as_fqdn: intermediate_rep.set_hostname_as_fqdn.into_iter().next(),
            share_process_namespace: intermediate_rep.share_process_namespace.into_iter().next(),
            subdomain: intermediate_rep.subdomain.into_iter().next(),
            termination_grace_period_seconds: intermediate_rep.termination_grace_period_seconds.into_iter().next(),
            tolerations: intermediate_rep.tolerations.into_iter().next(),
            topology_spread_constraints: intermediate_rep.topology_spread_constraints.into_iter().next(),
            volumes: intermediate_rep.volumes.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodSpec> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodSpec>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodSpec>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodSpec - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodSpec> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodSpec as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodSpec - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Port An open port on a container



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Port {
/// Host IP address that the container's port is mapped to
    #[serde(rename = "IP")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ip: Option<String>,

/// Port on the container
    #[serde(rename = "PrivatePort")]
    pub private_port: i32,

/// Port exposed on the host
    #[serde(rename = "PublicPort")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_port: Option<i32>,

/// type
    #[serde(rename = "Type")]
    pub r#type: String,

}


impl Port {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(private_port: i32, r#type: String, ) -> Port {
        Port {
            ip: None,
            private_port,
            public_port: None,
            r#type,
        }
    }
}

/// Converts the Port value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Port {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.ip.as_ref().map(|ip| {
                [
                    "IP".to_string(),
                    ip.to_string(),
                ].join(",")
            }),


            Some("PrivatePort".to_string()),
            Some(self.private_port.to_string()),


            self.public_port.as_ref().map(|public_port| {
                [
                    "PublicPort".to_string(),
                    public_port.to_string(),
                ].join(",")
            }),


            Some("Type".to_string()),
            Some(self.r#type.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Port value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Port {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ip: Vec<String>,
            pub private_port: Vec<i32>,
            pub public_port: Vec<i32>,
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Port".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "IP" => intermediate_rep.ip.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PrivatePort" => intermediate_rep.private_port.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PublicPort" => intermediate_rep.public_port.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Port".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Port {
            ip: intermediate_rep.ip.into_iter().next(),
            private_port: intermediate_rep.private_port.into_iter().next().ok_or_else(|| "PrivatePort missing in Port".to_string())?,
            public_port: intermediate_rep.public_port.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "Type missing in Port".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Port> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Port>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Port>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Port - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Port> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Port as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Port - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PortBinding represents a binding between a Host IP address and a Host Port



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PortBinding {
/// HostIP is the host IP Address
    #[serde(rename = "HostIp")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_ip: Option<String>,

/// HostPort is the host port number
    #[serde(rename = "HostPort")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_port: Option<String>,

}


impl PortBinding {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PortBinding {
        PortBinding {
            host_ip: None,
            host_port: None,
        }
    }
}

/// Converts the PortBinding value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PortBinding {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.host_ip.as_ref().map(|host_ip| {
                [
                    "HostIp".to_string(),
                    host_ip.to_string(),
                ].join(",")
            }),


            self.host_port.as_ref().map(|host_port| {
                [
                    "HostPort".to_string(),
                    host_port.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PortBinding value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PortBinding {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub host_ip: Vec<String>,
            pub host_port: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PortBinding".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "HostIp" => intermediate_rep.host_ip.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "HostPort" => intermediate_rep.host_port.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PortBinding".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PortBinding {
            host_ip: intermediate_rep.host_ip.into_iter().next(),
            host_port: intermediate_rep.host_port.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PortBinding> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PortBinding>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PortBinding>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PortBinding - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PortBinding> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PortBinding as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PortBinding - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PortworxVolumeSource {
/// FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\". Implicitly inferred to be \"ext4\" if unspecified.
    #[serde(rename = "fsType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fs_type: Option<String>,

/// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. +optional
    #[serde(rename = "readOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

/// VolumeID uniquely identifies a Portworx volume
    #[serde(rename = "volumeID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_id: Option<String>,

}


impl PortworxVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PortworxVolumeSource {
        PortworxVolumeSource {
            fs_type: None,
            read_only: None,
            volume_id: None,
        }
    }
}

/// Converts the PortworxVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PortworxVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.fs_type.as_ref().map(|fs_type| {
                [
                    "fsType".to_string(),
                    fs_type.to_string(),
                ].join(",")
            }),


            self.read_only.as_ref().map(|read_only| {
                [
                    "readOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),


            self.volume_id.as_ref().map(|volume_id| {
                [
                    "volumeID".to_string(),
                    volume_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PortworxVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PortworxVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub fs_type: Vec<String>,
            pub read_only: Vec<bool>,
            pub volume_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PortworxVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "fsType" => intermediate_rep.fs_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "readOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "volumeID" => intermediate_rep.volume_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PortworxVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PortworxVolumeSource {
            fs_type: intermediate_rep.fs_type.into_iter().next(),
            read_only: intermediate_rep.read_only.into_iter().next(),
            volume_id: intermediate_rep.volume_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PortworxVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PortworxVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PortworxVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PortworxVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PortworxVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PortworxVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PortworxVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// +enum
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PreemptionPolicy(String);

impl validator::Validate for PreemptionPolicy {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for PreemptionPolicy {
    fn from(x: String) -> Self {
        PreemptionPolicy(x)
    }
}

impl std::string::ToString for PreemptionPolicy {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for PreemptionPolicy {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(PreemptionPolicy(x.to_string()))
    }
}

impl std::convert::From<PreemptionPolicy> for String {
    fn from(x: PreemptionPolicy) -> Self {
        x.0
    }
}

impl std::ops::Deref for PreemptionPolicy {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for PreemptionPolicy {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PreferredSchedulingTerm {
    #[serde(rename = "preference")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub preference: Option<models::NodeSelectorTerm>,

/// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
    #[serde(rename = "weight")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight: Option<i32>,

}


impl PreferredSchedulingTerm {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PreferredSchedulingTerm {
        PreferredSchedulingTerm {
            preference: None,
            weight: None,
        }
    }
}

/// Converts the PreferredSchedulingTerm value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PreferredSchedulingTerm {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping preference in query parameter serialization


            self.weight.as_ref().map(|weight| {
                [
                    "weight".to_string(),
                    weight.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PreferredSchedulingTerm value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PreferredSchedulingTerm {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub preference: Vec<models::NodeSelectorTerm>,
            pub weight: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PreferredSchedulingTerm".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "preference" => intermediate_rep.preference.push(<models::NodeSelectorTerm as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "weight" => intermediate_rep.weight.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PreferredSchedulingTerm".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PreferredSchedulingTerm {
            preference: intermediate_rep.preference.into_iter().next(),
            weight: intermediate_rep.weight.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PreferredSchedulingTerm> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PreferredSchedulingTerm>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PreferredSchedulingTerm>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PreferredSchedulingTerm - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PreferredSchedulingTerm> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PreferredSchedulingTerm as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PreferredSchedulingTerm - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Probe {
    #[serde(rename = "exec")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exec: Option<models::ExecAction>,

/// Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. +optional
    #[serde(rename = "failureThreshold")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub failure_threshold: Option<i32>,

    #[serde(rename = "grpc")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub grpc: Option<models::GrpcAction>,

    #[serde(rename = "httpGet")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub http_get: Option<models::HttpGetAction>,

/// Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes +optional
    #[serde(rename = "initialDelaySeconds")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub initial_delay_seconds: Option<i32>,

/// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. +optional
    #[serde(rename = "periodSeconds")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub period_seconds: Option<i32>,

/// Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. +optional
    #[serde(rename = "successThreshold")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub success_threshold: Option<i32>,

    #[serde(rename = "tcpSocket")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tcp_socket: Option<models::TcpSocketAction>,

/// Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset. +optional
    #[serde(rename = "terminationGracePeriodSeconds")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub termination_grace_period_seconds: Option<i64>,

/// Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes +optional
    #[serde(rename = "timeoutSeconds")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeout_seconds: Option<i32>,

}


impl Probe {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Probe {
        Probe {
            exec: None,
            failure_threshold: None,
            grpc: None,
            http_get: None,
            initial_delay_seconds: None,
            period_seconds: None,
            success_threshold: None,
            tcp_socket: None,
            termination_grace_period_seconds: None,
            timeout_seconds: None,
        }
    }
}

/// Converts the Probe value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Probe {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping exec in query parameter serialization


            self.failure_threshold.as_ref().map(|failure_threshold| {
                [
                    "failureThreshold".to_string(),
                    failure_threshold.to_string(),
                ].join(",")
            }),

            // Skipping grpc in query parameter serialization

            // Skipping httpGet in query parameter serialization


            self.initial_delay_seconds.as_ref().map(|initial_delay_seconds| {
                [
                    "initialDelaySeconds".to_string(),
                    initial_delay_seconds.to_string(),
                ].join(",")
            }),


            self.period_seconds.as_ref().map(|period_seconds| {
                [
                    "periodSeconds".to_string(),
                    period_seconds.to_string(),
                ].join(",")
            }),


            self.success_threshold.as_ref().map(|success_threshold| {
                [
                    "successThreshold".to_string(),
                    success_threshold.to_string(),
                ].join(",")
            }),

            // Skipping tcpSocket in query parameter serialization


            self.termination_grace_period_seconds.as_ref().map(|termination_grace_period_seconds| {
                [
                    "terminationGracePeriodSeconds".to_string(),
                    termination_grace_period_seconds.to_string(),
                ].join(",")
            }),


            self.timeout_seconds.as_ref().map(|timeout_seconds| {
                [
                    "timeoutSeconds".to_string(),
                    timeout_seconds.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Probe value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Probe {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub exec: Vec<models::ExecAction>,
            pub failure_threshold: Vec<i32>,
            pub grpc: Vec<models::GrpcAction>,
            pub http_get: Vec<models::HttpGetAction>,
            pub initial_delay_seconds: Vec<i32>,
            pub period_seconds: Vec<i32>,
            pub success_threshold: Vec<i32>,
            pub tcp_socket: Vec<models::TcpSocketAction>,
            pub termination_grace_period_seconds: Vec<i64>,
            pub timeout_seconds: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Probe".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "exec" => intermediate_rep.exec.push(<models::ExecAction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "failureThreshold" => intermediate_rep.failure_threshold.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "grpc" => intermediate_rep.grpc.push(<models::GrpcAction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "httpGet" => intermediate_rep.http_get.push(<models::HttpGetAction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "initialDelaySeconds" => intermediate_rep.initial_delay_seconds.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "periodSeconds" => intermediate_rep.period_seconds.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "successThreshold" => intermediate_rep.success_threshold.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tcpSocket" => intermediate_rep.tcp_socket.push(<models::TcpSocketAction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "terminationGracePeriodSeconds" => intermediate_rep.termination_grace_period_seconds.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "timeoutSeconds" => intermediate_rep.timeout_seconds.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Probe".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Probe {
            exec: intermediate_rep.exec.into_iter().next(),
            failure_threshold: intermediate_rep.failure_threshold.into_iter().next(),
            grpc: intermediate_rep.grpc.into_iter().next(),
            http_get: intermediate_rep.http_get.into_iter().next(),
            initial_delay_seconds: intermediate_rep.initial_delay_seconds.into_iter().next(),
            period_seconds: intermediate_rep.period_seconds.into_iter().next(),
            success_threshold: intermediate_rep.success_threshold.into_iter().next(),
            tcp_socket: intermediate_rep.tcp_socket.into_iter().next(),
            termination_grace_period_seconds: intermediate_rep.termination_grace_period_seconds.into_iter().next(),
            timeout_seconds: intermediate_rep.timeout_seconds.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Probe> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Probe>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Probe>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Probe - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Probe> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Probe as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Probe - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// One and only one of the fields must be specified.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProbeHandler {
    #[serde(rename = "exec")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exec: Option<models::ExecAction>,

    #[serde(rename = "grpc")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub grpc: Option<models::GrpcAction>,

    #[serde(rename = "httpGet")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub http_get: Option<models::HttpGetAction>,

    #[serde(rename = "tcpSocket")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tcp_socket: Option<models::TcpSocketAction>,

}


impl ProbeHandler {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ProbeHandler {
        ProbeHandler {
            exec: None,
            grpc: None,
            http_get: None,
            tcp_socket: None,
        }
    }
}

/// Converts the ProbeHandler value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ProbeHandler {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping exec in query parameter serialization

            // Skipping grpc in query parameter serialization

            // Skipping httpGet in query parameter serialization

            // Skipping tcpSocket in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProbeHandler value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProbeHandler {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub exec: Vec<models::ExecAction>,
            pub grpc: Vec<models::GrpcAction>,
            pub http_get: Vec<models::HttpGetAction>,
            pub tcp_socket: Vec<models::TcpSocketAction>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProbeHandler".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "exec" => intermediate_rep.exec.push(<models::ExecAction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "grpc" => intermediate_rep.grpc.push(<models::GrpcAction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "httpGet" => intermediate_rep.http_get.push(<models::HttpGetAction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tcpSocket" => intermediate_rep.tcp_socket.push(<models::TcpSocketAction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProbeHandler".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProbeHandler {
            exec: intermediate_rep.exec.into_iter().next(),
            grpc: intermediate_rep.grpc.into_iter().next(),
            http_get: intermediate_rep.http_get.into_iter().next(),
            tcp_socket: intermediate_rep.tcp_socket.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProbeHandler> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProbeHandler>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProbeHandler>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProbeHandler - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProbeHandler> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProbeHandler as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProbeHandler - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// +enum
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProcMountType(String);

impl validator::Validate for ProcMountType {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for ProcMountType {
    fn from(x: String) -> Self {
        ProcMountType(x)
    }
}

impl std::string::ToString for ProcMountType {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for ProcMountType {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(ProcMountType(x.to_string()))
    }
}

impl std::convert::From<ProcMountType> for String {
    fn from(x: ProcMountType) -> Self {
        x.0
    }
}

impl std::ops::Deref for ProcMountType {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for ProcMountType {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// Represents a projected volume source



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectedVolumeSource {
/// Mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. +optional
    #[serde(rename = "defaultMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_mode: Option<i32>,

/// list of volume projections +optional
    #[serde(rename = "sources")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sources: Option<Vec<models::VolumeProjection>>,

}


impl ProjectedVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ProjectedVolumeSource {
        ProjectedVolumeSource {
            default_mode: None,
            sources: None,
        }
    }
}

/// Converts the ProjectedVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ProjectedVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.default_mode.as_ref().map(|default_mode| {
                [
                    "defaultMode".to_string(),
                    default_mode.to_string(),
                ].join(",")
            }),

            // Skipping sources in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectedVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectedVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub default_mode: Vec<i32>,
            pub sources: Vec<Vec<models::VolumeProjection>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectedVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "defaultMode" => intermediate_rep.default_mode.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "sources" => return std::result::Result::Err("Parsing a container in this style is not supported in ProjectedVolumeSource".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectedVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectedVolumeSource {
            default_mode: intermediate_rep.default_mode.into_iter().next(),
            sources: intermediate_rep.sources.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectedVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectedVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectedVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProjectedVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectedVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectedVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProjectedVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Propagation(String);

impl validator::Validate for Propagation {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for Propagation {
    fn from(x: String) -> Self {
        Propagation(x)
    }
}

impl std::string::ToString for Propagation {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for Propagation {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Propagation(x.to_string()))
    }
}

impl std::convert::From<Propagation> for String {
    fn from(x: Propagation) -> Self {
        x.0
    }
}

impl std::ops::Deref for Propagation {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Propagation {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// +enum
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Protocol(String);

impl validator::Validate for Protocol {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for Protocol {
    fn from(x: String) -> Self {
        Protocol(x)
    }
}

impl std::string::ToString for Protocol {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for Protocol {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Protocol(x.to_string()))
    }
}

impl std::convert::From<Protocol> for String {
    fn from(x: Protocol) -> Self {
        x.0
    }
}

impl std::ops::Deref for Protocol {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Protocol {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PublicKey {
/// PublicKey is the key in the authorized key format.
    #[serde(rename = "publicKey")]
    pub public_key: String,

}


impl PublicKey {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(public_key: String, ) -> PublicKey {
        PublicKey {
            public_key,
        }
    }
}

/// Converts the PublicKey value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PublicKey {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("publicKey".to_string()),
            Some(self.public_key.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PublicKey value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PublicKey {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub public_key: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PublicKey".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "publicKey" => intermediate_rep.public_key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PublicKey".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PublicKey {
            public_key: intermediate_rep.public_key.into_iter().next().ok_or_else(|| "publicKey missing in PublicKey".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PublicKey> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PublicKey>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PublicKey>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PublicKey - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PublicKey> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PublicKey as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PublicKey - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PublicKeyAuthRequest {
/// ClientVersion contains the version string the connecting client sent if any. May be empty if the client did not provide a client version.
    #[serde(rename = "clientVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_version: Option<String>,

/// ConnectionID is an opaque ID to identify the SSH connection in question.
    #[serde(rename = "connectionId")]
    pub connection_id: String,

/// Environment is a set of key-value pairs provided by the authentication or configuration system and may be exposed by the backend.
    #[serde(rename = "environment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<std::collections::HashMap<String, models::MetadataValue>>,

/// Files is a key-value pair of file names and their content set by the authentication or configuration system and consumed by the backend.
    #[serde(rename = "files")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub files: Option<std::collections::HashMap<String, models::BinaryMetadataValue>>,

/// Metadata is a set of key-value pairs that carry additional information from the authentication and configuration system to the backends. Backends can expose this information as container labels, environment variables, or other places.
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, models::MetadataValue>>,

/// PublicKey is the key in the authorized key format.
    #[serde(rename = "publicKey")]
    pub public_key: String,

/// RemoteAddress is the IP address and port of the user trying to authenticate.
    #[serde(rename = "remoteAddress")]
    pub remote_address: String,

/// Username is the username provided on login by the client. This may, but must not necessarily match the authenticated username.
    #[serde(rename = "username")]
    pub username: String,

}


impl PublicKeyAuthRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(connection_id: String, public_key: String, remote_address: String, username: String, ) -> PublicKeyAuthRequest {
        PublicKeyAuthRequest {
            client_version: None,
            connection_id,
            environment: None,
            files: None,
            metadata: None,
            public_key,
            remote_address,
            username,
        }
    }
}

/// Converts the PublicKeyAuthRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PublicKeyAuthRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.client_version.as_ref().map(|client_version| {
                [
                    "clientVersion".to_string(),
                    client_version.to_string(),
                ].join(",")
            }),


            Some("connectionId".to_string()),
            Some(self.connection_id.to_string()),

            // Skipping environment in query parameter serialization
            // Skipping environment in query parameter serialization

            // Skipping files in query parameter serialization
            // Skipping files in query parameter serialization

            // Skipping metadata in query parameter serialization
            // Skipping metadata in query parameter serialization


            Some("publicKey".to_string()),
            Some(self.public_key.to_string()),


            Some("remoteAddress".to_string()),
            Some(self.remote_address.to_string()),


            Some("username".to_string()),
            Some(self.username.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PublicKeyAuthRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PublicKeyAuthRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub client_version: Vec<String>,
            pub connection_id: Vec<String>,
            pub environment: Vec<std::collections::HashMap<String, models::MetadataValue>>,
            pub files: Vec<std::collections::HashMap<String, models::BinaryMetadataValue>>,
            pub metadata: Vec<std::collections::HashMap<String, models::MetadataValue>>,
            pub public_key: Vec<String>,
            pub remote_address: Vec<String>,
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PublicKeyAuthRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "clientVersion" => intermediate_rep.client_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "connectionId" => intermediate_rep.connection_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "environment" => return std::result::Result::Err("Parsing a container in this style is not supported in PublicKeyAuthRequest".to_string()),
                    "files" => return std::result::Result::Err("Parsing a container in this style is not supported in PublicKeyAuthRequest".to_string()),
                    "metadata" => return std::result::Result::Err("Parsing a container in this style is not supported in PublicKeyAuthRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "publicKey" => intermediate_rep.public_key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "remoteAddress" => intermediate_rep.remote_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PublicKeyAuthRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PublicKeyAuthRequest {
            client_version: intermediate_rep.client_version.into_iter().next(),
            connection_id: intermediate_rep.connection_id.into_iter().next().ok_or_else(|| "connectionId missing in PublicKeyAuthRequest".to_string())?,
            environment: intermediate_rep.environment.into_iter().next(),
            files: intermediate_rep.files.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
            public_key: intermediate_rep.public_key.into_iter().next().ok_or_else(|| "publicKey missing in PublicKeyAuthRequest".to_string())?,
            remote_address: intermediate_rep.remote_address.into_iter().next().ok_or_else(|| "remoteAddress missing in PublicKeyAuthRequest".to_string())?,
            username: intermediate_rep.username.into_iter().next().ok_or_else(|| "username missing in PublicKeyAuthRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PublicKeyAuthRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PublicKeyAuthRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PublicKeyAuthRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PublicKeyAuthRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PublicKeyAuthRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PublicKeyAuthRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PublicKeyAuthRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PullPolicy describes a policy for if/when to pull a container image +enum
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PullPolicy(String);

impl validator::Validate for PullPolicy {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for PullPolicy {
    fn from(x: String) -> Self {
        PullPolicy(x)
    }
}

impl std::string::ToString for PullPolicy {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for PullPolicy {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(PullPolicy(x.to_string()))
    }
}

impl std::convert::From<PullPolicy> for String {
    fn from(x: PullPolicy) -> Self {
        x.0
    }
}

impl std::ops::Deref for PullPolicy {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for PullPolicy {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// Quobyte volumes do not support ownership management or SELinux relabeling.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QuobyteVolumeSource {
/// Group to map volume access to Default is no group +optional
    #[serde(rename = "group")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub group: Option<String>,

/// ReadOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false. +optional
    #[serde(rename = "readOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

/// Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
    #[serde(rename = "registry")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub registry: Option<String>,

/// Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin +optional
    #[serde(rename = "tenant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tenant: Option<String>,

/// User to map volume access to Defaults to serivceaccount user +optional
    #[serde(rename = "user")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

/// Volume is a string that references an already created Quobyte volume by name.
    #[serde(rename = "volume")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume: Option<String>,

}


impl QuobyteVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> QuobyteVolumeSource {
        QuobyteVolumeSource {
            group: None,
            read_only: None,
            registry: None,
            tenant: None,
            user: None,
            volume: None,
        }
    }
}

/// Converts the QuobyteVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QuobyteVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.group.as_ref().map(|group| {
                [
                    "group".to_string(),
                    group.to_string(),
                ].join(",")
            }),


            self.read_only.as_ref().map(|read_only| {
                [
                    "readOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),


            self.registry.as_ref().map(|registry| {
                [
                    "registry".to_string(),
                    registry.to_string(),
                ].join(",")
            }),


            self.tenant.as_ref().map(|tenant| {
                [
                    "tenant".to_string(),
                    tenant.to_string(),
                ].join(",")
            }),


            self.user.as_ref().map(|user| {
                [
                    "user".to_string(),
                    user.to_string(),
                ].join(",")
            }),


            self.volume.as_ref().map(|volume| {
                [
                    "volume".to_string(),
                    volume.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QuobyteVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QuobyteVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub group: Vec<String>,
            pub read_only: Vec<bool>,
            pub registry: Vec<String>,
            pub tenant: Vec<String>,
            pub user: Vec<String>,
            pub volume: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing QuobyteVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "group" => intermediate_rep.group.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "readOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "registry" => intermediate_rep.registry.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tenant" => intermediate_rep.tenant.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "user" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "volume" => intermediate_rep.volume.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing QuobyteVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QuobyteVolumeSource {
            group: intermediate_rep.group.into_iter().next(),
            read_only: intermediate_rep.read_only.into_iter().next(),
            registry: intermediate_rep.registry.into_iter().next(),
            tenant: intermediate_rep.tenant.into_iter().next(),
            user: intermediate_rep.user.into_iter().next(),
            volume: intermediate_rep.volume.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QuobyteVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<QuobyteVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<QuobyteVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for QuobyteVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<QuobyteVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <QuobyteVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into QuobyteVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// RBD volumes support ownership management and SELinux relabeling.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RbdVolumeSource {
/// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine +optional
    #[serde(rename = "fsType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fs_type: Option<String>,

/// The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    #[serde(rename = "image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image: Option<String>,

/// Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it +optional
    #[serde(rename = "keyring")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub keyring: Option<String>,

/// A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    #[serde(rename = "monitors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub monitors: Option<Vec<String>>,

/// The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it +optional
    #[serde(rename = "pool")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pool: Option<String>,

/// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it +optional
    #[serde(rename = "readOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

    #[serde(rename = "secretRef")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_ref: Option<models::LocalObjectReference>,

/// The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it +optional
    #[serde(rename = "user")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

}


impl RbdVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RbdVolumeSource {
        RbdVolumeSource {
            fs_type: None,
            image: None,
            keyring: None,
            monitors: None,
            pool: None,
            read_only: None,
            secret_ref: None,
            user: None,
        }
    }
}

/// Converts the RbdVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RbdVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.fs_type.as_ref().map(|fs_type| {
                [
                    "fsType".to_string(),
                    fs_type.to_string(),
                ].join(",")
            }),


            self.image.as_ref().map(|image| {
                [
                    "image".to_string(),
                    image.to_string(),
                ].join(",")
            }),


            self.keyring.as_ref().map(|keyring| {
                [
                    "keyring".to_string(),
                    keyring.to_string(),
                ].join(",")
            }),


            self.monitors.as_ref().map(|monitors| {
                [
                    "monitors".to_string(),
                    monitors.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.pool.as_ref().map(|pool| {
                [
                    "pool".to_string(),
                    pool.to_string(),
                ].join(",")
            }),


            self.read_only.as_ref().map(|read_only| {
                [
                    "readOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),

            // Skipping secretRef in query parameter serialization


            self.user.as_ref().map(|user| {
                [
                    "user".to_string(),
                    user.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RbdVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RbdVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub fs_type: Vec<String>,
            pub image: Vec<String>,
            pub keyring: Vec<String>,
            pub monitors: Vec<Vec<String>>,
            pub pool: Vec<String>,
            pub read_only: Vec<bool>,
            pub secret_ref: Vec<models::LocalObjectReference>,
            pub user: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RbdVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "fsType" => intermediate_rep.fs_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image" => intermediate_rep.image.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "keyring" => intermediate_rep.keyring.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "monitors" => return std::result::Result::Err("Parsing a container in this style is not supported in RbdVolumeSource".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pool" => intermediate_rep.pool.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "readOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "secretRef" => intermediate_rep.secret_ref.push(<models::LocalObjectReference as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "user" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RbdVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RbdVolumeSource {
            fs_type: intermediate_rep.fs_type.into_iter().next(),
            image: intermediate_rep.image.into_iter().next(),
            keyring: intermediate_rep.keyring.into_iter().next(),
            monitors: intermediate_rep.monitors.into_iter().next(),
            pool: intermediate_rep.pool.into_iter().next(),
            read_only: intermediate_rep.read_only.into_iter().next(),
            secret_ref: intermediate_rep.secret_ref.into_iter().next(),
            user: intermediate_rep.user.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RbdVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RbdVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RbdVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RbdVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RbdVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RbdVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RbdVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ResourceFieldSelector represents container resources (cpu, memory) and their output format +structType=atomic



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ResourceFieldSelector {
/// Container name: required for volumes, optional for env vars +optional
    #[serde(rename = "containerName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_name: Option<String>,

/// The serialization format is:  <quantity>        ::= <signedNumber><suffix> (Note that <suffix> may be empty, from the \"\" case in <decimalSI>.) <digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= \"+\" | \"-\" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html) <decimalSI>       ::= m | \"\" | k | M | G | T | P | E (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.) <decimalExponent> ::= \"e\" <signedNumber> | \"E\" <signedNumber>  No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.  When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.  Before serializing, Quantity will be put in \"canonical form\". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that: a. No precision is lost b. No fractional digits will be emitted c. The exponent (or suffix) is as large as possible. The sign will be omitted unless the number is negative.  Examples: 1.5 will be serialized as \"1500m\" 1.5Gi will be serialized as \"1536Mi\"  Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.  Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)  This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.  +protobuf=true +protobuf.embed=string +protobuf.options.marshal=false +protobuf.options.(gogoproto.goproto_stringer)=false +k8s:deepcopy-gen=true +k8s:openapi-gen=true
    #[serde(rename = "divisor")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub divisor: Option<crate::types::Object>,

/// Required: resource to select
    #[serde(rename = "resource")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resource: Option<String>,

}


impl ResourceFieldSelector {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ResourceFieldSelector {
        ResourceFieldSelector {
            container_name: None,
            divisor: None,
            resource: None,
        }
    }
}

/// Converts the ResourceFieldSelector value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ResourceFieldSelector {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.container_name.as_ref().map(|container_name| {
                [
                    "containerName".to_string(),
                    container_name.to_string(),
                ].join(",")
            }),

            // Skipping divisor in query parameter serialization


            self.resource.as_ref().map(|resource| {
                [
                    "resource".to_string(),
                    resource.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ResourceFieldSelector value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ResourceFieldSelector {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub container_name: Vec<String>,
            pub divisor: Vec<crate::types::Object>,
            pub resource: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ResourceFieldSelector".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "containerName" => intermediate_rep.container_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "divisor" => intermediate_rep.divisor.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "resource" => intermediate_rep.resource.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ResourceFieldSelector".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ResourceFieldSelector {
            container_name: intermediate_rep.container_name.into_iter().next(),
            divisor: intermediate_rep.divisor.into_iter().next(),
            resource: intermediate_rep.resource.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ResourceFieldSelector> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ResourceFieldSelector>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ResourceFieldSelector>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ResourceFieldSelector - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ResourceFieldSelector> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ResourceFieldSelector as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ResourceFieldSelector - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ResourceRequirements {
    #[serde(rename = "limits")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub limits: Option<std::collections::HashMap<String, models::Quantity>>,

    #[serde(rename = "requests")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub requests: Option<std::collections::HashMap<String, models::Quantity>>,

}


impl ResourceRequirements {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ResourceRequirements {
        ResourceRequirements {
            limits: None,
            requests: None,
        }
    }
}

/// Converts the ResourceRequirements value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ResourceRequirements {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping limits in query parameter serialization
            // Skipping limits in query parameter serialization

            // Skipping requests in query parameter serialization
            // Skipping requests in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ResourceRequirements value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ResourceRequirements {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub limits: Vec<std::collections::HashMap<String, models::Quantity>>,
            pub requests: Vec<std::collections::HashMap<String, models::Quantity>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ResourceRequirements".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "limits" => return std::result::Result::Err("Parsing a container in this style is not supported in ResourceRequirements".to_string()),
                    "requests" => return std::result::Result::Err("Parsing a container in this style is not supported in ResourceRequirements".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ResourceRequirements".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ResourceRequirements {
            limits: intermediate_rep.limits.into_iter().next(),
            requests: intermediate_rep.requests.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ResourceRequirements> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ResourceRequirements>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ResourceRequirements>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ResourceRequirements - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ResourceRequirements> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ResourceRequirements as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ResourceRequirements - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Resources contains container's resources (cgroups config, ulimits...)



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Resources {
    #[serde(rename = "BlkioDeviceReadBps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_read_bps: Option<Vec<models::ThrottleDevice>>,

    #[serde(rename = "BlkioDeviceReadIOps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_read_i_ops: Option<Vec<models::ThrottleDevice>>,

    #[serde(rename = "BlkioDeviceWriteBps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_write_bps: Option<Vec<models::ThrottleDevice>>,

    #[serde(rename = "BlkioDeviceWriteIOps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_write_i_ops: Option<Vec<models::ThrottleDevice>>,

    #[serde(rename = "BlkioWeight")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_weight: Option<i32>,

    #[serde(rename = "BlkioWeightDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_weight_device: Option<Vec<models::WeightDevice>>,

/// Applicable to UNIX platforms
    #[serde(rename = "CgroupParent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_parent: Option<String>,

/// Applicable to Windows
    #[serde(rename = "CpuCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_count: Option<i64>,

    #[serde(rename = "CpuPercent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_percent: Option<i64>,

    #[serde(rename = "CpuPeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_period: Option<i64>,

    #[serde(rename = "CpuQuota")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_quota: Option<i64>,

    #[serde(rename = "CpuRealtimePeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_realtime_period: Option<i64>,

    #[serde(rename = "CpuRealtimeRuntime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_realtime_runtime: Option<i64>,

/// Applicable to all platforms
    #[serde(rename = "CpuShares")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_shares: Option<i64>,

    #[serde(rename = "CpusetCpus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpuset_cpus: Option<String>,

    #[serde(rename = "CpusetMems")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpuset_mems: Option<String>,

    #[serde(rename = "DeviceCgroupRules")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_cgroup_rules: Option<Vec<String>>,

    #[serde(rename = "DeviceRequests")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_requests: Option<Vec<models::DeviceRequest>>,

    #[serde(rename = "Devices")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub devices: Option<Vec<models::DeviceMapping>>,

    #[serde(rename = "IOMaximumBandwidth")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub io_maximum_bandwidth: Option<i32>,

    #[serde(rename = "IOMaximumIOps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub io_maximum_i_ops: Option<i32>,

    #[serde(rename = "KernelMemory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kernel_memory: Option<i64>,

    #[serde(rename = "KernelMemoryTCP")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kernel_memory_tcp: Option<i64>,

    #[serde(rename = "Memory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory: Option<i64>,

    #[serde(rename = "MemoryReservation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_reservation: Option<i64>,

    #[serde(rename = "MemorySwap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_swap: Option<i64>,

    #[serde(rename = "MemorySwappiness")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_swappiness: Option<i64>,

    #[serde(rename = "NanoCpus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub nano_cpus: Option<i64>,

    #[serde(rename = "OomKillDisable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub oom_kill_disable: Option<bool>,

    #[serde(rename = "PidsLimit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pids_limit: Option<i64>,

    #[serde(rename = "Ulimits")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ulimits: Option<Vec<models::Ulimit>>,

}


impl Resources {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Resources {
        Resources {
            blkio_device_read_bps: None,
            blkio_device_read_i_ops: None,
            blkio_device_write_bps: None,
            blkio_device_write_i_ops: None,
            blkio_weight: None,
            blkio_weight_device: None,
            cgroup_parent: None,
            cpu_count: None,
            cpu_percent: None,
            cpu_period: None,
            cpu_quota: None,
            cpu_realtime_period: None,
            cpu_realtime_runtime: None,
            cpu_shares: None,
            cpuset_cpus: None,
            cpuset_mems: None,
            device_cgroup_rules: None,
            device_requests: None,
            devices: None,
            io_maximum_bandwidth: None,
            io_maximum_i_ops: None,
            kernel_memory: None,
            kernel_memory_tcp: None,
            memory: None,
            memory_reservation: None,
            memory_swap: None,
            memory_swappiness: None,
            nano_cpus: None,
            oom_kill_disable: None,
            pids_limit: None,
            ulimits: None,
        }
    }
}

/// Converts the Resources value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Resources {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping BlkioDeviceReadBps in query parameter serialization

            // Skipping BlkioDeviceReadIOps in query parameter serialization

            // Skipping BlkioDeviceWriteBps in query parameter serialization

            // Skipping BlkioDeviceWriteIOps in query parameter serialization


            self.blkio_weight.as_ref().map(|blkio_weight| {
                [
                    "BlkioWeight".to_string(),
                    blkio_weight.to_string(),
                ].join(",")
            }),

            // Skipping BlkioWeightDevice in query parameter serialization


            self.cgroup_parent.as_ref().map(|cgroup_parent| {
                [
                    "CgroupParent".to_string(),
                    cgroup_parent.to_string(),
                ].join(",")
            }),


            self.cpu_count.as_ref().map(|cpu_count| {
                [
                    "CpuCount".to_string(),
                    cpu_count.to_string(),
                ].join(",")
            }),


            self.cpu_percent.as_ref().map(|cpu_percent| {
                [
                    "CpuPercent".to_string(),
                    cpu_percent.to_string(),
                ].join(",")
            }),


            self.cpu_period.as_ref().map(|cpu_period| {
                [
                    "CpuPeriod".to_string(),
                    cpu_period.to_string(),
                ].join(",")
            }),


            self.cpu_quota.as_ref().map(|cpu_quota| {
                [
                    "CpuQuota".to_string(),
                    cpu_quota.to_string(),
                ].join(",")
            }),


            self.cpu_realtime_period.as_ref().map(|cpu_realtime_period| {
                [
                    "CpuRealtimePeriod".to_string(),
                    cpu_realtime_period.to_string(),
                ].join(",")
            }),


            self.cpu_realtime_runtime.as_ref().map(|cpu_realtime_runtime| {
                [
                    "CpuRealtimeRuntime".to_string(),
                    cpu_realtime_runtime.to_string(),
                ].join(",")
            }),


            self.cpu_shares.as_ref().map(|cpu_shares| {
                [
                    "CpuShares".to_string(),
                    cpu_shares.to_string(),
                ].join(",")
            }),


            self.cpuset_cpus.as_ref().map(|cpuset_cpus| {
                [
                    "CpusetCpus".to_string(),
                    cpuset_cpus.to_string(),
                ].join(",")
            }),


            self.cpuset_mems.as_ref().map(|cpuset_mems| {
                [
                    "CpusetMems".to_string(),
                    cpuset_mems.to_string(),
                ].join(",")
            }),


            self.device_cgroup_rules.as_ref().map(|device_cgroup_rules| {
                [
                    "DeviceCgroupRules".to_string(),
                    device_cgroup_rules.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping DeviceRequests in query parameter serialization

            // Skipping Devices in query parameter serialization


            self.io_maximum_bandwidth.as_ref().map(|io_maximum_bandwidth| {
                [
                    "IOMaximumBandwidth".to_string(),
                    io_maximum_bandwidth.to_string(),
                ].join(",")
            }),


            self.io_maximum_i_ops.as_ref().map(|io_maximum_i_ops| {
                [
                    "IOMaximumIOps".to_string(),
                    io_maximum_i_ops.to_string(),
                ].join(",")
            }),


            self.kernel_memory.as_ref().map(|kernel_memory| {
                [
                    "KernelMemory".to_string(),
                    kernel_memory.to_string(),
                ].join(",")
            }),


            self.kernel_memory_tcp.as_ref().map(|kernel_memory_tcp| {
                [
                    "KernelMemoryTCP".to_string(),
                    kernel_memory_tcp.to_string(),
                ].join(",")
            }),


            self.memory.as_ref().map(|memory| {
                [
                    "Memory".to_string(),
                    memory.to_string(),
                ].join(",")
            }),


            self.memory_reservation.as_ref().map(|memory_reservation| {
                [
                    "MemoryReservation".to_string(),
                    memory_reservation.to_string(),
                ].join(",")
            }),


            self.memory_swap.as_ref().map(|memory_swap| {
                [
                    "MemorySwap".to_string(),
                    memory_swap.to_string(),
                ].join(",")
            }),


            self.memory_swappiness.as_ref().map(|memory_swappiness| {
                [
                    "MemorySwappiness".to_string(),
                    memory_swappiness.to_string(),
                ].join(",")
            }),


            self.nano_cpus.as_ref().map(|nano_cpus| {
                [
                    "NanoCpus".to_string(),
                    nano_cpus.to_string(),
                ].join(",")
            }),


            self.oom_kill_disable.as_ref().map(|oom_kill_disable| {
                [
                    "OomKillDisable".to_string(),
                    oom_kill_disable.to_string(),
                ].join(",")
            }),


            self.pids_limit.as_ref().map(|pids_limit| {
                [
                    "PidsLimit".to_string(),
                    pids_limit.to_string(),
                ].join(",")
            }),

            // Skipping Ulimits in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Resources value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Resources {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub blkio_device_read_bps: Vec<Vec<models::ThrottleDevice>>,
            pub blkio_device_read_i_ops: Vec<Vec<models::ThrottleDevice>>,
            pub blkio_device_write_bps: Vec<Vec<models::ThrottleDevice>>,
            pub blkio_device_write_i_ops: Vec<Vec<models::ThrottleDevice>>,
            pub blkio_weight: Vec<i32>,
            pub blkio_weight_device: Vec<Vec<models::WeightDevice>>,
            pub cgroup_parent: Vec<String>,
            pub cpu_count: Vec<i64>,
            pub cpu_percent: Vec<i64>,
            pub cpu_period: Vec<i64>,
            pub cpu_quota: Vec<i64>,
            pub cpu_realtime_period: Vec<i64>,
            pub cpu_realtime_runtime: Vec<i64>,
            pub cpu_shares: Vec<i64>,
            pub cpuset_cpus: Vec<String>,
            pub cpuset_mems: Vec<String>,
            pub device_cgroup_rules: Vec<Vec<String>>,
            pub device_requests: Vec<Vec<models::DeviceRequest>>,
            pub devices: Vec<Vec<models::DeviceMapping>>,
            pub io_maximum_bandwidth: Vec<i32>,
            pub io_maximum_i_ops: Vec<i32>,
            pub kernel_memory: Vec<i64>,
            pub kernel_memory_tcp: Vec<i64>,
            pub memory: Vec<i64>,
            pub memory_reservation: Vec<i64>,
            pub memory_swap: Vec<i64>,
            pub memory_swappiness: Vec<i64>,
            pub nano_cpus: Vec<i64>,
            pub oom_kill_disable: Vec<bool>,
            pub pids_limit: Vec<i64>,
            pub ulimits: Vec<Vec<models::Ulimit>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Resources".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "BlkioDeviceReadBps" => return std::result::Result::Err("Parsing a container in this style is not supported in Resources".to_string()),
                    "BlkioDeviceReadIOps" => return std::result::Result::Err("Parsing a container in this style is not supported in Resources".to_string()),
                    "BlkioDeviceWriteBps" => return std::result::Result::Err("Parsing a container in this style is not supported in Resources".to_string()),
                    "BlkioDeviceWriteIOps" => return std::result::Result::Err("Parsing a container in this style is not supported in Resources".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "BlkioWeight" => intermediate_rep.blkio_weight.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "BlkioWeightDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in Resources".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "CgroupParent" => intermediate_rep.cgroup_parent.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuCount" => intermediate_rep.cpu_count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuPercent" => intermediate_rep.cpu_percent.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuPeriod" => intermediate_rep.cpu_period.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuQuota" => intermediate_rep.cpu_quota.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuRealtimePeriod" => intermediate_rep.cpu_realtime_period.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuRealtimeRuntime" => intermediate_rep.cpu_realtime_runtime.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuShares" => intermediate_rep.cpu_shares.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpusetCpus" => intermediate_rep.cpuset_cpus.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpusetMems" => intermediate_rep.cpuset_mems.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "DeviceCgroupRules" => return std::result::Result::Err("Parsing a container in this style is not supported in Resources".to_string()),
                    "DeviceRequests" => return std::result::Result::Err("Parsing a container in this style is not supported in Resources".to_string()),
                    "Devices" => return std::result::Result::Err("Parsing a container in this style is not supported in Resources".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "IOMaximumBandwidth" => intermediate_rep.io_maximum_bandwidth.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IOMaximumIOps" => intermediate_rep.io_maximum_i_ops.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "KernelMemory" => intermediate_rep.kernel_memory.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "KernelMemoryTCP" => intermediate_rep.kernel_memory_tcp.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Memory" => intermediate_rep.memory.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemoryReservation" => intermediate_rep.memory_reservation.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemorySwap" => intermediate_rep.memory_swap.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemorySwappiness" => intermediate_rep.memory_swappiness.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NanoCpus" => intermediate_rep.nano_cpus.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OomKillDisable" => intermediate_rep.oom_kill_disable.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PidsLimit" => intermediate_rep.pids_limit.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Ulimits" => return std::result::Result::Err("Parsing a container in this style is not supported in Resources".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Resources".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Resources {
            blkio_device_read_bps: intermediate_rep.blkio_device_read_bps.into_iter().next(),
            blkio_device_read_i_ops: intermediate_rep.blkio_device_read_i_ops.into_iter().next(),
            blkio_device_write_bps: intermediate_rep.blkio_device_write_bps.into_iter().next(),
            blkio_device_write_i_ops: intermediate_rep.blkio_device_write_i_ops.into_iter().next(),
            blkio_weight: intermediate_rep.blkio_weight.into_iter().next(),
            blkio_weight_device: intermediate_rep.blkio_weight_device.into_iter().next(),
            cgroup_parent: intermediate_rep.cgroup_parent.into_iter().next(),
            cpu_count: intermediate_rep.cpu_count.into_iter().next(),
            cpu_percent: intermediate_rep.cpu_percent.into_iter().next(),
            cpu_period: intermediate_rep.cpu_period.into_iter().next(),
            cpu_quota: intermediate_rep.cpu_quota.into_iter().next(),
            cpu_realtime_period: intermediate_rep.cpu_realtime_period.into_iter().next(),
            cpu_realtime_runtime: intermediate_rep.cpu_realtime_runtime.into_iter().next(),
            cpu_shares: intermediate_rep.cpu_shares.into_iter().next(),
            cpuset_cpus: intermediate_rep.cpuset_cpus.into_iter().next(),
            cpuset_mems: intermediate_rep.cpuset_mems.into_iter().next(),
            device_cgroup_rules: intermediate_rep.device_cgroup_rules.into_iter().next(),
            device_requests: intermediate_rep.device_requests.into_iter().next(),
            devices: intermediate_rep.devices.into_iter().next(),
            io_maximum_bandwidth: intermediate_rep.io_maximum_bandwidth.into_iter().next(),
            io_maximum_i_ops: intermediate_rep.io_maximum_i_ops.into_iter().next(),
            kernel_memory: intermediate_rep.kernel_memory.into_iter().next(),
            kernel_memory_tcp: intermediate_rep.kernel_memory_tcp.into_iter().next(),
            memory: intermediate_rep.memory.into_iter().next(),
            memory_reservation: intermediate_rep.memory_reservation.into_iter().next(),
            memory_swap: intermediate_rep.memory_swap.into_iter().next(),
            memory_swappiness: intermediate_rep.memory_swappiness.into_iter().next(),
            nano_cpus: intermediate_rep.nano_cpus.into_iter().next(),
            oom_kill_disable: intermediate_rep.oom_kill_disable.into_iter().next(),
            pids_limit: intermediate_rep.pids_limit.into_iter().next(),
            ulimits: intermediate_rep.ulimits.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Resources> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Resources>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Resources>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Resources - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Resources> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Resources as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Resources - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Only one of the following restart policies may be specified. If none of the following policies is specified, the default one is RestartPolicyAlways. +enum
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RestartPolicy(String);

impl validator::Validate for RestartPolicy {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for RestartPolicy {
    fn from(x: String) -> Self {
        RestartPolicy(x)
    }
}

impl std::string::ToString for RestartPolicy {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for RestartPolicy {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(RestartPolicy(x.to_string()))
    }
}

impl std::convert::From<RestartPolicy> for String {
    fn from(x: RestartPolicy) -> Self {
        x.0
    }
}

impl std::ops::Deref for RestartPolicy {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for RestartPolicy {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// ScaleIOVolumeSource represents a persistent ScaleIO volume



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ScaleIoVolumeSource {
/// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Default is \"xfs\". +optional
    #[serde(rename = "fsType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fs_type: Option<String>,

/// The host address of the ScaleIO API Gateway.
    #[serde(rename = "gateway")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gateway: Option<String>,

/// The name of the ScaleIO Protection Domain for the configured storage. +optional
    #[serde(rename = "protectionDomain")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub protection_domain: Option<String>,

/// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. +optional
    #[serde(rename = "readOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

    #[serde(rename = "secretRef")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_ref: Option<models::LocalObjectReference>,

/// Flag to enable/disable SSL communication with Gateway, default false +optional
    #[serde(rename = "sslEnabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssl_enabled: Option<bool>,

/// Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned. +optional
    #[serde(rename = "storageMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_mode: Option<String>,

/// The ScaleIO Storage Pool associated with the protection domain. +optional
    #[serde(rename = "storagePool")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_pool: Option<String>,

/// The name of the storage system as configured in ScaleIO.
    #[serde(rename = "system")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub system: Option<String>,

/// The name of a volume already created in the ScaleIO system that is associated with this volume source.
    #[serde(rename = "volumeName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_name: Option<String>,

}


impl ScaleIoVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ScaleIoVolumeSource {
        ScaleIoVolumeSource {
            fs_type: None,
            gateway: None,
            protection_domain: None,
            read_only: None,
            secret_ref: None,
            ssl_enabled: None,
            storage_mode: None,
            storage_pool: None,
            system: None,
            volume_name: None,
        }
    }
}

/// Converts the ScaleIoVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ScaleIoVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.fs_type.as_ref().map(|fs_type| {
                [
                    "fsType".to_string(),
                    fs_type.to_string(),
                ].join(",")
            }),


            self.gateway.as_ref().map(|gateway| {
                [
                    "gateway".to_string(),
                    gateway.to_string(),
                ].join(",")
            }),


            self.protection_domain.as_ref().map(|protection_domain| {
                [
                    "protectionDomain".to_string(),
                    protection_domain.to_string(),
                ].join(",")
            }),


            self.read_only.as_ref().map(|read_only| {
                [
                    "readOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),

            // Skipping secretRef in query parameter serialization


            self.ssl_enabled.as_ref().map(|ssl_enabled| {
                [
                    "sslEnabled".to_string(),
                    ssl_enabled.to_string(),
                ].join(",")
            }),


            self.storage_mode.as_ref().map(|storage_mode| {
                [
                    "storageMode".to_string(),
                    storage_mode.to_string(),
                ].join(",")
            }),


            self.storage_pool.as_ref().map(|storage_pool| {
                [
                    "storagePool".to_string(),
                    storage_pool.to_string(),
                ].join(",")
            }),


            self.system.as_ref().map(|system| {
                [
                    "system".to_string(),
                    system.to_string(),
                ].join(",")
            }),


            self.volume_name.as_ref().map(|volume_name| {
                [
                    "volumeName".to_string(),
                    volume_name.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ScaleIoVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ScaleIoVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub fs_type: Vec<String>,
            pub gateway: Vec<String>,
            pub protection_domain: Vec<String>,
            pub read_only: Vec<bool>,
            pub secret_ref: Vec<models::LocalObjectReference>,
            pub ssl_enabled: Vec<bool>,
            pub storage_mode: Vec<String>,
            pub storage_pool: Vec<String>,
            pub system: Vec<String>,
            pub volume_name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ScaleIoVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "fsType" => intermediate_rep.fs_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gateway" => intermediate_rep.gateway.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "protectionDomain" => intermediate_rep.protection_domain.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "readOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "secretRef" => intermediate_rep.secret_ref.push(<models::LocalObjectReference as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sslEnabled" => intermediate_rep.ssl_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "storageMode" => intermediate_rep.storage_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "storagePool" => intermediate_rep.storage_pool.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "system" => intermediate_rep.system.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "volumeName" => intermediate_rep.volume_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ScaleIoVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ScaleIoVolumeSource {
            fs_type: intermediate_rep.fs_type.into_iter().next(),
            gateway: intermediate_rep.gateway.into_iter().next(),
            protection_domain: intermediate_rep.protection_domain.into_iter().next(),
            read_only: intermediate_rep.read_only.into_iter().next(),
            secret_ref: intermediate_rep.secret_ref.into_iter().next(),
            ssl_enabled: intermediate_rep.ssl_enabled.into_iter().next(),
            storage_mode: intermediate_rep.storage_mode.into_iter().next(),
            storage_pool: intermediate_rep.storage_pool.into_iter().next(),
            system: intermediate_rep.system.into_iter().next(),
            volume_name: intermediate_rep.volume_name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ScaleIoVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ScaleIoVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ScaleIoVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ScaleIoVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ScaleIoVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ScaleIoVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ScaleIoVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// SELinuxOptions are the labels to be applied to the container



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SeLinuxOptions {
/// Level is SELinux level label that applies to the container. +optional
    #[serde(rename = "level")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub level: Option<String>,

/// Role is a SELinux role label that applies to the container. +optional
    #[serde(rename = "role")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,

/// Type is a SELinux type label that applies to the container. +optional
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

/// User is a SELinux user label that applies to the container. +optional
    #[serde(rename = "user")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

}


impl SeLinuxOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SeLinuxOptions {
        SeLinuxOptions {
            level: None,
            role: None,
            r#type: None,
            user: None,
        }
    }
}

/// Converts the SeLinuxOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SeLinuxOptions {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.level.as_ref().map(|level| {
                [
                    "level".to_string(),
                    level.to_string(),
                ].join(",")
            }),


            self.role.as_ref().map(|role| {
                [
                    "role".to_string(),
                    role.to_string(),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),


            self.user.as_ref().map(|user| {
                [
                    "user".to_string(),
                    user.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SeLinuxOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SeLinuxOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub level: Vec<String>,
            pub role: Vec<String>,
            pub r#type: Vec<String>,
            pub user: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SeLinuxOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "level" => intermediate_rep.level.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "user" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SeLinuxOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SeLinuxOptions {
            level: intermediate_rep.level.into_iter().next(),
            role: intermediate_rep.role.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            user: intermediate_rep.user.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SeLinuxOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SeLinuxOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SeLinuxOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SeLinuxOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SeLinuxOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SeLinuxOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SeLinuxOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Only one profile source may be set. +union



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SeccompProfile {
/// localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is \"Localhost\". +optional
    #[serde(rename = "localhostProfile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub localhost_profile: Option<String>,

/// +enum
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

}


impl SeccompProfile {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SeccompProfile {
        SeccompProfile {
            localhost_profile: None,
            r#type: None,
        }
    }
}

/// Converts the SeccompProfile value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SeccompProfile {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.localhost_profile.as_ref().map(|localhost_profile| {
                [
                    "localhostProfile".to_string(),
                    localhost_profile.to_string(),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SeccompProfile value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SeccompProfile {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub localhost_profile: Vec<String>,
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SeccompProfile".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "localhostProfile" => intermediate_rep.localhost_profile.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SeccompProfile".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SeccompProfile {
            localhost_profile: intermediate_rep.localhost_profile.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SeccompProfile> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SeccompProfile>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SeccompProfile>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SeccompProfile - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SeccompProfile> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SeccompProfile as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SeccompProfile - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// +enum
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SeccompProfileType(String);

impl validator::Validate for SeccompProfileType {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for SeccompProfileType {
    fn from(x: String) -> Self {
        SeccompProfileType(x)
    }
}

impl std::string::ToString for SeccompProfileType {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for SeccompProfileType {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(SeccompProfileType(x.to_string()))
    }
}

impl std::convert::From<SeccompProfileType> for String {
    fn from(x: SeccompProfileType) -> Self {
        x.0
    }
}

impl std::ops::Deref for SeccompProfileType {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for SeccompProfileType {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// The contents of the target Secret's Data field will represent the key-value pairs as environment variables.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecretEnvSource {
/// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid? +optional
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Specify whether the Secret must be defined +optional
    #[serde(rename = "optional")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional: Option<bool>,

}


impl SecretEnvSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SecretEnvSource {
        SecretEnvSource {
            name: None,
            optional: None,
        }
    }
}

/// Converts the SecretEnvSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SecretEnvSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.optional.as_ref().map(|optional| {
                [
                    "optional".to_string(),
                    optional.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecretEnvSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecretEnvSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub optional: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SecretEnvSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "optional" => intermediate_rep.optional.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecretEnvSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecretEnvSource {
            name: intermediate_rep.name.into_iter().next(),
            optional: intermediate_rep.optional.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecretEnvSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SecretEnvSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SecretEnvSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SecretEnvSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SecretEnvSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SecretEnvSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SecretEnvSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// +structType=atomic



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecretKeySelector {
/// The key of the secret to select from.  Must be a valid secret key.
    #[serde(rename = "key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,

/// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid? +optional
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Specify whether the Secret or its key must be defined +optional
    #[serde(rename = "optional")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional: Option<bool>,

}


impl SecretKeySelector {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SecretKeySelector {
        SecretKeySelector {
            key: None,
            name: None,
            optional: None,
        }
    }
}

/// Converts the SecretKeySelector value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SecretKeySelector {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.key.as_ref().map(|key| {
                [
                    "key".to_string(),
                    key.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.optional.as_ref().map(|optional| {
                [
                    "optional".to_string(),
                    optional.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecretKeySelector value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecretKeySelector {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub key: Vec<String>,
            pub name: Vec<String>,
            pub optional: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SecretKeySelector".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "key" => intermediate_rep.key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "optional" => intermediate_rep.optional.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecretKeySelector".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecretKeySelector {
            key: intermediate_rep.key.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            optional: intermediate_rep.optional.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecretKeySelector> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SecretKeySelector>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SecretKeySelector>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SecretKeySelector - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SecretKeySelector> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SecretKeySelector as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SecretKeySelector - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The contents of the target Secret's Data field will be presented in a projected volume as files using the keys in the Data field as the file names. Note that this is identical to a secret volume source without the default mode.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecretProjection {
/// If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'. +optional
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::KeyToPath>>,

/// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid? +optional
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Specify whether the Secret or its key must be defined +optional
    #[serde(rename = "optional")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional: Option<bool>,

}


impl SecretProjection {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SecretProjection {
        SecretProjection {
            items: None,
            name: None,
            optional: None,
        }
    }
}

/// Converts the SecretProjection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SecretProjection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.optional.as_ref().map(|optional| {
                [
                    "optional".to_string(),
                    optional.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecretProjection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecretProjection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::KeyToPath>>,
            pub name: Vec<String>,
            pub optional: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SecretProjection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in SecretProjection".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "optional" => intermediate_rep.optional.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecretProjection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecretProjection {
            items: intermediate_rep.items.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            optional: intermediate_rep.optional.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecretProjection> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SecretProjection>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SecretProjection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SecretProjection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SecretProjection> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SecretProjection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SecretProjection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecretVolumeSource {
/// Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. +optional
    #[serde(rename = "defaultMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_mode: Option<i32>,

/// If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'. +optional
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::KeyToPath>>,

/// Specify whether the Secret or its keys must be defined +optional
    #[serde(rename = "optional")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional: Option<bool>,

/// Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret +optional
    #[serde(rename = "secretName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_name: Option<String>,

}


impl SecretVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SecretVolumeSource {
        SecretVolumeSource {
            default_mode: None,
            items: None,
            optional: None,
            secret_name: None,
        }
    }
}

/// Converts the SecretVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SecretVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.default_mode.as_ref().map(|default_mode| {
                [
                    "defaultMode".to_string(),
                    default_mode.to_string(),
                ].join(",")
            }),

            // Skipping items in query parameter serialization


            self.optional.as_ref().map(|optional| {
                [
                    "optional".to_string(),
                    optional.to_string(),
                ].join(",")
            }),


            self.secret_name.as_ref().map(|secret_name| {
                [
                    "secretName".to_string(),
                    secret_name.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecretVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecretVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub default_mode: Vec<i32>,
            pub items: Vec<Vec<models::KeyToPath>>,
            pub optional: Vec<bool>,
            pub secret_name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SecretVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "defaultMode" => intermediate_rep.default_mode.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in SecretVolumeSource".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "optional" => intermediate_rep.optional.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "secretName" => intermediate_rep.secret_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecretVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecretVolumeSource {
            default_mode: intermediate_rep.default_mode.into_iter().next(),
            items: intermediate_rep.items.into_iter().next(),
            optional: intermediate_rep.optional.into_iter().next(),
            secret_name: intermediate_rep.secret_name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecretVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SecretVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SecretVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SecretVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SecretVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SecretVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SecretVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecurityConfig {
    #[serde(rename = "command")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub command: Option<models::CommandConfig>,

    #[serde(rename = "defaultMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_mode: Option<String>,

    #[serde(rename = "env")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub env: Option<models::SecurityEnvConfig>,

/// ForceCommand behaves similar to the OpenSSH ForceCommand option. When set this command overrides any command requested by the client and executes this command instead. The original command supplied by the client will be set in the `SSH_ORIGINAL_COMMAND` environment variable.  Setting ForceCommand changes subsystem requests into exec requests for the backends.
    #[serde(rename = "forceCommand")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub force_command: Option<String>,

    #[serde(rename = "forwarding")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub forwarding: Option<models::ForwardingConfig>,

/// MaxSessions drives how many session channels can be open at the same time for a single network connection. 1 means unlimited. It is strongly recommended to configure this to a sane value, e.g. 10.
    #[serde(rename = "maxSessions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_sessions: Option<i64>,

    #[serde(rename = "shell")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shell: Option<models::SecurityShellConfig>,

    #[serde(rename = "signal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub signal: Option<models::SecuritySignalConfig>,

    #[serde(rename = "subsystem")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subsystem: Option<models::SubsystemConfig>,

    #[serde(rename = "tty")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tty: Option<models::SecurityTtyConfig>,

}


impl SecurityConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SecurityConfig {
        SecurityConfig {
            command: None,
            default_mode: None,
            env: None,
            force_command: None,
            forwarding: None,
            max_sessions: None,
            shell: None,
            signal: None,
            subsystem: None,
            tty: None,
        }
    }
}

/// Converts the SecurityConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SecurityConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping command in query parameter serialization


            self.default_mode.as_ref().map(|default_mode| {
                [
                    "defaultMode".to_string(),
                    default_mode.to_string(),
                ].join(",")
            }),

            // Skipping env in query parameter serialization


            self.force_command.as_ref().map(|force_command| {
                [
                    "forceCommand".to_string(),
                    force_command.to_string(),
                ].join(",")
            }),

            // Skipping forwarding in query parameter serialization


            self.max_sessions.as_ref().map(|max_sessions| {
                [
                    "maxSessions".to_string(),
                    max_sessions.to_string(),
                ].join(",")
            }),

            // Skipping shell in query parameter serialization

            // Skipping signal in query parameter serialization

            // Skipping subsystem in query parameter serialization

            // Skipping tty in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecurityConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecurityConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub command: Vec<models::CommandConfig>,
            pub default_mode: Vec<String>,
            pub env: Vec<models::SecurityEnvConfig>,
            pub force_command: Vec<String>,
            pub forwarding: Vec<models::ForwardingConfig>,
            pub max_sessions: Vec<i64>,
            pub shell: Vec<models::SecurityShellConfig>,
            pub signal: Vec<models::SecuritySignalConfig>,
            pub subsystem: Vec<models::SubsystemConfig>,
            pub tty: Vec<models::SecurityTtyConfig>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SecurityConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "command" => intermediate_rep.command.push(<models::CommandConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "defaultMode" => intermediate_rep.default_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "env" => intermediate_rep.env.push(<models::SecurityEnvConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "forceCommand" => intermediate_rep.force_command.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "forwarding" => intermediate_rep.forwarding.push(<models::ForwardingConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxSessions" => intermediate_rep.max_sessions.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shell" => intermediate_rep.shell.push(<models::SecurityShellConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "signal" => intermediate_rep.signal.push(<models::SecuritySignalConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "subsystem" => intermediate_rep.subsystem.push(<models::SubsystemConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tty" => intermediate_rep.tty.push(<models::SecurityTtyConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecurityConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecurityConfig {
            command: intermediate_rep.command.into_iter().next(),
            default_mode: intermediate_rep.default_mode.into_iter().next(),
            env: intermediate_rep.env.into_iter().next(),
            force_command: intermediate_rep.force_command.into_iter().next(),
            forwarding: intermediate_rep.forwarding.into_iter().next(),
            max_sessions: intermediate_rep.max_sessions.into_iter().next(),
            shell: intermediate_rep.shell.into_iter().next(),
            signal: intermediate_rep.signal.into_iter().next(),
            subsystem: intermediate_rep.subsystem.into_iter().next(),
            tty: intermediate_rep.tty.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecurityConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SecurityConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SecurityConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SecurityConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SecurityConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SecurityConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SecurityConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecurityContext {
/// AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows. +optional
    #[serde(rename = "allowPrivilegeEscalation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_privilege_escalation: Option<bool>,

    #[serde(rename = "capabilities")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub capabilities: Option<models::Capabilities>,

/// Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows. +optional
    #[serde(rename = "privileged")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub privileged: Option<bool>,

/// +enum
    #[serde(rename = "procMount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub proc_mount: Option<String>,

/// Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows. +optional
    #[serde(rename = "readOnlyRootFilesystem")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only_root_filesystem: Option<bool>,

/// The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows. +optional
    #[serde(rename = "runAsGroup")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_as_group: Option<i64>,

/// Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. +optional
    #[serde(rename = "runAsNonRoot")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_as_non_root: Option<bool>,

/// The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows. +optional
    #[serde(rename = "runAsUser")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_as_user: Option<i64>,

    #[serde(rename = "seLinuxOptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub se_linux_options: Option<models::SeLinuxOptions>,

    #[serde(rename = "seccompProfile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub seccomp_profile: Option<models::SeccompProfile>,

    #[serde(rename = "windowsOptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub windows_options: Option<models::WindowsSecurityContextOptions>,

}


impl SecurityContext {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SecurityContext {
        SecurityContext {
            allow_privilege_escalation: None,
            capabilities: None,
            privileged: None,
            proc_mount: None,
            read_only_root_filesystem: None,
            run_as_group: None,
            run_as_non_root: None,
            run_as_user: None,
            se_linux_options: None,
            seccomp_profile: None,
            windows_options: None,
        }
    }
}

/// Converts the SecurityContext value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SecurityContext {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.allow_privilege_escalation.as_ref().map(|allow_privilege_escalation| {
                [
                    "allowPrivilegeEscalation".to_string(),
                    allow_privilege_escalation.to_string(),
                ].join(",")
            }),

            // Skipping capabilities in query parameter serialization


            self.privileged.as_ref().map(|privileged| {
                [
                    "privileged".to_string(),
                    privileged.to_string(),
                ].join(",")
            }),


            self.proc_mount.as_ref().map(|proc_mount| {
                [
                    "procMount".to_string(),
                    proc_mount.to_string(),
                ].join(",")
            }),


            self.read_only_root_filesystem.as_ref().map(|read_only_root_filesystem| {
                [
                    "readOnlyRootFilesystem".to_string(),
                    read_only_root_filesystem.to_string(),
                ].join(",")
            }),


            self.run_as_group.as_ref().map(|run_as_group| {
                [
                    "runAsGroup".to_string(),
                    run_as_group.to_string(),
                ].join(",")
            }),


            self.run_as_non_root.as_ref().map(|run_as_non_root| {
                [
                    "runAsNonRoot".to_string(),
                    run_as_non_root.to_string(),
                ].join(",")
            }),


            self.run_as_user.as_ref().map(|run_as_user| {
                [
                    "runAsUser".to_string(),
                    run_as_user.to_string(),
                ].join(",")
            }),

            // Skipping seLinuxOptions in query parameter serialization

            // Skipping seccompProfile in query parameter serialization

            // Skipping windowsOptions in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecurityContext value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecurityContext {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub allow_privilege_escalation: Vec<bool>,
            pub capabilities: Vec<models::Capabilities>,
            pub privileged: Vec<bool>,
            pub proc_mount: Vec<String>,
            pub read_only_root_filesystem: Vec<bool>,
            pub run_as_group: Vec<i64>,
            pub run_as_non_root: Vec<bool>,
            pub run_as_user: Vec<i64>,
            pub se_linux_options: Vec<models::SeLinuxOptions>,
            pub seccomp_profile: Vec<models::SeccompProfile>,
            pub windows_options: Vec<models::WindowsSecurityContextOptions>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SecurityContext".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "allowPrivilegeEscalation" => intermediate_rep.allow_privilege_escalation.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "capabilities" => intermediate_rep.capabilities.push(<models::Capabilities as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "privileged" => intermediate_rep.privileged.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "procMount" => intermediate_rep.proc_mount.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "readOnlyRootFilesystem" => intermediate_rep.read_only_root_filesystem.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "runAsGroup" => intermediate_rep.run_as_group.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "runAsNonRoot" => intermediate_rep.run_as_non_root.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "runAsUser" => intermediate_rep.run_as_user.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "seLinuxOptions" => intermediate_rep.se_linux_options.push(<models::SeLinuxOptions as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "seccompProfile" => intermediate_rep.seccomp_profile.push(<models::SeccompProfile as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "windowsOptions" => intermediate_rep.windows_options.push(<models::WindowsSecurityContextOptions as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecurityContext".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecurityContext {
            allow_privilege_escalation: intermediate_rep.allow_privilege_escalation.into_iter().next(),
            capabilities: intermediate_rep.capabilities.into_iter().next(),
            privileged: intermediate_rep.privileged.into_iter().next(),
            proc_mount: intermediate_rep.proc_mount.into_iter().next(),
            read_only_root_filesystem: intermediate_rep.read_only_root_filesystem.into_iter().next(),
            run_as_group: intermediate_rep.run_as_group.into_iter().next(),
            run_as_non_root: intermediate_rep.run_as_non_root.into_iter().next(),
            run_as_user: intermediate_rep.run_as_user.into_iter().next(),
            se_linux_options: intermediate_rep.se_linux_options.into_iter().next(),
            seccomp_profile: intermediate_rep.seccomp_profile.into_iter().next(),
            windows_options: intermediate_rep.windows_options.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecurityContext> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SecurityContext>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SecurityContext>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SecurityContext - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SecurityContext> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SecurityContext as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SecurityContext - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecurityEnvConfig {
/// Allow takes effect when Mode is ExecutionPolicyFilter and only allows the specified environment variables to be set.
    #[serde(rename = "allow")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow: Option<Vec<String>>,

/// Allow takes effect when Mode is not ExecutionPolicyDisable and disallows the specified environment variables to be set.
    #[serde(rename = "deny")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deny: Option<Vec<String>>,

    #[serde(rename = "mode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mode: Option<String>,

}


impl SecurityEnvConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SecurityEnvConfig {
        SecurityEnvConfig {
            allow: None,
            deny: None,
            mode: None,
        }
    }
}

/// Converts the SecurityEnvConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SecurityEnvConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.allow.as_ref().map(|allow| {
                [
                    "allow".to_string(),
                    allow.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.deny.as_ref().map(|deny| {
                [
                    "deny".to_string(),
                    deny.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.mode.as_ref().map(|mode| {
                [
                    "mode".to_string(),
                    mode.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecurityEnvConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecurityEnvConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub allow: Vec<Vec<String>>,
            pub deny: Vec<Vec<String>>,
            pub mode: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SecurityEnvConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "allow" => return std::result::Result::Err("Parsing a container in this style is not supported in SecurityEnvConfig".to_string()),
                    "deny" => return std::result::Result::Err("Parsing a container in this style is not supported in SecurityEnvConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "mode" => intermediate_rep.mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecurityEnvConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecurityEnvConfig {
            allow: intermediate_rep.allow.into_iter().next(),
            deny: intermediate_rep.deny.into_iter().next(),
            mode: intermediate_rep.mode.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecurityEnvConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SecurityEnvConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SecurityEnvConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SecurityEnvConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SecurityEnvConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SecurityEnvConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SecurityEnvConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecurityExecutionPolicy(String);

impl validator::Validate for SecurityExecutionPolicy {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for SecurityExecutionPolicy {
    fn from(x: String) -> Self {
        SecurityExecutionPolicy(x)
    }
}

impl std::string::ToString for SecurityExecutionPolicy {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for SecurityExecutionPolicy {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(SecurityExecutionPolicy(x.to_string()))
    }
}

impl std::convert::From<SecurityExecutionPolicy> for String {
    fn from(x: SecurityExecutionPolicy) -> Self {
        x.0
    }
}

impl std::ops::Deref for SecurityExecutionPolicy {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for SecurityExecutionPolicy {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecurityShellConfig {
    #[serde(rename = "mode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mode: Option<String>,

}


impl SecurityShellConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SecurityShellConfig {
        SecurityShellConfig {
            mode: None,
        }
    }
}

/// Converts the SecurityShellConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SecurityShellConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.mode.as_ref().map(|mode| {
                [
                    "mode".to_string(),
                    mode.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecurityShellConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecurityShellConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mode: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SecurityShellConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "mode" => intermediate_rep.mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecurityShellConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecurityShellConfig {
            mode: intermediate_rep.mode.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecurityShellConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SecurityShellConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SecurityShellConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SecurityShellConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SecurityShellConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SecurityShellConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SecurityShellConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecuritySignalConfig {
/// Allow takes effect when Mode is ExecutionPolicyFilter and only allows the specified signals to be forwarded.
    #[serde(rename = "allow")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow: Option<Vec<String>>,

/// Allow takes effect when Mode is not ExecutionPolicyDisable and disallows the specified signals to be forwarded.
    #[serde(rename = "deny")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deny: Option<Vec<String>>,

    #[serde(rename = "mode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mode: Option<String>,

}


impl SecuritySignalConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SecuritySignalConfig {
        SecuritySignalConfig {
            allow: None,
            deny: None,
            mode: None,
        }
    }
}

/// Converts the SecuritySignalConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SecuritySignalConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.allow.as_ref().map(|allow| {
                [
                    "allow".to_string(),
                    allow.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.deny.as_ref().map(|deny| {
                [
                    "deny".to_string(),
                    deny.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.mode.as_ref().map(|mode| {
                [
                    "mode".to_string(),
                    mode.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecuritySignalConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecuritySignalConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub allow: Vec<Vec<String>>,
            pub deny: Vec<Vec<String>>,
            pub mode: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SecuritySignalConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "allow" => return std::result::Result::Err("Parsing a container in this style is not supported in SecuritySignalConfig".to_string()),
                    "deny" => return std::result::Result::Err("Parsing a container in this style is not supported in SecuritySignalConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "mode" => intermediate_rep.mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecuritySignalConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecuritySignalConfig {
            allow: intermediate_rep.allow.into_iter().next(),
            deny: intermediate_rep.deny.into_iter().next(),
            mode: intermediate_rep.mode.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecuritySignalConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SecuritySignalConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SecuritySignalConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SecuritySignalConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SecuritySignalConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SecuritySignalConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SecuritySignalConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecurityTtyConfig {
    #[serde(rename = "mode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mode: Option<String>,

}


impl SecurityTtyConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SecurityTtyConfig {
        SecurityTtyConfig {
            mode: None,
        }
    }
}

/// Converts the SecurityTtyConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SecurityTtyConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.mode.as_ref().map(|mode| {
                [
                    "mode".to_string(),
                    mode.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecurityTtyConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecurityTtyConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mode: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SecurityTtyConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "mode" => intermediate_rep.mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecurityTtyConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecurityTtyConfig {
            mode: intermediate_rep.mode.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecurityTtyConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SecurityTtyConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SecurityTtyConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SecurityTtyConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SecurityTtyConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SecurityTtyConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SecurityTtyConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ServiceAccountTokenProjection represents a projected service account token volume. This projection can be used to insert a service account token into the pods runtime filesystem for use against APIs (Kubernetes API Server or otherwise).



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ServiceAccountTokenProjection {
/// Audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver. +optional
    #[serde(rename = "audience")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audience: Option<String>,

/// ExpirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes. +optional
    #[serde(rename = "expirationSeconds")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expiration_seconds: Option<i64>,

/// Path is the path relative to the mount point of the file to project the token into.
    #[serde(rename = "path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

}


impl ServiceAccountTokenProjection {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ServiceAccountTokenProjection {
        ServiceAccountTokenProjection {
            audience: None,
            expiration_seconds: None,
            path: None,
        }
    }
}

/// Converts the ServiceAccountTokenProjection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ServiceAccountTokenProjection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.audience.as_ref().map(|audience| {
                [
                    "audience".to_string(),
                    audience.to_string(),
                ].join(",")
            }),


            self.expiration_seconds.as_ref().map(|expiration_seconds| {
                [
                    "expirationSeconds".to_string(),
                    expiration_seconds.to_string(),
                ].join(",")
            }),


            self.path.as_ref().map(|path| {
                [
                    "path".to_string(),
                    path.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ServiceAccountTokenProjection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ServiceAccountTokenProjection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub audience: Vec<String>,
            pub expiration_seconds: Vec<i64>,
            pub path: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ServiceAccountTokenProjection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "audience" => intermediate_rep.audience.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expirationSeconds" => intermediate_rep.expiration_seconds.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ServiceAccountTokenProjection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ServiceAccountTokenProjection {
            audience: intermediate_rep.audience.into_iter().next(),
            expiration_seconds: intermediate_rep.expiration_seconds.into_iter().next(),
            path: intermediate_rep.path.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ServiceAccountTokenProjection> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ServiceAccountTokenProjection>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ServiceAccountTokenProjection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ServiceAccountTokenProjection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ServiceAccountTokenProjection> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ServiceAccountTokenProjection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ServiceAccountTokenProjection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ServiceUpdateResponse service update response



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ServiceUpdateResponse {
/// Optional warning messages
    #[serde(rename = "Warnings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warnings: Option<Vec<String>>,

}


impl ServiceUpdateResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ServiceUpdateResponse {
        ServiceUpdateResponse {
            warnings: None,
        }
    }
}

/// Converts the ServiceUpdateResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ServiceUpdateResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.warnings.as_ref().map(|warnings| {
                [
                    "Warnings".to_string(),
                    warnings.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ServiceUpdateResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ServiceUpdateResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub warnings: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ServiceUpdateResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Warnings" => return std::result::Result::Err("Parsing a container in this style is not supported in ServiceUpdateResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ServiceUpdateResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ServiceUpdateResponse {
            warnings: intermediate_rep.warnings.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ServiceUpdateResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ServiceUpdateResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ServiceUpdateResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ServiceUpdateResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ServiceUpdateResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ServiceUpdateResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ServiceUpdateResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// SSHCipher is the SSH cipher
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SshCipher(String);

impl validator::Validate for SshCipher {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for SshCipher {
    fn from(x: String) -> Self {
        SshCipher(x)
    }
}

impl std::string::ToString for SshCipher {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for SshCipher {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(SshCipher(x.to_string()))
    }
}

impl std::convert::From<SshCipher> for String {
    fn from(x: SshCipher) -> Self {
        x.0
    }
}

impl std::ops::Deref for SshCipher {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for SshCipher {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// SSHKex are the SSH key exchange algorithms
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SshKex(String);

impl validator::Validate for SshKex {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for SshKex {
    fn from(x: String) -> Self {
        SshKex(x)
    }
}

impl std::string::ToString for SshKex {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for SshKex {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(SshKex(x.to_string()))
    }
}

impl std::convert::From<SshKex> for String {
    fn from(x: SshKex) -> Self {
        x.0
    }
}

impl std::ops::Deref for SshKex {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for SshKex {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SshKeyAlgo(String);

impl validator::Validate for SshKeyAlgo {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for SshKeyAlgo {
    fn from(x: String) -> Self {
        SshKeyAlgo(x)
    }
}

impl std::string::ToString for SshKeyAlgo {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for SshKeyAlgo {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(SshKeyAlgo(x.to_string()))
    }
}

impl std::convert::From<SshKeyAlgo> for String {
    fn from(x: SshKeyAlgo) -> Self {
        x.0
    }
}

impl std::ops::Deref for SshKeyAlgo {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for SshKeyAlgo {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SshProxyClientVersion(String);

impl validator::Validate for SshProxyClientVersion {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for SshProxyClientVersion {
    fn from(x: String) -> Self {
        SshProxyClientVersion(x)
    }
}

impl std::string::ToString for SshProxyClientVersion {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for SshProxyClientVersion {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(SshProxyClientVersion(x.to_string()))
    }
}

impl std::convert::From<SshProxyClientVersion> for String {
    fn from(x: SshProxyClientVersion) -> Self {
        x.0
    }
}

impl std::ops::Deref for SshProxyClientVersion {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for SshProxyClientVersion {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SshProxyConfig {
    #[serde(rename = "allowedHostKeyFingerprints")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allowed_host_key_fingerprints: Option<Vec<String>>,

/// SSHCipherList is a list of supported ciphers
    #[serde(rename = "ciphers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ciphers: Option<Vec<models::SshCipher>>,

    #[serde(rename = "clientVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_version: Option<String>,

    #[serde(rename = "hostKeyAlgos")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_key_algos: Option<Vec<models::SshKeyAlgo>>,

    #[serde(rename = "kex")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kex: Option<Vec<models::SshKex>>,

/// SSHMACList is a list of SSHMAC algorithms
    #[serde(rename = "macs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub macs: Option<Vec<models::Sshmac>>,

/// Password is the password to offer to the backing SSH server for authentication.
    #[serde(rename = "password")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub password: Option<String>,

/// Port is the TCP port to connect to.
    #[serde(rename = "port")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub port: Option<i32>,

/// PrivateKey is the private key to use for authenticating with the backing server.
    #[serde(rename = "privateKey")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub private_key: Option<String>,

/// Server is the IP address or hostname of the backing server.
    #[serde(rename = "server")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub server: Option<String>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "timeout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeout: Option<i64>,

/// Username is the username to pass to the backing SSH server for authentication.
    #[serde(rename = "username")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub username: Option<String>,

/// UsernamePassThrough means that the username should be taken from the connecting client.
    #[serde(rename = "usernamePassThrough")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub username_pass_through: Option<bool>,

}


impl SshProxyConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SshProxyConfig {
        SshProxyConfig {
            allowed_host_key_fingerprints: None,
            ciphers: None,
            client_version: None,
            host_key_algos: None,
            kex: None,
            macs: None,
            password: None,
            port: None,
            private_key: None,
            server: None,
            timeout: None,
            username: None,
            username_pass_through: None,
        }
    }
}

/// Converts the SshProxyConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SshProxyConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.allowed_host_key_fingerprints.as_ref().map(|allowed_host_key_fingerprints| {
                [
                    "allowedHostKeyFingerprints".to_string(),
                    allowed_host_key_fingerprints.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.ciphers.as_ref().map(|ciphers| {
                [
                    "ciphers".to_string(),
                    ciphers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.client_version.as_ref().map(|client_version| {
                [
                    "clientVersion".to_string(),
                    client_version.to_string(),
                ].join(",")
            }),


            self.host_key_algos.as_ref().map(|host_key_algos| {
                [
                    "hostKeyAlgos".to_string(),
                    host_key_algos.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.kex.as_ref().map(|kex| {
                [
                    "kex".to_string(),
                    kex.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.macs.as_ref().map(|macs| {
                [
                    "macs".to_string(),
                    macs.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.password.as_ref().map(|password| {
                [
                    "password".to_string(),
                    password.to_string(),
                ].join(",")
            }),


            self.port.as_ref().map(|port| {
                [
                    "port".to_string(),
                    port.to_string(),
                ].join(",")
            }),


            self.private_key.as_ref().map(|private_key| {
                [
                    "privateKey".to_string(),
                    private_key.to_string(),
                ].join(",")
            }),


            self.server.as_ref().map(|server| {
                [
                    "server".to_string(),
                    server.to_string(),
                ].join(",")
            }),


            self.timeout.as_ref().map(|timeout| {
                [
                    "timeout".to_string(),
                    timeout.to_string(),
                ].join(",")
            }),


            self.username.as_ref().map(|username| {
                [
                    "username".to_string(),
                    username.to_string(),
                ].join(",")
            }),


            self.username_pass_through.as_ref().map(|username_pass_through| {
                [
                    "usernamePassThrough".to_string(),
                    username_pass_through.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SshProxyConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SshProxyConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub allowed_host_key_fingerprints: Vec<Vec<String>>,
            pub ciphers: Vec<Vec<models::SshCipher>>,
            pub client_version: Vec<String>,
            pub host_key_algos: Vec<Vec<models::SshKeyAlgo>>,
            pub kex: Vec<Vec<models::SshKex>>,
            pub macs: Vec<Vec<models::Sshmac>>,
            pub password: Vec<String>,
            pub port: Vec<i32>,
            pub private_key: Vec<String>,
            pub server: Vec<String>,
            pub timeout: Vec<i64>,
            pub username: Vec<String>,
            pub username_pass_through: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SshProxyConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "allowedHostKeyFingerprints" => return std::result::Result::Err("Parsing a container in this style is not supported in SshProxyConfig".to_string()),
                    "ciphers" => return std::result::Result::Err("Parsing a container in this style is not supported in SshProxyConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "clientVersion" => intermediate_rep.client_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "hostKeyAlgos" => return std::result::Result::Err("Parsing a container in this style is not supported in SshProxyConfig".to_string()),
                    "kex" => return std::result::Result::Err("Parsing a container in this style is not supported in SshProxyConfig".to_string()),
                    "macs" => return std::result::Result::Err("Parsing a container in this style is not supported in SshProxyConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "password" => intermediate_rep.password.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "port" => intermediate_rep.port.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "privateKey" => intermediate_rep.private_key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "server" => intermediate_rep.server.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "timeout" => intermediate_rep.timeout.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "usernamePassThrough" => intermediate_rep.username_pass_through.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SshProxyConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SshProxyConfig {
            allowed_host_key_fingerprints: intermediate_rep.allowed_host_key_fingerprints.into_iter().next(),
            ciphers: intermediate_rep.ciphers.into_iter().next(),
            client_version: intermediate_rep.client_version.into_iter().next(),
            host_key_algos: intermediate_rep.host_key_algos.into_iter().next(),
            kex: intermediate_rep.kex.into_iter().next(),
            macs: intermediate_rep.macs.into_iter().next(),
            password: intermediate_rep.password.into_iter().next(),
            port: intermediate_rep.port.into_iter().next(),
            private_key: intermediate_rep.private_key.into_iter().next(),
            server: intermediate_rep.server.into_iter().next(),
            timeout: intermediate_rep.timeout.into_iter().next(),
            username: intermediate_rep.username.into_iter().next(),
            username_pass_through: intermediate_rep.username_pass_through.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SshProxyConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SshProxyConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SshProxyConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SshProxyConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SshProxyConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SshProxyConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SshProxyConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Sshmac(String);

impl validator::Validate for Sshmac {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for Sshmac {
    fn from(x: String) -> Self {
        Sshmac(x)
    }
}

impl std::string::ToString for Sshmac {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for Sshmac {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Sshmac(x.to_string()))
    }
}

impl std::convert::From<Sshmac> for String {
    fn from(x: Sshmac) -> Self {
        x.0
    }
}

impl std::ops::Deref for Sshmac {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Sshmac {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StorageMedium(String);

impl validator::Validate for StorageMedium {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for StorageMedium {
    fn from(x: String) -> Self {
        StorageMedium(x)
    }
}

impl std::string::ToString for StorageMedium {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for StorageMedium {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(StorageMedium(x.to_string()))
    }
}

impl std::convert::From<StorageMedium> for String {
    fn from(x: StorageMedium) -> Self {
        x.0
    }
}

impl std::ops::Deref for StorageMedium {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for StorageMedium {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StorageOsVolumeSource {
/// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. +optional
    #[serde(rename = "fsType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fs_type: Option<String>,

/// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. +optional
    #[serde(rename = "readOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

    #[serde(rename = "secretRef")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_ref: Option<models::LocalObjectReference>,

/// VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
    #[serde(rename = "volumeName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_name: Option<String>,

/// VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to \"default\" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created. +optional
    #[serde(rename = "volumeNamespace")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_namespace: Option<String>,

}


impl StorageOsVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> StorageOsVolumeSource {
        StorageOsVolumeSource {
            fs_type: None,
            read_only: None,
            secret_ref: None,
            volume_name: None,
            volume_namespace: None,
        }
    }
}

/// Converts the StorageOsVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for StorageOsVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.fs_type.as_ref().map(|fs_type| {
                [
                    "fsType".to_string(),
                    fs_type.to_string(),
                ].join(",")
            }),


            self.read_only.as_ref().map(|read_only| {
                [
                    "readOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),

            // Skipping secretRef in query parameter serialization


            self.volume_name.as_ref().map(|volume_name| {
                [
                    "volumeName".to_string(),
                    volume_name.to_string(),
                ].join(",")
            }),


            self.volume_namespace.as_ref().map(|volume_namespace| {
                [
                    "volumeNamespace".to_string(),
                    volume_namespace.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StorageOsVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StorageOsVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub fs_type: Vec<String>,
            pub read_only: Vec<bool>,
            pub secret_ref: Vec<models::LocalObjectReference>,
            pub volume_name: Vec<String>,
            pub volume_namespace: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing StorageOsVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "fsType" => intermediate_rep.fs_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "readOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "secretRef" => intermediate_rep.secret_ref.push(<models::LocalObjectReference as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "volumeName" => intermediate_rep.volume_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "volumeNamespace" => intermediate_rep.volume_namespace.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing StorageOsVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StorageOsVolumeSource {
            fs_type: intermediate_rep.fs_type.into_iter().next(),
            read_only: intermediate_rep.read_only.into_iter().next(),
            secret_ref: intermediate_rep.secret_ref.into_iter().next(),
            volume_name: intermediate_rep.volume_name.into_iter().next(),
            volume_namespace: intermediate_rep.volume_namespace.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<StorageOsVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<StorageOsVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<StorageOsVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for StorageOsVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<StorageOsVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <StorageOsVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into StorageOsVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SubsystemConfig {
/// Allow takes effect when Mode is ExecutionPolicyFilter and only allows the specified subsystems to be executed.
    #[serde(rename = "allow")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow: Option<Vec<String>>,

/// Allow takes effect when Mode is not ExecutionPolicyDisable and disallows the specified subsystems to be executed.
    #[serde(rename = "deny")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deny: Option<Vec<String>>,

    #[serde(rename = "mode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mode: Option<String>,

}


impl SubsystemConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SubsystemConfig {
        SubsystemConfig {
            allow: None,
            deny: None,
            mode: None,
        }
    }
}

/// Converts the SubsystemConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SubsystemConfig {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.allow.as_ref().map(|allow| {
                [
                    "allow".to_string(),
                    allow.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.deny.as_ref().map(|deny| {
                [
                    "deny".to_string(),
                    deny.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.mode.as_ref().map(|mode| {
                [
                    "mode".to_string(),
                    mode.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SubsystemConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SubsystemConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub allow: Vec<Vec<String>>,
            pub deny: Vec<Vec<String>>,
            pub mode: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SubsystemConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "allow" => return std::result::Result::Err("Parsing a container in this style is not supported in SubsystemConfig".to_string()),
                    "deny" => return std::result::Result::Err("Parsing a container in this style is not supported in SubsystemConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "mode" => intermediate_rep.mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SubsystemConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SubsystemConfig {
            allow: intermediate_rep.allow.into_iter().next(),
            deny: intermediate_rep.deny.into_iter().next(),
            mode: intermediate_rep.mode.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SubsystemConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SubsystemConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SubsystemConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SubsystemConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SubsystemConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SubsystemConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SubsystemConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Sysctl defines a kernel parameter to be set



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Sysctl {
/// Name of a property to set
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Value of a property to set
    #[serde(rename = "value")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,

}


impl Sysctl {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Sysctl {
        Sysctl {
            name: None,
            value: None,
        }
    }
}

/// Converts the Sysctl value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Sysctl {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.value.as_ref().map(|value| {
                [
                    "value".to_string(),
                    value.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Sysctl value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Sysctl {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Sysctl".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Sysctl".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Sysctl {
            name: intermediate_rep.name.into_iter().next(),
            value: intermediate_rep.value.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Sysctl> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Sysctl>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Sysctl>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Sysctl - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Sysctl> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Sysctl as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Sysctl - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// +enum
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TaintEffect(String);

impl validator::Validate for TaintEffect {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for TaintEffect {
    fn from(x: String) -> Self {
        TaintEffect(x)
    }
}

impl std::string::ToString for TaintEffect {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for TaintEffect {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(TaintEffect(x.to_string()))
    }
}

impl std::convert::From<TaintEffect> for String {
    fn from(x: TaintEffect) -> Self {
        x.0
    }
}

impl std::ops::Deref for TaintEffect {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for TaintEffect {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// TCPSocketAction describes an action based on opening a socket



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TcpSocketAction {
/// Optional: Host name to connect to, defaults to the pod IP. +optional
    #[serde(rename = "host")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host: Option<String>,

    #[serde(rename = "port")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub port: Option<models::IntOrString>,

}


impl TcpSocketAction {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TcpSocketAction {
        TcpSocketAction {
            host: None,
            port: None,
        }
    }
}

/// Converts the TcpSocketAction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TcpSocketAction {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.host.as_ref().map(|host| {
                [
                    "host".to_string(),
                    host.to_string(),
                ].join(",")
            }),

            // Skipping port in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TcpSocketAction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TcpSocketAction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub host: Vec<String>,
            pub port: Vec<models::IntOrString>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TcpSocketAction".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "host" => intermediate_rep.host.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "port" => intermediate_rep.port.push(<models::IntOrString as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TcpSocketAction".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TcpSocketAction {
            host: intermediate_rep.host.into_iter().next(),
            port: intermediate_rep.port.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TcpSocketAction> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TcpSocketAction>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TcpSocketAction>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TcpSocketAction - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TcpSocketAction> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TcpSocketAction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TcpSocketAction - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// +enum
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TerminationMessagePolicy(String);

impl validator::Validate for TerminationMessagePolicy {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for TerminationMessagePolicy {
    fn from(x: String) -> Self {
        TerminationMessagePolicy(x)
    }
}

impl std::string::ToString for TerminationMessagePolicy {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for TerminationMessagePolicy {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(TerminationMessagePolicy(x.to_string()))
    }
}

impl std::convert::From<TerminationMessagePolicy> for String {
    fn from(x: TerminationMessagePolicy) -> Self {
        x.0
    }
}

impl std::ops::Deref for TerminationMessagePolicy {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for TerminationMessagePolicy {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// ThrottleDevice is a structure that holds device:rate_per_second pair



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ThrottleDevice {
    #[serde(rename = "Path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

    #[serde(rename = "Rate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rate: Option<i32>,

}


impl ThrottleDevice {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ThrottleDevice {
        ThrottleDevice {
            path: None,
            rate: None,
        }
    }
}

/// Converts the ThrottleDevice value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ThrottleDevice {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.path.as_ref().map(|path| {
                [
                    "Path".to_string(),
                    path.to_string(),
                ].join(",")
            }),


            self.rate.as_ref().map(|rate| {
                [
                    "Rate".to_string(),
                    rate.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ThrottleDevice value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ThrottleDevice {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub path: Vec<String>,
            pub rate: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ThrottleDevice".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Rate" => intermediate_rep.rate.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ThrottleDevice".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ThrottleDevice {
            path: intermediate_rep.path.into_iter().next(),
            rate: intermediate_rep.rate.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ThrottleDevice> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ThrottleDevice>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ThrottleDevice>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ThrottleDevice - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ThrottleDevice> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ThrottleDevice as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ThrottleDevice - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TlsVersion(String);

impl validator::Validate for TlsVersion {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for TlsVersion {
    fn from(x: String) -> Self {
        TlsVersion(x)
    }
}

impl std::string::ToString for TlsVersion {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for TlsVersion {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(TlsVersion(x.to_string()))
    }
}

impl std::convert::From<TlsVersion> for String {
    fn from(x: TlsVersion) -> Self {
        x.0
    }
}

impl std::ops::Deref for TlsVersion {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for TlsVersion {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TmpfsOptions {
/// The bits have the same definition on all systems, so that information about files can be moved from one system to another portably. Not all bits apply to all systems. The only required bit is ModeDir for directories.
    #[serde(rename = "Mode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mode: Option<i32>,

/// Size sets the size of the tmpfs, in bytes.  This will be converted to an operating system specific value depending on the host. For example, on linux, it will be converted to use a 'k', 'm' or 'g' syntax. BSD, though not widely supported with docker, uses a straight byte value.  Percentages are not supported.
    #[serde(rename = "SizeBytes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_bytes: Option<i64>,

}


impl TmpfsOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TmpfsOptions {
        TmpfsOptions {
            mode: None,
            size_bytes: None,
        }
    }
}

/// Converts the TmpfsOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TmpfsOptions {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.mode.as_ref().map(|mode| {
                [
                    "Mode".to_string(),
                    mode.to_string(),
                ].join(",")
            }),


            self.size_bytes.as_ref().map(|size_bytes| {
                [
                    "SizeBytes".to_string(),
                    size_bytes.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TmpfsOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TmpfsOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mode: Vec<i32>,
            pub size_bytes: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TmpfsOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Mode" => intermediate_rep.mode.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SizeBytes" => intermediate_rep.size_bytes.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TmpfsOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TmpfsOptions {
            mode: intermediate_rep.mode.into_iter().next(),
            size_bytes: intermediate_rep.size_bytes.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TmpfsOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TmpfsOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TmpfsOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TmpfsOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TmpfsOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TmpfsOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TmpfsOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Toleration {
/// +enum
    #[serde(rename = "effect")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub effect: Option<String>,

/// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys. +optional
    #[serde(rename = "key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,

/// +enum
    #[serde(rename = "operator")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub operator: Option<String>,

/// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system. +optional
    #[serde(rename = "tolerationSeconds")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub toleration_seconds: Option<i64>,

/// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string. +optional
    #[serde(rename = "value")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,

}


impl Toleration {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Toleration {
        Toleration {
            effect: None,
            key: None,
            operator: None,
            toleration_seconds: None,
            value: None,
        }
    }
}

/// Converts the Toleration value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Toleration {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.effect.as_ref().map(|effect| {
                [
                    "effect".to_string(),
                    effect.to_string(),
                ].join(",")
            }),


            self.key.as_ref().map(|key| {
                [
                    "key".to_string(),
                    key.to_string(),
                ].join(",")
            }),


            self.operator.as_ref().map(|operator| {
                [
                    "operator".to_string(),
                    operator.to_string(),
                ].join(",")
            }),


            self.toleration_seconds.as_ref().map(|toleration_seconds| {
                [
                    "tolerationSeconds".to_string(),
                    toleration_seconds.to_string(),
                ].join(",")
            }),


            self.value.as_ref().map(|value| {
                [
                    "value".to_string(),
                    value.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Toleration value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Toleration {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub effect: Vec<String>,
            pub key: Vec<String>,
            pub operator: Vec<String>,
            pub toleration_seconds: Vec<i64>,
            pub value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Toleration".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "effect" => intermediate_rep.effect.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "key" => intermediate_rep.key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "operator" => intermediate_rep.operator.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tolerationSeconds" => intermediate_rep.toleration_seconds.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Toleration".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Toleration {
            effect: intermediate_rep.effect.into_iter().next(),
            key: intermediate_rep.key.into_iter().next(),
            operator: intermediate_rep.operator.into_iter().next(),
            toleration_seconds: intermediate_rep.toleration_seconds.into_iter().next(),
            value: intermediate_rep.value.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Toleration> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Toleration>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Toleration>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Toleration - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Toleration> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Toleration as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Toleration - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// +enum
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TolerationOperator(String);

impl validator::Validate for TolerationOperator {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for TolerationOperator {
    fn from(x: String) -> Self {
        TolerationOperator(x)
    }
}

impl std::string::ToString for TolerationOperator {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for TolerationOperator {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(TolerationOperator(x.to_string()))
    }
}

impl std::convert::From<TolerationOperator> for String {
    fn from(x: TolerationOperator) -> Self {
        x.0
    }
}

impl std::ops::Deref for TolerationOperator {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for TolerationOperator {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TopologySpreadConstraint {
    #[serde(rename = "labelSelector")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub label_selector: Option<models::LabelSelector>,

/// MaxSkew describes the degree to which pods may be unevenly distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference between the number of matching pods in the target topology and the global minimum. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 1/1/0: +-------+-------+-------+  zone1 | zone2 | zone3 | +-------+-------+-------+    P   |   P   |       | +-------+-------+-------+ if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1; scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1). if MaxSkew is 2, incoming pod can be scheduled onto any zone. When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it. It's a required field. Default value is 1 and 0 is not allowed.
    #[serde(rename = "maxSkew")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_skew: Option<i32>,

/// TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a \"bucket\", and try to put balanced number of pods into each bucket. It's a required field.
    #[serde(rename = "topologyKey")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub topology_key: Option<String>,

/// +enum
    #[serde(rename = "whenUnsatisfiable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub when_unsatisfiable: Option<String>,

}


impl TopologySpreadConstraint {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TopologySpreadConstraint {
        TopologySpreadConstraint {
            label_selector: None,
            max_skew: None,
            topology_key: None,
            when_unsatisfiable: None,
        }
    }
}

/// Converts the TopologySpreadConstraint value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TopologySpreadConstraint {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping labelSelector in query parameter serialization


            self.max_skew.as_ref().map(|max_skew| {
                [
                    "maxSkew".to_string(),
                    max_skew.to_string(),
                ].join(",")
            }),


            self.topology_key.as_ref().map(|topology_key| {
                [
                    "topologyKey".to_string(),
                    topology_key.to_string(),
                ].join(",")
            }),


            self.when_unsatisfiable.as_ref().map(|when_unsatisfiable| {
                [
                    "whenUnsatisfiable".to_string(),
                    when_unsatisfiable.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TopologySpreadConstraint value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TopologySpreadConstraint {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub label_selector: Vec<models::LabelSelector>,
            pub max_skew: Vec<i32>,
            pub topology_key: Vec<String>,
            pub when_unsatisfiable: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TopologySpreadConstraint".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "labelSelector" => intermediate_rep.label_selector.push(<models::LabelSelector as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxSkew" => intermediate_rep.max_skew.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "topologyKey" => intermediate_rep.topology_key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "whenUnsatisfiable" => intermediate_rep.when_unsatisfiable.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TopologySpreadConstraint".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TopologySpreadConstraint {
            label_selector: intermediate_rep.label_selector.into_iter().next(),
            max_skew: intermediate_rep.max_skew.into_iter().next(),
            topology_key: intermediate_rep.topology_key.into_iter().next(),
            when_unsatisfiable: intermediate_rep.when_unsatisfiable.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TopologySpreadConstraint> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TopologySpreadConstraint>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TopologySpreadConstraint>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TopologySpreadConstraint - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TopologySpreadConstraint> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TopologySpreadConstraint as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TopologySpreadConstraint - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Type(i64);

impl validator::Validate for Type {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<i64> for Type {
    fn from(x: i64) -> Self {
        Type(x)
    }
}

impl std::convert::From<Type> for i64 {
    fn from(x: Type) -> Self {
        x.0
    }
}

impl std::ops::Deref for Type {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}

impl std::ops::DerefMut for Type {
    fn deref_mut(&mut self) -> &mut i64 {
        &mut self.0
    }
}



/// TypedLocalObjectReference contains enough information to let you locate the typed referenced object inside the same namespace. +structType=atomic



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TypedLocalObjectReference {
/// APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required. +optional
    #[serde(rename = "apiGroup")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_group: Option<String>,

/// Kind is the type of resource being referenced
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kind: Option<String>,

/// Name is the name of resource being referenced
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl TypedLocalObjectReference {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TypedLocalObjectReference {
        TypedLocalObjectReference {
            api_group: None,
            kind: None,
            name: None,
        }
    }
}

/// Converts the TypedLocalObjectReference value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TypedLocalObjectReference {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.api_group.as_ref().map(|api_group| {
                [
                    "apiGroup".to_string(),
                    api_group.to_string(),
                ].join(",")
            }),


            self.kind.as_ref().map(|kind| {
                [
                    "kind".to_string(),
                    kind.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TypedLocalObjectReference value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TypedLocalObjectReference {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub api_group: Vec<String>,
            pub kind: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TypedLocalObjectReference".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "apiGroup" => intermediate_rep.api_group.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "kind" => intermediate_rep.kind.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TypedLocalObjectReference".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TypedLocalObjectReference {
            api_group: intermediate_rep.api_group.into_iter().next(),
            kind: intermediate_rep.kind.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TypedLocalObjectReference> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TypedLocalObjectReference>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TypedLocalObjectReference>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TypedLocalObjectReference - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TypedLocalObjectReference> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TypedLocalObjectReference as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TypedLocalObjectReference - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// UID is a type that holds unique ID values, including UUIDs.  Because we don't ONLY use UUIDs, this is an alias to string.  Being a type captures intent and helps make sure that UIDs and names do not get conflated.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Uid(String);

impl validator::Validate for Uid {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for Uid {
    fn from(x: String) -> Self {
        Uid(x)
    }
}

impl std::string::ToString for Uid {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for Uid {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Uid(x.to_string()))
    }
}

impl std::convert::From<Uid> for String {
    fn from(x: Uid) -> Self {
        x.0
    }
}

impl std::ops::Deref for Uid {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Uid {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ulimit {
    #[serde(rename = "Hard")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hard: Option<i64>,

    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "Soft")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub soft: Option<i64>,

}


impl Ulimit {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Ulimit {
        Ulimit {
            hard: None,
            name: None,
            soft: None,
        }
    }
}

/// Converts the Ulimit value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Ulimit {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.hard.as_ref().map(|hard| {
                [
                    "Hard".to_string(),
                    hard.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.soft.as_ref().map(|soft| {
                [
                    "Soft".to_string(),
                    soft.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Ulimit value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Ulimit {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hard: Vec<i64>,
            pub name: Vec<String>,
            pub soft: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Ulimit".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Hard" => intermediate_rep.hard.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Soft" => intermediate_rep.soft.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Ulimit".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Ulimit {
            hard: intermediate_rep.hard.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            soft: intermediate_rep.soft.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Ulimit> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Ulimit>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Ulimit>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Ulimit - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Ulimit> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Ulimit as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Ulimit - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// +enum
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UnsatisfiableConstraintAction(String);

impl validator::Validate for UnsatisfiableConstraintAction {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for UnsatisfiableConstraintAction {
    fn from(x: String) -> Self {
        UnsatisfiableConstraintAction(x)
    }
}

impl std::string::ToString for UnsatisfiableConstraintAction {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for UnsatisfiableConstraintAction {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(UnsatisfiableConstraintAction(x.to_string()))
    }
}

impl std::convert::From<UnsatisfiableConstraintAction> for String {
    fn from(x: UnsatisfiableConstraintAction) -> Self {
        x.0
    }
}

impl std::ops::Deref for UnsatisfiableConstraintAction {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for UnsatisfiableConstraintAction {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// URIScheme identifies the scheme used for connection to a host for Get actions +enum
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UriScheme(String);

impl validator::Validate for UriScheme {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for UriScheme {
    fn from(x: String) -> Self {
        UriScheme(x)
    }
}

impl std::string::ToString for UriScheme {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for UriScheme {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(UriScheme(x.to_string()))
    }
}

impl std::convert::From<UriScheme> for String {
    fn from(x: UriScheme) -> Self {
        x.0
    }
}

impl std::ops::Deref for UriScheme {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for UriScheme {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UsernsMode(String);

impl validator::Validate for UsernsMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for UsernsMode {
    fn from(x: String) -> Self {
        UsernsMode(x)
    }
}

impl std::string::ToString for UsernsMode {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for UsernsMode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(UsernsMode(x.to_string()))
    }
}

impl std::convert::From<UsernsMode> for String {
    fn from(x: UsernsMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for UsernsMode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for UsernsMode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UtsMode(String);

impl validator::Validate for UtsMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for UtsMode {
    fn from(x: String) -> Self {
        UtsMode(x)
    }
}

impl std::string::ToString for UtsMode {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for UtsMode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(UtsMode(x.to_string()))
    }
}

impl std::convert::From<UtsMode> for String {
    fn from(x: UtsMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for UtsMode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for UtsMode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Volume {
    #[serde(rename = "awsElasticBlockStore")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub aws_elastic_block_store: Option<models::AwsElasticBlockStoreVolumeSource>,

    #[serde(rename = "azureDisk")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub azure_disk: Option<models::AzureDiskVolumeSource>,

    #[serde(rename = "azureFile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub azure_file: Option<models::AzureFileVolumeSource>,

    #[serde(rename = "cephfs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cephfs: Option<models::CephFsVolumeSource>,

    #[serde(rename = "cinder")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cinder: Option<models::CinderVolumeSource>,

    #[serde(rename = "configMap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub config_map: Option<models::ConfigMapVolumeSource>,

    #[serde(rename = "csi")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub csi: Option<models::CsiVolumeSource>,

    #[serde(rename = "downwardAPI")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub downward_api: Option<models::DownwardApiVolumeSource>,

    #[serde(rename = "emptyDir")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub empty_dir: Option<models::EmptyDirVolumeSource>,

    #[serde(rename = "ephemeral")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ephemeral: Option<models::EphemeralVolumeSource>,

    #[serde(rename = "fc")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fc: Option<models::FcVolumeSource>,

    #[serde(rename = "flexVolume")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub flex_volume: Option<models::FlexVolumeSource>,

    #[serde(rename = "flocker")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub flocker: Option<models::FlockerVolumeSource>,

    #[serde(rename = "gcePersistentDisk")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gce_persistent_disk: Option<models::GcePersistentDiskVolumeSource>,

    #[serde(rename = "gitRepo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_repo: Option<models::GitRepoVolumeSource>,

    #[serde(rename = "glusterfs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub glusterfs: Option<models::GlusterfsVolumeSource>,

    #[serde(rename = "hostPath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_path: Option<models::HostPathVolumeSource>,

    #[serde(rename = "iscsi")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub iscsi: Option<models::IscsiVolumeSource>,

/// Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "nfs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub nfs: Option<models::NfsVolumeSource>,

    #[serde(rename = "persistentVolumeClaim")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub persistent_volume_claim: Option<models::PersistentVolumeClaimVolumeSource>,

    #[serde(rename = "photonPersistentDisk")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub photon_persistent_disk: Option<models::PhotonPersistentDiskVolumeSource>,

    #[serde(rename = "portworxVolume")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub portworx_volume: Option<models::PortworxVolumeSource>,

    #[serde(rename = "projected")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub projected: Option<models::ProjectedVolumeSource>,

    #[serde(rename = "quobyte")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quobyte: Option<models::QuobyteVolumeSource>,

    #[serde(rename = "rbd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rbd: Option<models::RbdVolumeSource>,

    #[serde(rename = "scaleIO")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scale_io: Option<models::ScaleIoVolumeSource>,

    #[serde(rename = "secret")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret: Option<models::SecretVolumeSource>,

    #[serde(rename = "storageos")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storageos: Option<models::StorageOsVolumeSource>,

    #[serde(rename = "vsphereVolume")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vsphere_volume: Option<models::VsphereVirtualDiskVolumeSource>,

}


impl Volume {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Volume {
        Volume {
            aws_elastic_block_store: None,
            azure_disk: None,
            azure_file: None,
            cephfs: None,
            cinder: None,
            config_map: None,
            csi: None,
            downward_api: None,
            empty_dir: None,
            ephemeral: None,
            fc: None,
            flex_volume: None,
            flocker: None,
            gce_persistent_disk: None,
            git_repo: None,
            glusterfs: None,
            host_path: None,
            iscsi: None,
            name: None,
            nfs: None,
            persistent_volume_claim: None,
            photon_persistent_disk: None,
            portworx_volume: None,
            projected: None,
            quobyte: None,
            rbd: None,
            scale_io: None,
            secret: None,
            storageos: None,
            vsphere_volume: None,
        }
    }
}

/// Converts the Volume value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Volume {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping awsElasticBlockStore in query parameter serialization

            // Skipping azureDisk in query parameter serialization

            // Skipping azureFile in query parameter serialization

            // Skipping cephfs in query parameter serialization

            // Skipping cinder in query parameter serialization

            // Skipping configMap in query parameter serialization

            // Skipping csi in query parameter serialization

            // Skipping downwardAPI in query parameter serialization

            // Skipping emptyDir in query parameter serialization

            // Skipping ephemeral in query parameter serialization

            // Skipping fc in query parameter serialization

            // Skipping flexVolume in query parameter serialization

            // Skipping flocker in query parameter serialization

            // Skipping gcePersistentDisk in query parameter serialization

            // Skipping gitRepo in query parameter serialization

            // Skipping glusterfs in query parameter serialization

            // Skipping hostPath in query parameter serialization

            // Skipping iscsi in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping nfs in query parameter serialization

            // Skipping persistentVolumeClaim in query parameter serialization

            // Skipping photonPersistentDisk in query parameter serialization

            // Skipping portworxVolume in query parameter serialization

            // Skipping projected in query parameter serialization

            // Skipping quobyte in query parameter serialization

            // Skipping rbd in query parameter serialization

            // Skipping scaleIO in query parameter serialization

            // Skipping secret in query parameter serialization

            // Skipping storageos in query parameter serialization

            // Skipping vsphereVolume in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Volume value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Volume {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub aws_elastic_block_store: Vec<models::AwsElasticBlockStoreVolumeSource>,
            pub azure_disk: Vec<models::AzureDiskVolumeSource>,
            pub azure_file: Vec<models::AzureFileVolumeSource>,
            pub cephfs: Vec<models::CephFsVolumeSource>,
            pub cinder: Vec<models::CinderVolumeSource>,
            pub config_map: Vec<models::ConfigMapVolumeSource>,
            pub csi: Vec<models::CsiVolumeSource>,
            pub downward_api: Vec<models::DownwardApiVolumeSource>,
            pub empty_dir: Vec<models::EmptyDirVolumeSource>,
            pub ephemeral: Vec<models::EphemeralVolumeSource>,
            pub fc: Vec<models::FcVolumeSource>,
            pub flex_volume: Vec<models::FlexVolumeSource>,
            pub flocker: Vec<models::FlockerVolumeSource>,
            pub gce_persistent_disk: Vec<models::GcePersistentDiskVolumeSource>,
            pub git_repo: Vec<models::GitRepoVolumeSource>,
            pub glusterfs: Vec<models::GlusterfsVolumeSource>,
            pub host_path: Vec<models::HostPathVolumeSource>,
            pub iscsi: Vec<models::IscsiVolumeSource>,
            pub name: Vec<String>,
            pub nfs: Vec<models::NfsVolumeSource>,
            pub persistent_volume_claim: Vec<models::PersistentVolumeClaimVolumeSource>,
            pub photon_persistent_disk: Vec<models::PhotonPersistentDiskVolumeSource>,
            pub portworx_volume: Vec<models::PortworxVolumeSource>,
            pub projected: Vec<models::ProjectedVolumeSource>,
            pub quobyte: Vec<models::QuobyteVolumeSource>,
            pub rbd: Vec<models::RbdVolumeSource>,
            pub scale_io: Vec<models::ScaleIoVolumeSource>,
            pub secret: Vec<models::SecretVolumeSource>,
            pub storageos: Vec<models::StorageOsVolumeSource>,
            pub vsphere_volume: Vec<models::VsphereVirtualDiskVolumeSource>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Volume".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "awsElasticBlockStore" => intermediate_rep.aws_elastic_block_store.push(<models::AwsElasticBlockStoreVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "azureDisk" => intermediate_rep.azure_disk.push(<models::AzureDiskVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "azureFile" => intermediate_rep.azure_file.push(<models::AzureFileVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cephfs" => intermediate_rep.cephfs.push(<models::CephFsVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cinder" => intermediate_rep.cinder.push(<models::CinderVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "configMap" => intermediate_rep.config_map.push(<models::ConfigMapVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "csi" => intermediate_rep.csi.push(<models::CsiVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "downwardAPI" => intermediate_rep.downward_api.push(<models::DownwardApiVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "emptyDir" => intermediate_rep.empty_dir.push(<models::EmptyDirVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ephemeral" => intermediate_rep.ephemeral.push(<models::EphemeralVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fc" => intermediate_rep.fc.push(<models::FcVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "flexVolume" => intermediate_rep.flex_volume.push(<models::FlexVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "flocker" => intermediate_rep.flocker.push(<models::FlockerVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gcePersistentDisk" => intermediate_rep.gce_persistent_disk.push(<models::GcePersistentDiskVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gitRepo" => intermediate_rep.git_repo.push(<models::GitRepoVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "glusterfs" => intermediate_rep.glusterfs.push(<models::GlusterfsVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hostPath" => intermediate_rep.host_path.push(<models::HostPathVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "iscsi" => intermediate_rep.iscsi.push(<models::IscsiVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "nfs" => intermediate_rep.nfs.push(<models::NfsVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "persistentVolumeClaim" => intermediate_rep.persistent_volume_claim.push(<models::PersistentVolumeClaimVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "photonPersistentDisk" => intermediate_rep.photon_persistent_disk.push(<models::PhotonPersistentDiskVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "portworxVolume" => intermediate_rep.portworx_volume.push(<models::PortworxVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "projected" => intermediate_rep.projected.push(<models::ProjectedVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "quobyte" => intermediate_rep.quobyte.push(<models::QuobyteVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rbd" => intermediate_rep.rbd.push(<models::RbdVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "scaleIO" => intermediate_rep.scale_io.push(<models::ScaleIoVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "secret" => intermediate_rep.secret.push(<models::SecretVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "storageos" => intermediate_rep.storageos.push(<models::StorageOsVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vsphereVolume" => intermediate_rep.vsphere_volume.push(<models::VsphereVirtualDiskVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Volume".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Volume {
            aws_elastic_block_store: intermediate_rep.aws_elastic_block_store.into_iter().next(),
            azure_disk: intermediate_rep.azure_disk.into_iter().next(),
            azure_file: intermediate_rep.azure_file.into_iter().next(),
            cephfs: intermediate_rep.cephfs.into_iter().next(),
            cinder: intermediate_rep.cinder.into_iter().next(),
            config_map: intermediate_rep.config_map.into_iter().next(),
            csi: intermediate_rep.csi.into_iter().next(),
            downward_api: intermediate_rep.downward_api.into_iter().next(),
            empty_dir: intermediate_rep.empty_dir.into_iter().next(),
            ephemeral: intermediate_rep.ephemeral.into_iter().next(),
            fc: intermediate_rep.fc.into_iter().next(),
            flex_volume: intermediate_rep.flex_volume.into_iter().next(),
            flocker: intermediate_rep.flocker.into_iter().next(),
            gce_persistent_disk: intermediate_rep.gce_persistent_disk.into_iter().next(),
            git_repo: intermediate_rep.git_repo.into_iter().next(),
            glusterfs: intermediate_rep.glusterfs.into_iter().next(),
            host_path: intermediate_rep.host_path.into_iter().next(),
            iscsi: intermediate_rep.iscsi.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            nfs: intermediate_rep.nfs.into_iter().next(),
            persistent_volume_claim: intermediate_rep.persistent_volume_claim.into_iter().next(),
            photon_persistent_disk: intermediate_rep.photon_persistent_disk.into_iter().next(),
            portworx_volume: intermediate_rep.portworx_volume.into_iter().next(),
            projected: intermediate_rep.projected.into_iter().next(),
            quobyte: intermediate_rep.quobyte.into_iter().next(),
            rbd: intermediate_rep.rbd.into_iter().next(),
            scale_io: intermediate_rep.scale_io.into_iter().next(),
            secret: intermediate_rep.secret.into_iter().next(),
            storageos: intermediate_rep.storageos.into_iter().next(),
            vsphere_volume: intermediate_rep.vsphere_volume.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Volume> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Volume>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Volume>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Volume - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Volume> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Volume as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Volume - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// VolumeCreateBody Volume configuration



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VolumeCreateBody {
/// Name of the volume driver to use.
    #[serde(rename = "Driver")]
    pub driver: String,

/// A mapping of driver options and values. These options are passed directly to the driver and are driver specific.
    #[serde(rename = "DriverOpts")]
    pub driver_opts: std::collections::HashMap<String, String>,

/// User-defined key/value metadata.
    #[serde(rename = "Labels")]
    pub labels: std::collections::HashMap<String, String>,

/// The new volume's name. If not specified, Docker generates a name.
    #[serde(rename = "Name")]
    pub name: String,

}


impl VolumeCreateBody {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(driver: String, driver_opts: std::collections::HashMap<String, String>, labels: std::collections::HashMap<String, String>, name: String, ) -> VolumeCreateBody {
        VolumeCreateBody {
            driver,
            driver_opts,
            labels,
            name,
        }
    }
}

/// Converts the VolumeCreateBody value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for VolumeCreateBody {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("Driver".to_string()),
            Some(self.driver.to_string()),

            // Skipping DriverOpts in query parameter serialization

            // Skipping Labels in query parameter serialization


            Some("Name".to_string()),
            Some(self.name.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VolumeCreateBody value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VolumeCreateBody {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub driver: Vec<String>,
            pub driver_opts: Vec<std::collections::HashMap<String, String>>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VolumeCreateBody".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Driver" => intermediate_rep.driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "DriverOpts" => return std::result::Result::Err("Parsing a container in this style is not supported in VolumeCreateBody".to_string()),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in VolumeCreateBody".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VolumeCreateBody".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VolumeCreateBody {
            driver: intermediate_rep.driver.into_iter().next().ok_or_else(|| "Driver missing in VolumeCreateBody".to_string())?,
            driver_opts: intermediate_rep.driver_opts.into_iter().next().ok_or_else(|| "DriverOpts missing in VolumeCreateBody".to_string())?,
            labels: intermediate_rep.labels.into_iter().next().ok_or_else(|| "Labels missing in VolumeCreateBody".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "Name missing in VolumeCreateBody".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VolumeCreateBody> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VolumeCreateBody>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VolumeCreateBody>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for VolumeCreateBody - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VolumeCreateBody> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VolumeCreateBody as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into VolumeCreateBody - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VolumeDevice {
/// devicePath is the path inside of the container that the device will be mapped to.
    #[serde(rename = "devicePath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_path: Option<String>,

/// name must match the name of a persistentVolumeClaim in the pod
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl VolumeDevice {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> VolumeDevice {
        VolumeDevice {
            device_path: None,
            name: None,
        }
    }
}

/// Converts the VolumeDevice value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for VolumeDevice {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.device_path.as_ref().map(|device_path| {
                [
                    "devicePath".to_string(),
                    device_path.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VolumeDevice value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VolumeDevice {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub device_path: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VolumeDevice".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "devicePath" => intermediate_rep.device_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VolumeDevice".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VolumeDevice {
            device_path: intermediate_rep.device_path.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VolumeDevice> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VolumeDevice>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VolumeDevice>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for VolumeDevice - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VolumeDevice> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VolumeDevice as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into VolumeDevice - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// VolumeListOKBody Volume list response



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VolumeListOkBody {
/// List of volumes
    #[serde(rename = "Volumes")]
    pub volumes: Vec<models::Volume>,

/// Warnings that occurred when fetching the list of volumes.
    #[serde(rename = "Warnings")]
    pub warnings: Vec<String>,

}


impl VolumeListOkBody {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(volumes: Vec<models::Volume>, warnings: Vec<String>, ) -> VolumeListOkBody {
        VolumeListOkBody {
            volumes,
            warnings,
        }
    }
}

/// Converts the VolumeListOkBody value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for VolumeListOkBody {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping Volumes in query parameter serialization


            Some("Warnings".to_string()),
            Some(self.warnings.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VolumeListOkBody value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VolumeListOkBody {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub volumes: Vec<Vec<models::Volume>>,
            pub warnings: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VolumeListOkBody".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in VolumeListOkBody".to_string()),
                    "Warnings" => return std::result::Result::Err("Parsing a container in this style is not supported in VolumeListOkBody".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing VolumeListOkBody".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VolumeListOkBody {
            volumes: intermediate_rep.volumes.into_iter().next().ok_or_else(|| "Volumes missing in VolumeListOkBody".to_string())?,
            warnings: intermediate_rep.warnings.into_iter().next().ok_or_else(|| "Warnings missing in VolumeListOkBody".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VolumeListOkBody> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VolumeListOkBody>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VolumeListOkBody>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for VolumeListOkBody - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VolumeListOkBody> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VolumeListOkBody as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into VolumeListOkBody - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VolumeMount {
/// Path within the container at which the volume should be mounted.  Must not contain ':'.
    #[serde(rename = "mountPath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mount_path: Option<String>,

/// +enum
    #[serde(rename = "mountPropagation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mount_propagation: Option<String>,

/// This must match the Name of a Volume.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. +optional
    #[serde(rename = "readOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

/// Path within the volume from which the container's volume should be mounted. Defaults to \"\" (volume's root). +optional
    #[serde(rename = "subPath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_path: Option<String>,

/// Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to \"\" (volume's root). SubPathExpr and SubPath are mutually exclusive. +optional
    #[serde(rename = "subPathExpr")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_path_expr: Option<String>,

}


impl VolumeMount {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> VolumeMount {
        VolumeMount {
            mount_path: None,
            mount_propagation: None,
            name: None,
            read_only: None,
            sub_path: None,
            sub_path_expr: None,
        }
    }
}

/// Converts the VolumeMount value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for VolumeMount {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.mount_path.as_ref().map(|mount_path| {
                [
                    "mountPath".to_string(),
                    mount_path.to_string(),
                ].join(",")
            }),


            self.mount_propagation.as_ref().map(|mount_propagation| {
                [
                    "mountPropagation".to_string(),
                    mount_propagation.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.read_only.as_ref().map(|read_only| {
                [
                    "readOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),


            self.sub_path.as_ref().map(|sub_path| {
                [
                    "subPath".to_string(),
                    sub_path.to_string(),
                ].join(",")
            }),


            self.sub_path_expr.as_ref().map(|sub_path_expr| {
                [
                    "subPathExpr".to_string(),
                    sub_path_expr.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VolumeMount value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VolumeMount {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mount_path: Vec<String>,
            pub mount_propagation: Vec<String>,
            pub name: Vec<String>,
            pub read_only: Vec<bool>,
            pub sub_path: Vec<String>,
            pub sub_path_expr: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VolumeMount".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "mountPath" => intermediate_rep.mount_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mountPropagation" => intermediate_rep.mount_propagation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "readOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "subPath" => intermediate_rep.sub_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "subPathExpr" => intermediate_rep.sub_path_expr.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VolumeMount".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VolumeMount {
            mount_path: intermediate_rep.mount_path.into_iter().next(),
            mount_propagation: intermediate_rep.mount_propagation.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            read_only: intermediate_rep.read_only.into_iter().next(),
            sub_path: intermediate_rep.sub_path.into_iter().next(),
            sub_path_expr: intermediate_rep.sub_path_expr.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VolumeMount> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VolumeMount>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VolumeMount>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for VolumeMount - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VolumeMount> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VolumeMount as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into VolumeMount - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VolumeOptions {
    #[serde(rename = "DriverConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver_config: Option<models::Driver>,

    #[serde(rename = "Labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "NoCopy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub no_copy: Option<bool>,

}


impl VolumeOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> VolumeOptions {
        VolumeOptions {
            driver_config: None,
            labels: None,
            no_copy: None,
        }
    }
}

/// Converts the VolumeOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for VolumeOptions {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping DriverConfig in query parameter serialization

            // Skipping Labels in query parameter serialization


            self.no_copy.as_ref().map(|no_copy| {
                [
                    "NoCopy".to_string(),
                    no_copy.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VolumeOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VolumeOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub driver_config: Vec<models::Driver>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub no_copy: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VolumeOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "DriverConfig" => intermediate_rep.driver_config.push(<models::Driver as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in VolumeOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "NoCopy" => intermediate_rep.no_copy.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VolumeOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VolumeOptions {
            driver_config: intermediate_rep.driver_config.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            no_copy: intermediate_rep.no_copy.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VolumeOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VolumeOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VolumeOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for VolumeOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VolumeOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VolumeOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into VolumeOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Projection that may be projected along with other supported volume types



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VolumeProjection {
    #[serde(rename = "configMap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub config_map: Option<models::ConfigMapProjection>,

    #[serde(rename = "downwardAPI")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub downward_api: Option<models::DownwardApiProjection>,

    #[serde(rename = "secret")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret: Option<models::SecretProjection>,

    #[serde(rename = "serviceAccountToken")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_account_token: Option<models::ServiceAccountTokenProjection>,

}


impl VolumeProjection {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> VolumeProjection {
        VolumeProjection {
            config_map: None,
            downward_api: None,
            secret: None,
            service_account_token: None,
        }
    }
}

/// Converts the VolumeProjection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for VolumeProjection {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping configMap in query parameter serialization

            // Skipping downwardAPI in query parameter serialization

            // Skipping secret in query parameter serialization

            // Skipping serviceAccountToken in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VolumeProjection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VolumeProjection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub config_map: Vec<models::ConfigMapProjection>,
            pub downward_api: Vec<models::DownwardApiProjection>,
            pub secret: Vec<models::SecretProjection>,
            pub service_account_token: Vec<models::ServiceAccountTokenProjection>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VolumeProjection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "configMap" => intermediate_rep.config_map.push(<models::ConfigMapProjection as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "downwardAPI" => intermediate_rep.downward_api.push(<models::DownwardApiProjection as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "secret" => intermediate_rep.secret.push(<models::SecretProjection as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "serviceAccountToken" => intermediate_rep.service_account_token.push(<models::ServiceAccountTokenProjection as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VolumeProjection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VolumeProjection {
            config_map: intermediate_rep.config_map.into_iter().next(),
            downward_api: intermediate_rep.downward_api.into_iter().next(),
            secret: intermediate_rep.secret.into_iter().next(),
            service_account_token: intermediate_rep.service_account_token.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VolumeProjection> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VolumeProjection>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VolumeProjection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for VolumeProjection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VolumeProjection> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VolumeProjection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into VolumeProjection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Only one of its members may be specified.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VolumeSource {
    #[serde(rename = "awsElasticBlockStore")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub aws_elastic_block_store: Option<models::AwsElasticBlockStoreVolumeSource>,

    #[serde(rename = "azureDisk")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub azure_disk: Option<models::AzureDiskVolumeSource>,

    #[serde(rename = "azureFile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub azure_file: Option<models::AzureFileVolumeSource>,

    #[serde(rename = "cephfs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cephfs: Option<models::CephFsVolumeSource>,

    #[serde(rename = "cinder")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cinder: Option<models::CinderVolumeSource>,

    #[serde(rename = "configMap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub config_map: Option<models::ConfigMapVolumeSource>,

    #[serde(rename = "csi")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub csi: Option<models::CsiVolumeSource>,

    #[serde(rename = "downwardAPI")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub downward_api: Option<models::DownwardApiVolumeSource>,

    #[serde(rename = "emptyDir")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub empty_dir: Option<models::EmptyDirVolumeSource>,

    #[serde(rename = "ephemeral")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ephemeral: Option<models::EphemeralVolumeSource>,

    #[serde(rename = "fc")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fc: Option<models::FcVolumeSource>,

    #[serde(rename = "flexVolume")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub flex_volume: Option<models::FlexVolumeSource>,

    #[serde(rename = "flocker")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub flocker: Option<models::FlockerVolumeSource>,

    #[serde(rename = "gcePersistentDisk")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gce_persistent_disk: Option<models::GcePersistentDiskVolumeSource>,

    #[serde(rename = "gitRepo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_repo: Option<models::GitRepoVolumeSource>,

    #[serde(rename = "glusterfs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub glusterfs: Option<models::GlusterfsVolumeSource>,

    #[serde(rename = "hostPath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_path: Option<models::HostPathVolumeSource>,

    #[serde(rename = "iscsi")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub iscsi: Option<models::IscsiVolumeSource>,

    #[serde(rename = "nfs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub nfs: Option<models::NfsVolumeSource>,

    #[serde(rename = "persistentVolumeClaim")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub persistent_volume_claim: Option<models::PersistentVolumeClaimVolumeSource>,

    #[serde(rename = "photonPersistentDisk")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub photon_persistent_disk: Option<models::PhotonPersistentDiskVolumeSource>,

    #[serde(rename = "portworxVolume")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub portworx_volume: Option<models::PortworxVolumeSource>,

    #[serde(rename = "projected")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub projected: Option<models::ProjectedVolumeSource>,

    #[serde(rename = "quobyte")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quobyte: Option<models::QuobyteVolumeSource>,

    #[serde(rename = "rbd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rbd: Option<models::RbdVolumeSource>,

    #[serde(rename = "scaleIO")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scale_io: Option<models::ScaleIoVolumeSource>,

    #[serde(rename = "secret")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret: Option<models::SecretVolumeSource>,

    #[serde(rename = "storageos")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storageos: Option<models::StorageOsVolumeSource>,

    #[serde(rename = "vsphereVolume")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vsphere_volume: Option<models::VsphereVirtualDiskVolumeSource>,

}


impl VolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> VolumeSource {
        VolumeSource {
            aws_elastic_block_store: None,
            azure_disk: None,
            azure_file: None,
            cephfs: None,
            cinder: None,
            config_map: None,
            csi: None,
            downward_api: None,
            empty_dir: None,
            ephemeral: None,
            fc: None,
            flex_volume: None,
            flocker: None,
            gce_persistent_disk: None,
            git_repo: None,
            glusterfs: None,
            host_path: None,
            iscsi: None,
            nfs: None,
            persistent_volume_claim: None,
            photon_persistent_disk: None,
            portworx_volume: None,
            projected: None,
            quobyte: None,
            rbd: None,
            scale_io: None,
            secret: None,
            storageos: None,
            vsphere_volume: None,
        }
    }
}

/// Converts the VolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for VolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping awsElasticBlockStore in query parameter serialization

            // Skipping azureDisk in query parameter serialization

            // Skipping azureFile in query parameter serialization

            // Skipping cephfs in query parameter serialization

            // Skipping cinder in query parameter serialization

            // Skipping configMap in query parameter serialization

            // Skipping csi in query parameter serialization

            // Skipping downwardAPI in query parameter serialization

            // Skipping emptyDir in query parameter serialization

            // Skipping ephemeral in query parameter serialization

            // Skipping fc in query parameter serialization

            // Skipping flexVolume in query parameter serialization

            // Skipping flocker in query parameter serialization

            // Skipping gcePersistentDisk in query parameter serialization

            // Skipping gitRepo in query parameter serialization

            // Skipping glusterfs in query parameter serialization

            // Skipping hostPath in query parameter serialization

            // Skipping iscsi in query parameter serialization

            // Skipping nfs in query parameter serialization

            // Skipping persistentVolumeClaim in query parameter serialization

            // Skipping photonPersistentDisk in query parameter serialization

            // Skipping portworxVolume in query parameter serialization

            // Skipping projected in query parameter serialization

            // Skipping quobyte in query parameter serialization

            // Skipping rbd in query parameter serialization

            // Skipping scaleIO in query parameter serialization

            // Skipping secret in query parameter serialization

            // Skipping storageos in query parameter serialization

            // Skipping vsphereVolume in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub aws_elastic_block_store: Vec<models::AwsElasticBlockStoreVolumeSource>,
            pub azure_disk: Vec<models::AzureDiskVolumeSource>,
            pub azure_file: Vec<models::AzureFileVolumeSource>,
            pub cephfs: Vec<models::CephFsVolumeSource>,
            pub cinder: Vec<models::CinderVolumeSource>,
            pub config_map: Vec<models::ConfigMapVolumeSource>,
            pub csi: Vec<models::CsiVolumeSource>,
            pub downward_api: Vec<models::DownwardApiVolumeSource>,
            pub empty_dir: Vec<models::EmptyDirVolumeSource>,
            pub ephemeral: Vec<models::EphemeralVolumeSource>,
            pub fc: Vec<models::FcVolumeSource>,
            pub flex_volume: Vec<models::FlexVolumeSource>,
            pub flocker: Vec<models::FlockerVolumeSource>,
            pub gce_persistent_disk: Vec<models::GcePersistentDiskVolumeSource>,
            pub git_repo: Vec<models::GitRepoVolumeSource>,
            pub glusterfs: Vec<models::GlusterfsVolumeSource>,
            pub host_path: Vec<models::HostPathVolumeSource>,
            pub iscsi: Vec<models::IscsiVolumeSource>,
            pub nfs: Vec<models::NfsVolumeSource>,
            pub persistent_volume_claim: Vec<models::PersistentVolumeClaimVolumeSource>,
            pub photon_persistent_disk: Vec<models::PhotonPersistentDiskVolumeSource>,
            pub portworx_volume: Vec<models::PortworxVolumeSource>,
            pub projected: Vec<models::ProjectedVolumeSource>,
            pub quobyte: Vec<models::QuobyteVolumeSource>,
            pub rbd: Vec<models::RbdVolumeSource>,
            pub scale_io: Vec<models::ScaleIoVolumeSource>,
            pub secret: Vec<models::SecretVolumeSource>,
            pub storageos: Vec<models::StorageOsVolumeSource>,
            pub vsphere_volume: Vec<models::VsphereVirtualDiskVolumeSource>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "awsElasticBlockStore" => intermediate_rep.aws_elastic_block_store.push(<models::AwsElasticBlockStoreVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "azureDisk" => intermediate_rep.azure_disk.push(<models::AzureDiskVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "azureFile" => intermediate_rep.azure_file.push(<models::AzureFileVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cephfs" => intermediate_rep.cephfs.push(<models::CephFsVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cinder" => intermediate_rep.cinder.push(<models::CinderVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "configMap" => intermediate_rep.config_map.push(<models::ConfigMapVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "csi" => intermediate_rep.csi.push(<models::CsiVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "downwardAPI" => intermediate_rep.downward_api.push(<models::DownwardApiVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "emptyDir" => intermediate_rep.empty_dir.push(<models::EmptyDirVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ephemeral" => intermediate_rep.ephemeral.push(<models::EphemeralVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fc" => intermediate_rep.fc.push(<models::FcVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "flexVolume" => intermediate_rep.flex_volume.push(<models::FlexVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "flocker" => intermediate_rep.flocker.push(<models::FlockerVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gcePersistentDisk" => intermediate_rep.gce_persistent_disk.push(<models::GcePersistentDiskVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gitRepo" => intermediate_rep.git_repo.push(<models::GitRepoVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "glusterfs" => intermediate_rep.glusterfs.push(<models::GlusterfsVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hostPath" => intermediate_rep.host_path.push(<models::HostPathVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "iscsi" => intermediate_rep.iscsi.push(<models::IscsiVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "nfs" => intermediate_rep.nfs.push(<models::NfsVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "persistentVolumeClaim" => intermediate_rep.persistent_volume_claim.push(<models::PersistentVolumeClaimVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "photonPersistentDisk" => intermediate_rep.photon_persistent_disk.push(<models::PhotonPersistentDiskVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "portworxVolume" => intermediate_rep.portworx_volume.push(<models::PortworxVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "projected" => intermediate_rep.projected.push(<models::ProjectedVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "quobyte" => intermediate_rep.quobyte.push(<models::QuobyteVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rbd" => intermediate_rep.rbd.push(<models::RbdVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "scaleIO" => intermediate_rep.scale_io.push(<models::ScaleIoVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "secret" => intermediate_rep.secret.push(<models::SecretVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "storageos" => intermediate_rep.storageos.push(<models::StorageOsVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vsphereVolume" => intermediate_rep.vsphere_volume.push(<models::VsphereVirtualDiskVolumeSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VolumeSource {
            aws_elastic_block_store: intermediate_rep.aws_elastic_block_store.into_iter().next(),
            azure_disk: intermediate_rep.azure_disk.into_iter().next(),
            azure_file: intermediate_rep.azure_file.into_iter().next(),
            cephfs: intermediate_rep.cephfs.into_iter().next(),
            cinder: intermediate_rep.cinder.into_iter().next(),
            config_map: intermediate_rep.config_map.into_iter().next(),
            csi: intermediate_rep.csi.into_iter().next(),
            downward_api: intermediate_rep.downward_api.into_iter().next(),
            empty_dir: intermediate_rep.empty_dir.into_iter().next(),
            ephemeral: intermediate_rep.ephemeral.into_iter().next(),
            fc: intermediate_rep.fc.into_iter().next(),
            flex_volume: intermediate_rep.flex_volume.into_iter().next(),
            flocker: intermediate_rep.flocker.into_iter().next(),
            gce_persistent_disk: intermediate_rep.gce_persistent_disk.into_iter().next(),
            git_repo: intermediate_rep.git_repo.into_iter().next(),
            glusterfs: intermediate_rep.glusterfs.into_iter().next(),
            host_path: intermediate_rep.host_path.into_iter().next(),
            iscsi: intermediate_rep.iscsi.into_iter().next(),
            nfs: intermediate_rep.nfs.into_iter().next(),
            persistent_volume_claim: intermediate_rep.persistent_volume_claim.into_iter().next(),
            photon_persistent_disk: intermediate_rep.photon_persistent_disk.into_iter().next(),
            portworx_volume: intermediate_rep.portworx_volume.into_iter().next(),
            projected: intermediate_rep.projected.into_iter().next(),
            quobyte: intermediate_rep.quobyte.into_iter().next(),
            rbd: intermediate_rep.rbd.into_iter().next(),
            scale_io: intermediate_rep.scale_io.into_iter().next(),
            secret: intermediate_rep.secret.into_iter().next(),
            storageos: intermediate_rep.storageos.into_iter().next(),
            vsphere_volume: intermediate_rep.vsphere_volume.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for VolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into VolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// VolumeUsageData Usage details about the volume. This information is used by the `GET /system/df` endpoint, and omitted in other endpoints.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VolumeUsageData {
/// The number of containers referencing this volume. This field is set to `-1` if the reference-count is not available.
    #[serde(rename = "RefCount")]
    pub ref_count: i64,

/// Amount of disk space used by the volume (in bytes). This information is only available for volumes created with the `\"local\"` volume driver. For volumes created with other volume drivers, this field is set to `-1` (\"not available\")
    #[serde(rename = "Size")]
    pub size: i64,

}


impl VolumeUsageData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(ref_count: i64, size: i64, ) -> VolumeUsageData {
        VolumeUsageData {
            ref_count,
            size,
        }
    }
}

/// Converts the VolumeUsageData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for VolumeUsageData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("RefCount".to_string()),
            Some(self.ref_count.to_string()),


            Some("Size".to_string()),
            Some(self.size.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VolumeUsageData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VolumeUsageData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ref_count: Vec<i64>,
            pub size: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VolumeUsageData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "RefCount" => intermediate_rep.ref_count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Size" => intermediate_rep.size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VolumeUsageData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VolumeUsageData {
            ref_count: intermediate_rep.ref_count.into_iter().next().ok_or_else(|| "RefCount missing in VolumeUsageData".to_string())?,
            size: intermediate_rep.size.into_iter().next().ok_or_else(|| "Size missing in VolumeUsageData".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VolumeUsageData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VolumeUsageData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VolumeUsageData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for VolumeUsageData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VolumeUsageData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VolumeUsageData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into VolumeUsageData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VsphereVirtualDiskVolumeSource {
/// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. +optional
    #[serde(rename = "fsType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fs_type: Option<String>,

/// Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName. +optional
    #[serde(rename = "storagePolicyID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_policy_id: Option<String>,

/// Storage Policy Based Management (SPBM) profile name. +optional
    #[serde(rename = "storagePolicyName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_policy_name: Option<String>,

/// Path that identifies vSphere volume vmdk
    #[serde(rename = "volumePath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_path: Option<String>,

}


impl VsphereVirtualDiskVolumeSource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> VsphereVirtualDiskVolumeSource {
        VsphereVirtualDiskVolumeSource {
            fs_type: None,
            storage_policy_id: None,
            storage_policy_name: None,
            volume_path: None,
        }
    }
}

/// Converts the VsphereVirtualDiskVolumeSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for VsphereVirtualDiskVolumeSource {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.fs_type.as_ref().map(|fs_type| {
                [
                    "fsType".to_string(),
                    fs_type.to_string(),
                ].join(",")
            }),


            self.storage_policy_id.as_ref().map(|storage_policy_id| {
                [
                    "storagePolicyID".to_string(),
                    storage_policy_id.to_string(),
                ].join(",")
            }),


            self.storage_policy_name.as_ref().map(|storage_policy_name| {
                [
                    "storagePolicyName".to_string(),
                    storage_policy_name.to_string(),
                ].join(",")
            }),


            self.volume_path.as_ref().map(|volume_path| {
                [
                    "volumePath".to_string(),
                    volume_path.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VsphereVirtualDiskVolumeSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VsphereVirtualDiskVolumeSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub fs_type: Vec<String>,
            pub storage_policy_id: Vec<String>,
            pub storage_policy_name: Vec<String>,
            pub volume_path: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VsphereVirtualDiskVolumeSource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "fsType" => intermediate_rep.fs_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "storagePolicyID" => intermediate_rep.storage_policy_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "storagePolicyName" => intermediate_rep.storage_policy_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "volumePath" => intermediate_rep.volume_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VsphereVirtualDiskVolumeSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VsphereVirtualDiskVolumeSource {
            fs_type: intermediate_rep.fs_type.into_iter().next(),
            storage_policy_id: intermediate_rep.storage_policy_id.into_iter().next(),
            storage_policy_name: intermediate_rep.storage_policy_name.into_iter().next(),
            volume_path: intermediate_rep.volume_path.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VsphereVirtualDiskVolumeSource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VsphereVirtualDiskVolumeSource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VsphereVirtualDiskVolumeSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for VsphereVirtualDiskVolumeSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VsphereVirtualDiskVolumeSource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VsphereVirtualDiskVolumeSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into VsphereVirtualDiskVolumeSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// WeightDevice is a structure that holds device:weight pair



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WeightDevice {
    #[serde(rename = "Path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

    #[serde(rename = "Weight")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight: Option<i32>,

}


impl WeightDevice {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> WeightDevice {
        WeightDevice {
            path: None,
            weight: None,
        }
    }
}

/// Converts the WeightDevice value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for WeightDevice {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.path.as_ref().map(|path| {
                [
                    "Path".to_string(),
                    path.to_string(),
                ].join(",")
            }),


            self.weight.as_ref().map(|weight| {
                [
                    "Weight".to_string(),
                    weight.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WeightDevice value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WeightDevice {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub path: Vec<String>,
            pub weight: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing WeightDevice".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Weight" => intermediate_rep.weight.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing WeightDevice".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WeightDevice {
            path: intermediate_rep.path.into_iter().next(),
            weight: intermediate_rep.weight.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WeightDevice> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<WeightDevice>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<WeightDevice>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for WeightDevice - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<WeightDevice> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <WeightDevice as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into WeightDevice - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WeightedPodAffinityTerm {
    #[serde(rename = "podAffinityTerm")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pod_affinity_term: Option<models::PodAffinityTerm>,

/// weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
    #[serde(rename = "weight")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight: Option<i32>,

}


impl WeightedPodAffinityTerm {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> WeightedPodAffinityTerm {
        WeightedPodAffinityTerm {
            pod_affinity_term: None,
            weight: None,
        }
    }
}

/// Converts the WeightedPodAffinityTerm value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for WeightedPodAffinityTerm {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping podAffinityTerm in query parameter serialization


            self.weight.as_ref().map(|weight| {
                [
                    "weight".to_string(),
                    weight.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WeightedPodAffinityTerm value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WeightedPodAffinityTerm {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pod_affinity_term: Vec<models::PodAffinityTerm>,
            pub weight: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing WeightedPodAffinityTerm".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "podAffinityTerm" => intermediate_rep.pod_affinity_term.push(<models::PodAffinityTerm as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "weight" => intermediate_rep.weight.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing WeightedPodAffinityTerm".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WeightedPodAffinityTerm {
            pod_affinity_term: intermediate_rep.pod_affinity_term.into_iter().next(),
            weight: intermediate_rep.weight.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WeightedPodAffinityTerm> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<WeightedPodAffinityTerm>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<WeightedPodAffinityTerm>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for WeightedPodAffinityTerm - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<WeightedPodAffinityTerm> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <WeightedPodAffinityTerm as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into WeightedPodAffinityTerm - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WindowsSecurityContextOptions {
/// GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field. +optional
    #[serde(rename = "gmsaCredentialSpec")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gmsa_credential_spec: Option<String>,

/// GMSACredentialSpecName is the name of the GMSA credential spec to use. +optional
    #[serde(rename = "gmsaCredentialSpecName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gmsa_credential_spec_name: Option<String>,

/// HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true. +optional
    #[serde(rename = "hostProcess")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_process: Option<bool>,

/// The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. +optional
    #[serde(rename = "runAsUserName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_as_user_name: Option<String>,

}


impl WindowsSecurityContextOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> WindowsSecurityContextOptions {
        WindowsSecurityContextOptions {
            gmsa_credential_spec: None,
            gmsa_credential_spec_name: None,
            host_process: None,
            run_as_user_name: None,
        }
    }
}

/// Converts the WindowsSecurityContextOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for WindowsSecurityContextOptions {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.gmsa_credential_spec.as_ref().map(|gmsa_credential_spec| {
                [
                    "gmsaCredentialSpec".to_string(),
                    gmsa_credential_spec.to_string(),
                ].join(",")
            }),


            self.gmsa_credential_spec_name.as_ref().map(|gmsa_credential_spec_name| {
                [
                    "gmsaCredentialSpecName".to_string(),
                    gmsa_credential_spec_name.to_string(),
                ].join(",")
            }),


            self.host_process.as_ref().map(|host_process| {
                [
                    "hostProcess".to_string(),
                    host_process.to_string(),
                ].join(",")
            }),


            self.run_as_user_name.as_ref().map(|run_as_user_name| {
                [
                    "runAsUserName".to_string(),
                    run_as_user_name.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WindowsSecurityContextOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WindowsSecurityContextOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub gmsa_credential_spec: Vec<String>,
            pub gmsa_credential_spec_name: Vec<String>,
            pub host_process: Vec<bool>,
            pub run_as_user_name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing WindowsSecurityContextOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "gmsaCredentialSpec" => intermediate_rep.gmsa_credential_spec.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gmsaCredentialSpecName" => intermediate_rep.gmsa_credential_spec_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hostProcess" => intermediate_rep.host_process.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "runAsUserName" => intermediate_rep.run_as_user_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing WindowsSecurityContextOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WindowsSecurityContextOptions {
            gmsa_credential_spec: intermediate_rep.gmsa_credential_spec.into_iter().next(),
            gmsa_credential_spec_name: intermediate_rep.gmsa_credential_spec_name.into_iter().next(),
            host_process: intermediate_rep.host_process.into_iter().next(),
            run_as_user_name: intermediate_rep.run_as_user_name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WindowsSecurityContextOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<WindowsSecurityContextOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<WindowsSecurityContextOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for WindowsSecurityContextOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<WindowsSecurityContextOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <WindowsSecurityContextOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into WindowsSecurityContextOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}



